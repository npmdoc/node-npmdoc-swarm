<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://github.com/gritzko/swarm"

    >swarm (v0.3.25)</a>
</h1>
<h4>_reactive data sync lib: replicated model for your web app_</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm">module swarm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.EinarosWSStream">
            function <span class="apidocSignatureSpan">swarm.</span>EinarosWSStream
            <span class="apidocSignatureSpan">(ws)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.FileStorage">
            function <span class="apidocSignatureSpan">swarm.</span>FileStorage
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host">
            function <span class="apidocSignatureSpan">swarm.</span>Host
            <span class="apidocSignatureSpan">(id, ms, storage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LamportClock">
            function <span class="apidocSignatureSpan">swarm.</span>LamportClock
            <span class="apidocSignatureSpan">(processId, initTime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LevelStorage">
            function <span class="apidocSignatureSpan">swarm.</span>LevelStorage
            <span class="apidocSignatureSpan">(id, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec">
            function <span class="apidocSignatureSpan">swarm.</span>LongSpec
            <span class="apidocSignatureSpan">(spec, codeBook)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator">
            function <span class="apidocSignatureSpan">swarm.</span>LongSpec.Iterator
            <span class="apidocSignatureSpan">(owner, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.MinutePreciseClock">
            function <span class="apidocSignatureSpan">swarm.</span>MinutePreciseClock
            <span class="apidocSignatureSpan">(processId, timeOffsetMs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model">
            function <span class="apidocSignatureSpan">swarm.</span>Model
            <span class="apidocSignatureSpan">(idOrState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Pipe">
            function <span class="apidocSignatureSpan">swarm.</span>Pipe
            <span class="apidocSignatureSpan">(host, stream, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.ProxyListener">
            function <span class="apidocSignatureSpan">swarm.</span>ProxyListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SecondPreciseClock">
            function <span class="apidocSignatureSpan">swarm.</span>SecondPreciseClock
            <span class="apidocSignatureSpan">(processId, timeOffsetMs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set">
            function <span class="apidocSignatureSpan">swarm.</span>Set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SharedWebStorage">
            function <span class="apidocSignatureSpan">swarm.</span>SharedWebStorage
            <span class="apidocSignatureSpan">(id, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SockJSServerStream">
            function <span class="apidocSignatureSpan">swarm.</span>SockJSServerStream
            <span class="apidocSignatureSpan">(ws)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec">
            function <span class="apidocSignatureSpan">swarm.</span>Spec
            <span class="apidocSignatureSpan">(str, quant)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.Map">
            function <span class="apidocSignatureSpan">swarm.</span>Spec.Map
            <span class="apidocSignatureSpan">(vec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Storage">
            function <span class="apidocSignatureSpan">swarm.</span>Storage
            <span class="apidocSignatureSpan">(async)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable">
            function <span class="apidocSignatureSpan">swarm.</span>Syncable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Text">
            function <span class="apidocSignatureSpan">swarm.</span>Text
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector">
            function <span class="apidocSignatureSpan">swarm.</span>Vector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.WebSocketStream">
            function <span class="apidocSignatureSpan">swarm.</span>WebSocketStream
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>CollectionMethodsMixin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>EinarosWSStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>FileStorage.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Host.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Host.prototype._neutrals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Host.prototype._ops</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>LamportClock.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>LevelStorage.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>LongSpec.Iterator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>LongSpec.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>MinutePreciseClock.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Model.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Model.prototype._neutrals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Model.prototype._ops</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Pipe.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>ProxyListener.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>ReactMixin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>SecondPreciseClock.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Set.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Set.prototype._neutrals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Set.prototype._ops</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>SharedWebStorage.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>SockJSServerStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Spec.Map.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Spec.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Storage.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Syncable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Syncable.prototype._neutrals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Syncable.prototype._ops</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Syncable.types</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Syncable.types.Text.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Vector.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Vector.prototype._neutrals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>Vector.prototype._ops</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>env</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>env.streams</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>env.streams.loopback.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.</span>env.streams.wss.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.</span>profile</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.CollectionMethodsMixin">module swarm.CollectionMethodsMixin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.CollectionMethodsMixin.offObjectEvent">
            function <span class="apidocSignatureSpan">swarm.CollectionMethodsMixin.</span>offObjectEvent
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.CollectionMethodsMixin.onObjectEvent">
            function <span class="apidocSignatureSpan">swarm.CollectionMethodsMixin.</span>onObjectEvent
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.CollectionMethodsMixin.onObjectStateReady">
            function <span class="apidocSignatureSpan">swarm.CollectionMethodsMixin.</span>onObjectStateReady
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.EinarosWSStream">module swarm.EinarosWSStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.EinarosWSStream.EinarosWSStream">
            function <span class="apidocSignatureSpan">swarm.</span>EinarosWSStream
            <span class="apidocSignatureSpan">(ws)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.EinarosWSStream.prototype">module swarm.EinarosWSStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.EinarosWSStream.prototype.on">
            function <span class="apidocSignatureSpan">swarm.EinarosWSStream.prototype.</span>on
            <span class="apidocSignatureSpan">(evname, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.EinarosWSStream.prototype.write">
            function <span class="apidocSignatureSpan">swarm.EinarosWSStream.prototype.</span>write
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.FileStorage">module swarm.FileStorage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.FileStorage.FileStorage">
            function <span class="apidocSignatureSpan">swarm.</span>FileStorage
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.FileStorage.prototype">module swarm.FileStorage.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>async</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.FileStorage.prototype.close">
            function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>close
            <span class="apidocSignatureSpan">(callback, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.FileStorage.prototype.loadLog">
            function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>loadLog
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.FileStorage.prototype.logFileName">
            function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>logFileName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.FileStorage.prototype.readOps">
            function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>readOps
            <span class="apidocSignatureSpan">(ti, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.FileStorage.prototype.readState">
            function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>readState
            <span class="apidocSignatureSpan">(ti, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.FileStorage.prototype.rotateLog">
            function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>rotateLog
            <span class="apidocSignatureSpan">(noOpen, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.FileStorage.prototype.stateFileName">
            function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>stateFileName
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.FileStorage.prototype.writeOp">
            function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>writeOp
            <span class="apidocSignatureSpan">(spec, value, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.FileStorage.prototype.writeState">
            function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>writeState
            <span class="apidocSignatureSpan">(spec, state, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>_host</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>counts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>lstn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>states</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>tails</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>_id</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Host">module swarm.Host</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.Host">
            function <span class="apidocSignatureSpan">swarm.</span>Host
            <span class="apidocSignatureSpan">(id, ms, storage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host._super">
            function <span class="apidocSignatureSpan">swarm.Host.</span>_super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.addReaction">
            function <span class="apidocSignatureSpan">swarm.Host.</span>addReaction
            <span class="apidocSignatureSpan">(op, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.extend">
            function <span class="apidocSignatureSpan">swarm.Host.</span>extend
            <span class="apidocSignatureSpan">(fn, own)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.hashDistance">
            function <span class="apidocSignatureSpan">swarm.Host.</span>hashDistance
            <span class="apidocSignatureSpan">(peer, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.removeReaction">
            function <span class="apidocSignatureSpan">swarm.Host.</span>removeReaction
            <span class="apidocSignatureSpan">(handle)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">swarm.Host.</span>HASH_POINTS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">swarm.Host.</span>MAX_INT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">swarm.Host.</span>MAX_SYNC_TIME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Host.</span>_pt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Host.</span>defaults</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Host.prototype">module swarm.Host.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.accept">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>accept
            <span class="apidocSignatureSpan">(stream_or_url, pipe_env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.addSource">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>addSource
            <span class="apidocSignatureSpan">(spec, peer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.callReactions">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>callReactions
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.checkUplink">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>checkUplink
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.close">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.connect">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>connect
            <span class="apidocSignatureSpan">(stream_or_url, pipe_env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.constructor">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>constructor
            <span class="apidocSignatureSpan">(id, ms, storage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.deliver">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>deliver
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.disconnect">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>disconnect
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.get">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>get
            <span class="apidocSignatureSpan">(spec, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.getSources">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>getSources
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.init">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>init
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.isServer">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>isServer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.isUplinked">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>isUplinked
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.off">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>off
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.on">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.register">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>register
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.removeSource">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>removeSource
            <span class="apidocSignatureSpan">(spec, peer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.reoff">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>reoff
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.reon">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>reon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.time">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>time
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype.unregister">
            function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>unregister
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Host.prototype.</span>_neutrals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Host.prototype.</span>_ops</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Host.prototype.</span>_reactions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Host.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.Host.prototype.</span>_type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Host.prototype._neutrals">module swarm.Host.prototype._neutrals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype._neutrals.error">
            function <span class="apidocSignatureSpan">swarm.Host.prototype._neutrals.</span>error
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype._neutrals.off">
            function <span class="apidocSignatureSpan">swarm.Host.prototype._neutrals.</span>off
            <span class="apidocSignatureSpan">(spec, nothing, peer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype._neutrals.on">
            function <span class="apidocSignatureSpan">swarm.Host.prototype._neutrals.</span>on
            <span class="apidocSignatureSpan">(spec, filter, lstn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype._neutrals.reoff">
            function <span class="apidocSignatureSpan">swarm.Host.prototype._neutrals.</span>reoff
            <span class="apidocSignatureSpan">(spec, nothing, peer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype._neutrals.reon">
            function <span class="apidocSignatureSpan">swarm.Host.prototype._neutrals.</span>reon
            <span class="apidocSignatureSpan">(spec, ms, host)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Host.prototype._ops">module swarm.Host.prototype._ops</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Host.prototype._ops.init">
            function <span class="apidocSignatureSpan">swarm.Host.prototype._ops.</span>init
            <span class="apidocSignatureSpan">(spec, state, src)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.LamportClock">module swarm.LamportClock</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LamportClock.LamportClock">
            function <span class="apidocSignatureSpan">swarm.</span>LamportClock
            <span class="apidocSignatureSpan">(processId, initTime)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.LamportClock.prototype">module swarm.LamportClock.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LamportClock.prototype.adjustTime">
            function <span class="apidocSignatureSpan">swarm.LamportClock.prototype.</span>adjustTime
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LamportClock.prototype.checkTimestamp">
            function <span class="apidocSignatureSpan">swarm.LamportClock.prototype.</span>checkTimestamp
            <span class="apidocSignatureSpan">(ts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LamportClock.prototype.issueTimestamp">
            function <span class="apidocSignatureSpan">swarm.LamportClock.prototype.</span>issueTimestamp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LamportClock.prototype.parseTimestamp">
            function <span class="apidocSignatureSpan">swarm.LamportClock.prototype.</span>parseTimestamp
            <span class="apidocSignatureSpan">(ts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LamportClock.prototype.time2date">
            function <span class="apidocSignatureSpan">swarm.LamportClock.prototype.</span>time2date
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.LevelStorage">module swarm.LevelStorage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LevelStorage.LevelStorage">
            function <span class="apidocSignatureSpan">swarm.</span>LevelStorage
            <span class="apidocSignatureSpan">(id, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.LevelStorage.prototype">module swarm.LevelStorage.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>async</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>isRoot</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LevelStorage.prototype.close">
            function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>close
            <span class="apidocSignatureSpan">(callback, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LevelStorage.prototype.off">
            function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>off
            <span class="apidocSignatureSpan">(spec, val, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LevelStorage.prototype.open">
            function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>open
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LevelStorage.prototype.readOps">
            function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>readOps
            <span class="apidocSignatureSpan">(ti, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LevelStorage.prototype.readState">
            function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>readState
            <span class="apidocSignatureSpan">(ti, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LevelStorage.prototype.writeOp">
            function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>writeOp
            <span class="apidocSignatureSpan">(spec, value, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LevelStorage.prototype.writeState">
            function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>writeState
            <span class="apidocSignatureSpan">(spec, state, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>_host</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>counts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>lstn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>states</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>tails</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>_id</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.LongSpec">module swarm.LongSpec</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.LongSpec">
            function <span class="apidocSignatureSpan">swarm.</span>LongSpec
            <span class="apidocSignatureSpan">(spec, codeBook)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator">
            function <span class="apidocSignatureSpan">swarm.LongSpec.</span>Iterator
            <span class="apidocSignatureSpan">(owner, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.int2uni">
            function <span class="apidocSignatureSpan">swarm.LongSpec.</span>int2uni
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.uni2int">
            function <span class="apidocSignatureSpan">swarm.LongSpec.</span>uni2int
            <span class="apidocSignatureSpan">(uni)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.LongSpec.</span>quants2code</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.LongSpec.</span>reQTok</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.LongSpec.</span>reQTokEn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.LongSpec.</span>reQTokExtEn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.LongSpec.</span>rTEn</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.LongSpec.Iterator">module swarm.LongSpec.Iterator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator.Iterator">
            function <span class="apidocSignatureSpan">swarm.LongSpec.</span>Iterator
            <span class="apidocSignatureSpan">(owner, index)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.</span>reTok</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.LongSpec.Iterator.prototype">module swarm.LongSpec.Iterator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator.prototype.clone">
            function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator.prototype.decode">
            function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>decode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator.prototype.encode">
            function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>encode
            <span class="apidocSignatureSpan">(de)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator.prototype.end">
            function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator.prototype.erase">
            function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>erase
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator.prototype.insert">
            function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>insert
            <span class="apidocSignatureSpan">(de)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator.prototype.insertBlock">
            function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>insertBlock
            <span class="apidocSignatureSpan">(de)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator.prototype.next">
            function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>next
            <span class="apidocSignatureSpan">( )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator.prototype.skip">
            function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>skip
            <span class="apidocSignatureSpan">( count )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator.prototype.skip2chunk">
            function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>skip2chunk
            <span class="apidocSignatureSpan">( chunk )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.Iterator.prototype.token">
            function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>token
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.LongSpec.prototype">module swarm.LongSpec.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.prototype.add">
            function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>add
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.prototype.allocateCode">
            function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>allocateCode
            <span class="apidocSignatureSpan">(tok)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.prototype.append">
            function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>append
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.prototype.charLength">
            function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>charLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.prototype.end">
            function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.prototype.find">
            function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>find
            <span class="apidocSignatureSpan">(tok, startIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.prototype.indexOf">
            function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(tok, startAt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.prototype.insert">
            function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>insert
            <span class="apidocSignatureSpan">(tok, i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.prototype.iterator">
            function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>iterator
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.prototype.length">
            function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.prototype.toString">
            function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.LongSpec.prototype.tokenAt">
            function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>tokenAt
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.MinutePreciseClock">module swarm.MinutePreciseClock</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.MinutePreciseClock.MinutePreciseClock">
            function <span class="apidocSignatureSpan">swarm.</span>MinutePreciseClock
            <span class="apidocSignatureSpan">(processId, timeOffsetMs)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">swarm.MinutePreciseClock.</span>EPOCH</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.MinutePreciseClock.prototype">module swarm.MinutePreciseClock.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.MinutePreciseClock.prototype.adjustTime">
            function <span class="apidocSignatureSpan">swarm.MinutePreciseClock.prototype.</span>adjustTime
            <span class="apidocSignatureSpan">(trueMs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.MinutePreciseClock.prototype.checkTimestamp">
            function <span class="apidocSignatureSpan">swarm.MinutePreciseClock.prototype.</span>checkTimestamp
            <span class="apidocSignatureSpan">(ts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.MinutePreciseClock.prototype.issueTimestamp">
            function <span class="apidocSignatureSpan">swarm.MinutePreciseClock.prototype.</span>issueTimestamp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.MinutePreciseClock.prototype.minutes">
            function <span class="apidocSignatureSpan">swarm.MinutePreciseClock.prototype.</span>minutes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.MinutePreciseClock.prototype.parseTimestamp">
            function <span class="apidocSignatureSpan">swarm.MinutePreciseClock.prototype.</span>parseTimestamp
            <span class="apidocSignatureSpan">(ts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.MinutePreciseClock.prototype.time2date">
            function <span class="apidocSignatureSpan">swarm.MinutePreciseClock.prototype.</span>time2date
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Model">module swarm.Model</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.Model">
            function <span class="apidocSignatureSpan">swarm.</span>Model
            <span class="apidocSignatureSpan">(idOrState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model._super">
            function <span class="apidocSignatureSpan">swarm.Model.</span>_super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.addReaction">
            function <span class="apidocSignatureSpan">swarm.Model.</span>addReaction
            <span class="apidocSignatureSpan">(methodOrField, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.extend">
            function <span class="apidocSignatureSpan">swarm.Model.</span>extend
            <span class="apidocSignatureSpan">(fn, own)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.removeReaction">
            function <span class="apidocSignatureSpan">swarm.Model.</span>removeReaction
            <span class="apidocSignatureSpan">(handle)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Model.</span>_pt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Model.</span>defaults</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Model.prototype">module swarm.Model.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype.callReactions">
            function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>callReactions
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype.constructor">
            function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>constructor
            <span class="apidocSignatureSpan">(idOrState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype.distillLog">
            function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>distillLog
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype.fill">
            function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>fill
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype.off">
            function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>off
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype.on">
            function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype.packState">
            function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>packState
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype.save">
            function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>save
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype.set">
            function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype.unpackState">
            function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>unpackState
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype.validate">
            function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>validate
            <span class="apidocSignatureSpan">(spec, val)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Model.prototype.</span>_neutrals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Model.prototype.</span>_ops</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Model.prototype.</span>_reactions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Model.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.Model.prototype.</span>_type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Model.prototype._neutrals">module swarm.Model.prototype._neutrals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype._neutrals.error">
            function <span class="apidocSignatureSpan">swarm.Model.prototype._neutrals.</span>error
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype._neutrals.off">
            function <span class="apidocSignatureSpan">swarm.Model.prototype._neutrals.</span>off
            <span class="apidocSignatureSpan">(spec, base, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype._neutrals.on">
            function <span class="apidocSignatureSpan">swarm.Model.prototype._neutrals.</span>on
            <span class="apidocSignatureSpan">(spec, base, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype._neutrals.reoff">
            function <span class="apidocSignatureSpan">swarm.Model.prototype._neutrals.</span>reoff
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype._neutrals.reon">
            function <span class="apidocSignatureSpan">swarm.Model.prototype._neutrals.</span>reon
            <span class="apidocSignatureSpan">(spec, filter, repl)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Model.prototype._ops">module swarm.Model.prototype._ops</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype._ops.init">
            function <span class="apidocSignatureSpan">swarm.Model.prototype._ops.</span>init
            <span class="apidocSignatureSpan">(spec, state, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Model.prototype._ops.set">
            function <span class="apidocSignatureSpan">swarm.Model.prototype._ops.</span>set
            <span class="apidocSignatureSpan">(spec, value, repl)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Pipe">module swarm.Pipe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Pipe.Pipe">
            function <span class="apidocSignatureSpan">swarm.</span>Pipe
            <span class="apidocSignatureSpan">(host, stream, opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">swarm.Pipe.</span>TIMEOUT</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Pipe.prototype">module swarm.Pipe.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Pipe.prototype.close">
            function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>close
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Pipe.prototype.connect">
            function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>connect
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Pipe.prototype.deliver">
            function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>deliver
            <span class="apidocSignatureSpan">(spec, val, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Pipe.prototype.keepAliveFn">
            function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>keepAliveFn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Pipe.prototype.parseBundle">
            function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>parseBundle
            <span class="apidocSignatureSpan">(bundle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Pipe.prototype.parseHandshake">
            function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>parseHandshake
            <span class="apidocSignatureSpan">(handshake)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Pipe.prototype.sendBundle">
            function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>sendBundle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Pipe.prototype.spec">
            function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>spec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Pipe.prototype.time">
            function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>time
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.ProxyListener">module swarm.ProxyListener</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.ProxyListener.ProxyListener">
            function <span class="apidocSignatureSpan">swarm.</span>ProxyListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.ProxyListener.prototype">module swarm.ProxyListener.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.ProxyListener.prototype.deliver">
            function <span class="apidocSignatureSpan">swarm.ProxyListener.prototype.</span>deliver
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.ProxyListener.prototype.off">
            function <span class="apidocSignatureSpan">swarm.ProxyListener.prototype.</span>off
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.ProxyListener.prototype.on">
            function <span class="apidocSignatureSpan">swarm.ProxyListener.prototype.</span>on
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.ReactMixin">module swarm.ReactMixin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.ReactMixin.componentWillMount">
            function <span class="apidocSignatureSpan">swarm.ReactMixin.</span>componentWillMount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.ReactMixin.componentWillUnmount">
            function <span class="apidocSignatureSpan">swarm.ReactMixin.</span>componentWillUnmount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.ReactMixin.deliver">
            function <span class="apidocSignatureSpan">swarm.ReactMixin.</span>deliver
            <span class="apidocSignatureSpan">(spec, val, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.ReactMixin.shouldComponentUpdate">
            function <span class="apidocSignatureSpan">swarm.ReactMixin.</span>shouldComponentUpdate
            <span class="apidocSignatureSpan">(nextProps, nextState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.SecondPreciseClock">module swarm.SecondPreciseClock</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SecondPreciseClock.SecondPreciseClock">
            function <span class="apidocSignatureSpan">swarm.</span>SecondPreciseClock
            <span class="apidocSignatureSpan">(processId, timeOffsetMs)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">swarm.SecondPreciseClock.</span>EPOCH</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.SecondPreciseClock.prototype">module swarm.SecondPreciseClock.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SecondPreciseClock.prototype.adjustTime">
            function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>adjustTime
            <span class="apidocSignatureSpan">(trueMs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SecondPreciseClock.prototype.checkTimestamp">
            function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>checkTimestamp
            <span class="apidocSignatureSpan">(ts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SecondPreciseClock.prototype.issueTimestamp">
            function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>issueTimestamp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SecondPreciseClock.prototype.ms">
            function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>ms
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SecondPreciseClock.prototype.parseTimestamp">
            function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>parseTimestamp
            <span class="apidocSignatureSpan">(ts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SecondPreciseClock.prototype.seconds">
            function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>seconds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SecondPreciseClock.prototype.timestamp2date">
            function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>timestamp2date
            <span class="apidocSignatureSpan">(ts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Set">module swarm.Set</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.Set">
            function <span class="apidocSignatureSpan">swarm.</span>Set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set._super">
            function <span class="apidocSignatureSpan">swarm.Set.</span>_super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.addReaction">
            function <span class="apidocSignatureSpan">swarm.Set.</span>addReaction
            <span class="apidocSignatureSpan">(op, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.extend">
            function <span class="apidocSignatureSpan">swarm.Set.</span>extend
            <span class="apidocSignatureSpan">(fn, own)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.removeReaction">
            function <span class="apidocSignatureSpan">swarm.Set.</span>removeReaction
            <span class="apidocSignatureSpan">(handle)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Set.</span>_pt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Set.</span>defaults</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Set.prototype">module swarm.Set.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.addObject">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>addObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.callReactions">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>callReactions
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.change">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>change
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.constructor">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.distillLog">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>distillLog
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.distillOp">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>distillOp
            <span class="apidocSignatureSpan">(spec, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.every">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>every
            <span class="apidocSignatureSpan">(cb, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.filter">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>filter
            <span class="apidocSignatureSpan">(cb, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.forEach">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>forEach
            <span class="apidocSignatureSpan">(cb, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.get">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>get
            <span class="apidocSignatureSpan">(key_spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.list">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>list
            <span class="apidocSignatureSpan">(order)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.map">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>map
            <span class="apidocSignatureSpan">(cb, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.offObjectEvent">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>offObjectEvent
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.onObjectEvent">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>onObjectEvent
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.onObjectStateReady">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>onObjectStateReady
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.pojo">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>pojo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.removeObject">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>removeObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype.validate">
            function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>validate
            <span class="apidocSignatureSpan">(spec, val, src)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Set.prototype.</span>_neutrals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Set.prototype.</span>_ops</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Set.prototype.</span>_reactions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Set.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.Set.prototype.</span>_type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Set.prototype._neutrals">module swarm.Set.prototype._neutrals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype._neutrals.error">
            function <span class="apidocSignatureSpan">swarm.Set.prototype._neutrals.</span>error
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype._neutrals.off">
            function <span class="apidocSignatureSpan">swarm.Set.prototype._neutrals.</span>off
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype._neutrals.on">
            function <span class="apidocSignatureSpan">swarm.Set.prototype._neutrals.</span>on
            <span class="apidocSignatureSpan">(spec, filter, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype._neutrals.reoff">
            function <span class="apidocSignatureSpan">swarm.Set.prototype._neutrals.</span>reoff
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype._neutrals.reon">
            function <span class="apidocSignatureSpan">swarm.Set.prototype._neutrals.</span>reon
            <span class="apidocSignatureSpan">(spec, filter, repl)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Set.prototype._ops">module swarm.Set.prototype._ops</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype._ops.change">
            function <span class="apidocSignatureSpan">swarm.Set.prototype._ops.</span>change
            <span class="apidocSignatureSpan">(spec, value, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Set.prototype._ops.init">
            function <span class="apidocSignatureSpan">swarm.Set.prototype._ops.</span>init
            <span class="apidocSignatureSpan">(spec, state, src)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.SharedWebStorage">module swarm.SharedWebStorage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SharedWebStorage.SharedWebStorage">
            function <span class="apidocSignatureSpan">swarm.</span>SharedWebStorage
            <span class="apidocSignatureSpan">(id, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.SharedWebStorage.prototype">module swarm.SharedWebStorage.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>async</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>isRoot</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SharedWebStorage.prototype.installListeners">
            function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>installListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SharedWebStorage.prototype.loadLog">
            function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>loadLog
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SharedWebStorage.prototype.onOp">
            function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>onOp
            <span class="apidocSignatureSpan">(spec, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SharedWebStorage.prototype.readOps">
            function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>readOps
            <span class="apidocSignatureSpan">(ti, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SharedWebStorage.prototype.readState">
            function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>readState
            <span class="apidocSignatureSpan">(spec, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SharedWebStorage.prototype.writeOp">
            function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>writeOp
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SharedWebStorage.prototype.writeState">
            function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>writeState
            <span class="apidocSignatureSpan">(spec, state, src)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>_host</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>counts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>lstn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>states</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>tails</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>_id</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.SockJSServerStream">module swarm.SockJSServerStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SockJSServerStream.SockJSServerStream">
            function <span class="apidocSignatureSpan">swarm.</span>SockJSServerStream
            <span class="apidocSignatureSpan">(ws)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.SockJSServerStream.prototype">module swarm.SockJSServerStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SockJSServerStream.prototype.on">
            function <span class="apidocSignatureSpan">swarm.SockJSServerStream.prototype.</span>on
            <span class="apidocSignatureSpan">(evname, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.SockJSServerStream.prototype.write">
            function <span class="apidocSignatureSpan">swarm.SockJSServerStream.prototype.</span>write
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Spec">module swarm.Spec</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.Spec">
            function <span class="apidocSignatureSpan">swarm.</span>Spec
            <span class="apidocSignatureSpan">(str, quant)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.Map">
            function <span class="apidocSignatureSpan">swarm.Spec.</span>Map
            <span class="apidocSignatureSpan">(vec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.as">
            function <span class="apidocSignatureSpan">swarm.Spec.</span>as
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.base2int">
            function <span class="apidocSignatureSpan">swarm.Spec.</span>base2int
            <span class="apidocSignatureSpan">(base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.int2base">
            function <span class="apidocSignatureSpan">swarm.Spec.</span>int2base
            <span class="apidocSignatureSpan">(i, padlen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.is">
            function <span class="apidocSignatureSpan">swarm.Spec.</span>is
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.parseToken">
            function <span class="apidocSignatureSpan">swarm.Spec.</span>parseToken
            <span class="apidocSignatureSpan">(token_body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.pattern">
            function <span class="apidocSignatureSpan">swarm.Spec.</span>pattern
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Spec.</span>quants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Spec.</span>re64l</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Spec.</span>reQTokExt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Spec.</span>reTok</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Spec.</span>reTokExt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.Spec.</span>base64</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.Spec.</span>rT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.Spec.</span>rsQTokExt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.Spec.</span>rsTokExt</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Spec.Map">module swarm.Spec.Map</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.Map.Map">
            function <span class="apidocSignatureSpan">swarm.Spec.</span>Map
            <span class="apidocSignatureSpan">(vec)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Spec.Map.prototype">module swarm.Spec.Map.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.Map.prototype.add">
            function <span class="apidocSignatureSpan">swarm.Spec.Map.prototype.</span>add
            <span class="apidocSignatureSpan">(versionVector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.Map.prototype.covers">
            function <span class="apidocSignatureSpan">swarm.Spec.Map.prototype.</span>covers
            <span class="apidocSignatureSpan">(version)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.Map.prototype.maxTs">
            function <span class="apidocSignatureSpan">swarm.Spec.Map.prototype.</span>maxTs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.Map.prototype.toString">
            function <span class="apidocSignatureSpan">swarm.Spec.Map.prototype.</span>toString
            <span class="apidocSignatureSpan">(trim)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Spec.prototype">module swarm.Spec.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.add">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>add
            <span class="apidocSignatureSpan">(spec, quant)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.filter">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>filter
            <span class="apidocSignatureSpan">(quants)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.fits">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>fits
            <span class="apidocSignatureSpan">(specFilter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.get">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>get
            <span class="apidocSignatureSpan">(quant)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.has">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>has
            <span class="apidocSignatureSpan">(quant)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.id">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>id
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.isEmpty">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.op">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>op
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.pattern">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>pattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.set">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>set
            <span class="apidocSignatureSpan">(spec, quant)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.sort">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>sort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.source">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>source
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.toString">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.tok">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>tok
            <span class="apidocSignatureSpan">(quant)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.token">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>token
            <span class="apidocSignatureSpan">(quant)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.type">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.typeid">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>typeid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Spec.prototype.version">
            function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>version
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Storage">module swarm.Storage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Storage.Storage">
            function <span class="apidocSignatureSpan">swarm.</span>Storage
            <span class="apidocSignatureSpan">(async)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Storage.prototype">module swarm.Storage.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>isRoot</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Storage.prototype.anyOp">
            function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>anyOp
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Storage.prototype.close">
            function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Storage.prototype.deliver">
            function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>deliver
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Storage.prototype.emit">
            function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>emit
            <span class="apidocSignatureSpan">(spec, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Storage.prototype.init">
            function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>init
            <span class="apidocSignatureSpan">(spec, state, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Storage.prototype.off">
            function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>off
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Storage.prototype.on">
            function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>on
            <span class="apidocSignatureSpan">(spec, base, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Storage.prototype.readOps">
            function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>readOps
            <span class="apidocSignatureSpan">(ti, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Storage.prototype.readState">
            function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>readState
            <span class="apidocSignatureSpan">(ti, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Storage.prototype.writeOp">
            function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>writeOp
            <span class="apidocSignatureSpan">(spec, value, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Storage.prototype.writeState">
            function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>writeState
            <span class="apidocSignatureSpan">(spec, state, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>MAX_LOG_SIZE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Syncable">module swarm.Syncable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.Syncable">
            function <span class="apidocSignatureSpan">swarm.</span>Syncable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable._super">
            function <span class="apidocSignatureSpan">swarm.Syncable.</span>_super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.addReaction">
            function <span class="apidocSignatureSpan">swarm.Syncable.</span>addReaction
            <span class="apidocSignatureSpan">(op, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.extend">
            function <span class="apidocSignatureSpan">swarm.Syncable.</span>extend
            <span class="apidocSignatureSpan">(fn, own)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.isOpSink">
            function <span class="apidocSignatureSpan">swarm.Syncable.</span>isOpSink
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.listenerEquals">
            function <span class="apidocSignatureSpan">swarm.Syncable.</span>listenerEquals
            <span class="apidocSignatureSpan">(ln, other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.removeReaction">
            function <span class="apidocSignatureSpan">swarm.Syncable.</span>removeReaction
            <span class="apidocSignatureSpan">(handle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.stateVersionVector">
            function <span class="apidocSignatureSpan">swarm.Syncable.</span>stateVersionVector
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.</span>_default</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.</span>_pt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.</span>memberClasses</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.</span>reFieldName</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.</span>reMethodName</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Syncable.prototype">module swarm.Syncable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.acl">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>acl
            <span class="apidocSignatureSpan">(spec, val, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.apply">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>apply
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.callReactions">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>callReactions
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.checkUplink">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>checkUplink
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.close">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.constructor">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.deliver">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>deliver
            <span class="apidocSignatureSpan">(spec, value, lstn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.diff">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>diff
            <span class="apidocSignatureSpan">(base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.distillLog">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>distillLog
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.emit">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>emit
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.error">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.gc">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>gc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.getListenerIndex">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>getListenerIndex
            <span class="apidocSignatureSpan">(search_for, uplinks_only)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.hasState">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>hasState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.init">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.isReplay">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>isReplay
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.newEventSpec">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>newEventSpec
            <span class="apidocSignatureSpan">(op)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.off">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>off
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.on">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.once">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>once
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.pojo">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>pojo
            <span class="apidocSignatureSpan">(addVersionInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.reoff">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>reoff
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.reon">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>reon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.reset">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.spec">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>spec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.stateSpec">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>stateSpec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.trigger">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>trigger
            <span class="apidocSignatureSpan">(event, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.unimplemented">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>unimplemented
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.validate">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>validate
            <span class="apidocSignatureSpan">(spec, val, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype.version">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>version
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>_neutrals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>_ops</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>_reactions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>_type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Syncable.prototype._neutrals">module swarm.Syncable.prototype._neutrals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype._neutrals.error">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype._neutrals.</span>error
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype._neutrals.off">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype._neutrals.</span>off
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype._neutrals.on">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype._neutrals.</span>on
            <span class="apidocSignatureSpan">(spec, filter, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype._neutrals.reoff">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype._neutrals.</span>reoff
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype._neutrals.reon">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype._neutrals.</span>reon
            <span class="apidocSignatureSpan">(spec, filter, repl)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Syncable.prototype._ops">module swarm.Syncable.prototype._ops</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.prototype._ops.init">
            function <span class="apidocSignatureSpan">swarm.Syncable.prototype._ops.</span>init
            <span class="apidocSignatureSpan">(spec, state, src)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Syncable.types">module swarm.Syncable.types</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.types.Host">
            function <span class="apidocSignatureSpan">swarm.Syncable.types.</span>Host
            <span class="apidocSignatureSpan">(id, ms, storage)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.types.Model">
            function <span class="apidocSignatureSpan">swarm.Syncable.types.</span>Model
            <span class="apidocSignatureSpan">(idOrState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.types.Set">
            function <span class="apidocSignatureSpan">swarm.Syncable.types.</span>Set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.types.Syncable">
            function <span class="apidocSignatureSpan">swarm.Syncable.types.</span>Syncable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.types.Text">
            function <span class="apidocSignatureSpan">swarm.Syncable.types.</span>Text
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.types.Vector">
            function <span class="apidocSignatureSpan">swarm.Syncable.types.</span>Vector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Syncable.types.Text.prototype">module swarm.Syncable.types.Text.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.types.Text.prototype.callReactions">
            function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>callReactions
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.types.Text.prototype.constructor">
            function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.types.Text.prototype.insert">
            function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>insert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.types.Text.prototype.rebuild">
            function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>rebuild
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.types.Text.prototype.remove">
            function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>remove
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.types.Text.prototype.set">
            function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>set
            <span class="apidocSignatureSpan">(newText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Syncable.types.Text.prototype.state">
            function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>state
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>_neutrals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>_ops</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>_reactions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>_type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Text">module swarm.Text</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Text.Text">
            function <span class="apidocSignatureSpan">swarm.</span>Text
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Text._super">
            function <span class="apidocSignatureSpan">swarm.Text.</span>_super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Text.addReaction">
            function <span class="apidocSignatureSpan">swarm.Text.</span>addReaction
            <span class="apidocSignatureSpan">(op, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Text.diff">
            function <span class="apidocSignatureSpan">swarm.Text.</span>diff
            <span class="apidocSignatureSpan">(was, is)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Text.extend">
            function <span class="apidocSignatureSpan">swarm.Text.</span>extend
            <span class="apidocSignatureSpan">(fn, own)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Text.removeReaction">
            function <span class="apidocSignatureSpan">swarm.Text.</span>removeReaction
            <span class="apidocSignatureSpan">(handle)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Text.</span>_pt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Text.</span>defaults</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Vector">module swarm.Vector</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.Vector">
            function <span class="apidocSignatureSpan">swarm.</span>Vector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector._super">
            function <span class="apidocSignatureSpan">swarm.Vector.</span>_super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.addReaction">
            function <span class="apidocSignatureSpan">swarm.Vector.</span>addReaction
            <span class="apidocSignatureSpan">(op, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.extend">
            function <span class="apidocSignatureSpan">swarm.Vector.</span>extend
            <span class="apidocSignatureSpan">(fn, own)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.removeReaction">
            function <span class="apidocSignatureSpan">swarm.Vector.</span>removeReaction
            <span class="apidocSignatureSpan">(handle)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Vector.</span>_pt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Vector.</span>defaults</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Vector.prototype">module swarm.Vector.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.addObject">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>addObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.append">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>append
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.callReactions">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>callReactions
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.constructor">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.distillLog">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>distillLog
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.every">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>every
            <span class="apidocSignatureSpan">(cb, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.filter">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>filter
            <span class="apidocSignatureSpan">(cb, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.findPositionFor">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>findPositionFor
            <span class="apidocSignatureSpan">(id, parentId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.forEach">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>forEach
            <span class="apidocSignatureSpan">(cb, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.getObject">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>getObject
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.getParentOf">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>getParentOf
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.in">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>in
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.inSubtreeOf">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>inSubtreeOf
            <span class="apidocSignatureSpan">(nodeId, rootId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.indexOf">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(obj, startAt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.insert">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>insert
            <span class="apidocSignatureSpan">(spec, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.insertAfter">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>insertAfter
            <span class="apidocSignatureSpan">(obj, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.insertBefore">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>insertBefore
            <span class="apidocSignatureSpan">(spec, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.insertSorted">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>insertSorted
            <span class="apidocSignatureSpan">(obj, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.isDescendantOf">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>isDescendantOf
            <span class="apidocSignatureSpan">(nodeId, rootId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.length">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.map">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>map
            <span class="apidocSignatureSpan">(cb, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.normalizePos">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>normalizePos
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.objectAt">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>objectAt
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.offObjectEvent">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>offObjectEvent
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.onObjectEvent">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>onObjectEvent
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.onObjectStateReady">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>onObjectStateReady
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.pojo">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>pojo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.remove">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>remove
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.removeObject">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>removeObject
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.rm">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>rm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.setOrder">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>setOrder
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.skipSubtree">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>skipSubtree
            <span class="apidocSignatureSpan">(iter, root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype.validate">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>validate
            <span class="apidocSignatureSpan">(spec, val, source)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>_neutrals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>_ops</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>_reactions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>_super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>_type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Vector.prototype._neutrals">module swarm.Vector.prototype._neutrals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype._neutrals.error">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype._neutrals.</span>error
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype._neutrals.off">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype._neutrals.</span>off
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype._neutrals.on">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype._neutrals.</span>on
            <span class="apidocSignatureSpan">(spec, filter, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype._neutrals.reoff">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype._neutrals.</span>reoff
            <span class="apidocSignatureSpan">(spec, val, repl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype._neutrals.reon">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype._neutrals.</span>reon
            <span class="apidocSignatureSpan">(spec, filter, repl)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.Vector.prototype._ops">module swarm.Vector.prototype._ops</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype._ops.in">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype._ops.</span>in
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype._ops.init">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype._ops.</span>init
            <span class="apidocSignatureSpan">(spec, state, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.Vector.prototype._ops.rm">
            function <span class="apidocSignatureSpan">swarm.Vector.prototype._ops.</span>rm
            <span class="apidocSignatureSpan">(spec, value, src)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.WebSocketStream">module swarm.WebSocketStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.WebSocketStream.WebSocketStream">
            function <span class="apidocSignatureSpan">swarm.</span>WebSocketStream
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.env">module swarm.env</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.env.</span>debug</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.env.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.env.</span>isGecko</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.env.</span>isIE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.env.</span>isServer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.env.</span>isWebKit</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.env.</span>multihost</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">swarm.env.</span>trace</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.env.hashfn">
            function <span class="apidocSignatureSpan">swarm.env.</span>hashfn
            <span class="apidocSignatureSpan">(key, seed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.env.log">
            function <span class="apidocSignatureSpan">swarm.env.</span>log
            <span class="apidocSignatureSpan">(spec, val, object)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">swarm.env.</span>streams</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.env.streams">module swarm.env.streams</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.env.streams.loopback">
            function <span class="apidocSignatureSpan">swarm.env.streams.</span>loopback
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.env.streams.ws">
            function <span class="apidocSignatureSpan">swarm.env.streams.</span>ws
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.env.streams.wss">
            function <span class="apidocSignatureSpan">swarm.env.streams.</span>wss
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.env.streams.loopback.prototype">module swarm.env.streams.loopback.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.env.streams.loopback.prototype.close">
            function <span class="apidocSignatureSpan">swarm.env.streams.loopback.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.env.streams.loopback.prototype.on">
            function <span class="apidocSignatureSpan">swarm.env.streams.loopback.prototype.</span>on
            <span class="apidocSignatureSpan">(evname, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.env.streams.loopback.prototype.pair">
            function <span class="apidocSignatureSpan">swarm.env.streams.loopback.prototype.</span>pair
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.env.streams.loopback.prototype.receive">
            function <span class="apidocSignatureSpan">swarm.env.streams.loopback.prototype.</span>receive
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.env.streams.loopback.prototype.write">
            function <span class="apidocSignatureSpan">swarm.env.streams.loopback.prototype.</span>write
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.swarm.env.streams.wss.prototype">module swarm.env.streams.wss.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.env.streams.wss.prototype.on">
            function <span class="apidocSignatureSpan">swarm.env.streams.wss.prototype.</span>on
            <span class="apidocSignatureSpan">(evname, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.swarm.env.streams.wss.prototype.write">
            function <span class="apidocSignatureSpan">swarm.env.streams.wss.prototype.</span>write
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm" id="apidoc.module.swarm">module swarm</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.EinarosWSStream" id="apidoc.element.swarm.EinarosWSStream">
        function <span class="apidocSignatureSpan">swarm.</span>EinarosWSStream
        <span class="apidocSignatureSpan">(ws)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EinarosWSStream(ws) {
    var self = this,
        ln = this.lstn = {},
        buf = [];

    if (typeof ws === &#x27;string&#x27;) { // url passed
        ws = new ws_lib(ws);
    }
    this.ws = ws;
    if (ws.readyState !== 1/*WebSocket.OPEN*/) {
        this.buf = buf; //will wait for &#x22;open&#x22;
    }
    ws.on(&#x27;open&#x27;, function () {
        buf.reverse();
        self.buf = null;
        while (buf.length) {
            self.write(buf.pop());
        }
    });
    ws.on(&#x27;close&#x27;, function () { ln.close &#x26;&#x26; ln.close(); });
    ws.on(&#x27;message&#x27;, function (msg) {
        try {
            ln.data &#x26;&#x26; ln.data(msg);
        } catch (ex) {
            console.error(&#x27;message processing fails&#x27;, ex);
            ln.error &#x26;&#x26; ln.error(ex.message);
        }
    });
    ws.on(&#x27;error&#x27;, function (msg) { ln.error &#x26;&#x26; ln.error(msg); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// start WebSocket server
var wsServer = new ws_lib.Server({ server: httpServer });

// accept incoming WebSockets connections
wsServer.on(&#x27;connection&#x27;, function (ws) {
    console.log(&#x27;new incoming WebSocket connection&#x27;);
    swarmHost.accept(new Swarm.<span class="apidocCodeKeywordSpan">EinarosWSStream</span>(ws), { delay: 50 });
});
```

see [swarm-example](https://github.com/swarmjs/swarm-example/blob/master/server.js) for a nice example of a generic model sync server


## Swarm API Quickstart
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.FileStorage" id="apidoc.element.swarm.FileStorage">
        function <span class="apidocSignatureSpan">swarm.</span>FileStorage
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FileStorage(dir) {
    Storage.call(this);
    this._host = null; //will be set during Host creation
    this.dir = path.resolve(dir);
    if (!fs.existsSync(this.dir)) {
        fs.mkdirSync(this.dir);
    }
    this._id = &#x27;file&#x27;;
    this.tail = {};

    this.loadLog();
    this.rotateLog();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// npm install swarm
var Swarm = require(&#x27;swarm&#x27;);

var Mouse = require(&#x27;./Mouse.js&#x27;); // see the model definition above

// use file storage
var fileStorage = new Swarm.<span class="apidocCodeKeywordSpan">FileStorage</span>(&#x27;storage&#x27;);

// create the server-side Swarm Host
var swarmHost = new Swarm.Host(&#x27;swarm~nodejs&#x27;, 0, fileStorage);

// create and start the HTTP server
var httpServer = http.createServer();
httpServer.listen(8000, function (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host" id="apidoc.element.swarm.Host">
        function <span class="apidocSignatureSpan">swarm.</span>Host
        <span class="apidocSignatureSpan">(id, ms, storage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Host(id, ms, storage) {
    this.objects = {};
    this.sources = {};
    this.storage = storage;
    this._host = this; // :)
    this._lstn = [&#x27;,&#x27;];
    this._id = id;
    this._server = /^swarm~.*/.test(id);
    var clock_fn = env.clockType || SecondPreciseClock;
    this.clock = new clock_fn(this._id, ms||0);

    if (this.storage) {
        this.sources[this._id] = this.storage;
        this.storage._host = this;
    }
    delete this.objects[this.spec()];

    if (!env.multihost) {
        if (env.localhost) {
            throw new Error(&#x27;use multihost mode&#x27;);
        }
        env.localhost = this;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
module.exports = Mouse; // CommonJS
```

### Using the model on the client (app.js)

```js
// 1. create local Host
var swarmHost = new Swarm.<span class="apidocCodeKeywordSpan">Host</span>(&#x27;unique_client_id&#x27;);

// 2. connect to your server
swarmHost.connect(&#x27;ws://localhost:8000/&#x27;);

// 3.a. create an object
var someMouse = new Mouse();
// OR swarmHost.get(&#x27;/Mouse&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LamportClock" id="apidoc.element.swarm.LamportClock">
        function <span class="apidocSignatureSpan">swarm.</span>LamportClock
        <span class="apidocSignatureSpan">(processId, initTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LamportClock = function (processId, initTime) {
    if (!Spec.reTok.test(processId)) {
        throw new Error(&#x27;invalid process id: &#x27;+processId);
    }
    this.id = processId;
    // sometimes we assume our local clock has some offset
    this.seq = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LevelStorage" id="apidoc.element.swarm.LevelStorage">
        function <span class="apidocSignatureSpan">swarm.</span>LevelStorage
        <span class="apidocSignatureSpan">(id, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LevelStorage(id, options, callback) {
    Storage.call(this);
    this.options = options;
    this._host = null; // will be set by the Host
    this.db = options.db;
    this._id = id;
    this.filename = null;
    if (this.db.constructor===Function) {
        this.db = this.db(options.path||id);
    }
    this.logtails = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec" id="apidoc.element.swarm.LongSpec">
        function <span class="apidocSignatureSpan">swarm.</span>LongSpec
        <span class="apidocSignatureSpan">(spec, codeBook)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LongSpec = function (spec, codeBook) {
    var cb = this.codeBook = codeBook || {en:{},de:{}};
    if (!cb.en) { cb.en = {}; }
    if (!cb.de) { // revert en to make de
        cb.de = {};
        for(var tok in cb.en) {
            cb.de[cb.en[tok]] = tok;
        }
    }
    if (!cb.lastCodes) {
        cb.lastCodes = {&#x27;/&#x27;:0x30,&#x27;#&#x27;:0x30,&#x27;!&#x27;:0x30,&#x27;.&#x27;:0x30,&#x27;+&#x27;:0x30};
    }
    // For a larger document, a single LongSpec may be some megabytes long.
    // As we don&#x27;t want to rewrite those megabytes on every keypress, we
    // divide data into chunks.
    this.chunks = [];
    this.chunkLengths = [];
    if (spec) {
        this.append(spec);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator" id="apidoc.element.swarm.LongSpec.Iterator">
        function <span class="apidocSignatureSpan">swarm.</span>LongSpec.Iterator
        <span class="apidocSignatureSpan">(owner, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Iterator(owner, index) {
    this.owner = owner;         // our LongSpec
<span class="apidocCodeCommentSpan">    /*this.chunk = 0;             // the chunk we are in
    this.index = -1;            // token index (position &#x22;before the 1st token&#x22;)
    this.chunkIndex = -1;       // token index within the chunk
    this.prevFull = undefined;  // previous full (non-collapsed) token
    //  seqStart IS the previous match or prev match is trivial
    this.prevCollapsed = 0;
    this.match = null;
    //this.next();*/
</span>    this.skip2chunk(0);
    if (index) {
        if (index.constructor===LongSpec.Iterator) {
            index = index.index;
        }
        this.skip(index);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.MinutePreciseClock" id="apidoc.element.swarm.MinutePreciseClock">
        function <span class="apidocSignatureSpan">swarm.</span>MinutePreciseClock
        <span class="apidocSignatureSpan">(processId, timeOffsetMs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MinutePreciseClock = function (processId, timeOffsetMs) {
    if (!Spec.reTok.test(processId)) {
        throw new Error(&#x27;invalid process id: &#x27;+processId);
    }
    this.id = processId;
    // sometimes we assume our local clock has some offset
    this.clockOffsetMs = 0;
    this.lastIssuedTimestamp = &#x27;&#x27;;
    // although we try hard to use wall clock time, we must
    // obey Lamport logical clock rules, in particular our
    // timestamps must be greater than any other timestamps
    // previously seen
    this.lastTimeSeen = 0;
    this.lastSeqSeen = 0;
    if (timeOffsetMs) {
        this.clockOffsetMs = timeOffsetMs;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model" id="apidoc.element.swarm.Model">
        function <span class="apidocSignatureSpan">swarm.</span>Model
        <span class="apidocSignatureSpan">(idOrState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Model(idOrState) {
    var ret = Model._super.apply(this, arguments);
    /// TODO: combine with state push, make clean
    if (ret === this &#x26;&#x26; idOrState &#x26;&#x26; idOrState.constructor !== String &#x26;&#x26; !Spec.is(idOrState)) {
        this.deliver(this.spec().add(this._id, &#x27;!&#x27;).add(&#x27;.set&#x27;), idOrState);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Pipe" id="apidoc.element.swarm.Pipe">
        function <span class="apidocSignatureSpan">swarm.</span>Pipe
        <span class="apidocSignatureSpan">(host, stream, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pipe(host, stream, opts) {
    var self = this;
    self.opts = opts || {};
    if (!stream || !host) {
        throw new Error(&#x27;new Pipe(host,stream[,opts])&#x27;);
    }
    self._id = null;
    self.host = host;
    // uplink/downlink state flag;
    //  true: this side initiated handshake &#x3e;.on &#x3c;.reon
    //  false: this side received handshake &#x3c;.on &#x3e;.reon
    //  undefined: nothing sent/received OR had a .reoff
    this.isOnSent = undefined;
    this.reconnectDelay = self.opts.reconnectDelay || 1000;
    self.serializer = self.opts.serializer || JSON;
    self.katimer = null;
    self.send_timer = null;
    self.lastSendTS = self.lastRecvTS = self.time();
    self.bundle = {};
    // don&#x27;t send immediately, delay to bundle more messages
    self.delay = self.opts.delay || -1;
    //self.reconnectDelay = self.opts.reconnectDelay || 1000;
    if (typeof(stream.write) !== &#x27;function&#x27;) { // TODO nicer
        var url = stream.toString();
        var m = url.match(/(\w+):.*/);
        if (!m) {
            throw new Error(&#x27;invalid url &#x27; + url);
        }
        var proto = m[1].toLowerCase();
        var fn = env.streams[proto];
        if (!fn) {
            throw new Error(&#x27;protocol not supported: &#x27; + proto);
        }
        self.url = url;
        stream = new fn(url);
    }
    self.connect(stream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.ProxyListener" id="apidoc.element.swarm.ProxyListener">
        function <span class="apidocSignatureSpan">swarm.</span>ProxyListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyListener() {
    this.callbacks = null;
    this.owner = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SecondPreciseClock" id="apidoc.element.swarm.SecondPreciseClock">
        function <span class="apidocSignatureSpan">swarm.</span>SecondPreciseClock
        <span class="apidocSignatureSpan">(processId, timeOffsetMs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SecondPreciseClock = function (processId, timeOffsetMs) {
    if (!Spec.reTok.test(processId)) {
        throw new Error(&#x27;invalid process id: &#x27;+processId);
    }
    this.id = processId;
    // sometimes we assume our local clock has some offset
    this.clockOffsetMs = 0;
    this.lastTimestamp = &#x27;&#x27;;
    // although we try hard to use wall clock time, we must
    // obey Lamport logical clock rules, in particular our
    // timestamps must be greater than any other timestamps
    // previously seen
    this.lastTimeSeen = 0;
    this.lastSeqSeen = 0;
    if (timeOffsetMs) {
        this.clockOffsetMs = timeOffsetMs;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set" id="apidoc.element.swarm.Set">
        function <span class="apidocSignatureSpan">swarm.</span>Set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SomeSyncable() {
    return parent.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SharedWebStorage" id="apidoc.element.swarm.SharedWebStorage">
        function <span class="apidocSignatureSpan">swarm.</span>SharedWebStorage
        <span class="apidocSignatureSpan">(id, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SharedWebStorage(id, options) {
    this.options = options || {};
    this.lstn = {};
    this._id = id;
    this.tails = {};
    this.store = this.options.persistent ?
        window.localStorage : window.sessionStorage;

    this.loadLog();
    this.installListeners();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SockJSServerStream" id="apidoc.element.swarm.SockJSServerStream">
        function <span class="apidocSignatureSpan">swarm.</span>SockJSServerStream
        <span class="apidocSignatureSpan">(ws)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SockJSStream(ws) {
    var ln = this.lstn = {},
        buf = [];

    if (typeof ws === &#x27;string&#x27;) { // url passed
        throw new Error(&#x27;client-side connections not supported yet&#x27;);
    }
    this.ws = ws;
    if (ws.readyState !== 1/*WebSocket.OPEN*/) {
        this.buf = buf; //will wait for &#x22;open&#x22;
    }
    ws.on(&#x27;close&#x27;, function () { ln.close &#x26;&#x26; ln.close(); });
    ws.on(&#x27;data&#x27;, function (msg) {
        try {
            ln.data &#x26;&#x26; ln.data(msg);
        } catch (ex) {
            console.error(&#x27;message processing fails&#x27;, ex);
            ln.error &#x26;&#x26; ln.error(ex.message);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec" id="apidoc.element.swarm.Spec">
        function <span class="apidocSignatureSpan">swarm.</span>Spec
        <span class="apidocSignatureSpan">(str, quant)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Spec(str, quant) {
    if (str &#x26;&#x26; str.constructor === Spec) {
        str = str.value;
    } else { // later we assume value has valid format
        str = (str || &#x27;&#x27;).toString();
        if (quant &#x26;&#x26; str.charAt(0) &#x3e;= &#x27;0&#x27;) {
            str = quant + str;
        }
        if (str.replace(Spec.reQTokExt, &#x27;&#x27;)) {
            throw new Error(&#x27;malformed specifier: &#x27; + str);
        }
    }
    this.value = str;
    this.index = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.Map" id="apidoc.element.swarm.Spec.Map">
        function <span class="apidocSignatureSpan">swarm.</span>Spec.Map
        <span class="apidocSignatureSpan">(vec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VersionVectorAsAMap(vec) {
    this.map = {};
    if (vec) {
        this.add(vec);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Storage" id="apidoc.element.swarm.Storage">
        function <span class="apidocSignatureSpan">swarm.</span>Storage
        <span class="apidocSignatureSpan">(async)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Storage(async) {
    this.async = !!async || false;
    this.states = {};
    this.tails = {};
    this.counts = {};
    this._host = null;
    // many implementations do not push changes
    // so there are no listeners
    this.lstn = null;
    this._id = &#x27;some_storage&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable" id="apidoc.element.swarm.Syncable">
        function <span class="apidocSignatureSpan">swarm.</span>Syncable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Syncable() {
    // listeners represented as objects that have deliver() method
    this._lstn = [&#x27;,&#x27;]; // we unshift() uplink listeners and push() downlinks
    // ...so _lstn is like [server1, server2, storage, &#x27;,&#x27;, view, listener]
    // The most correct way to specify a version is the version vector,
    // but that one may consume more space than the data itself in some cases.
    // Hence, _version is not a fully specified version vector (see version()
    // instead). _version is essentially is the greatest operation timestamp
    // (Lamport-like, i.e. &#x22;time+source&#x22;), sometimes amended with additional
    // timestamps. Its main features:
    // (1) changes once the object&#x27;s state changes
    // (2) does it monotonically (in the alphanum order sense)
    this._version = &#x27;&#x27;;
    // make sense of arguments
    var args = Array.prototype.slice.call(arguments);
    this._host = (args.length &#x26;&#x26; args[args.length - 1]._type === &#x27;Host&#x27;) ?
            args.pop() : env.localhost;
    if (Spec.is(args[0])) {
        this._id = new Spec(args.shift()).id() || this._host.time();
    } else if (typeof(args[0]) === &#x27;string&#x27;) {
        this._id = args.shift(); // TODO format
    } else {
        this._id = this._host.time();
        this._version = &#x27;!0&#x27;; // may apply state in the constructor, see Model
    }
    //var state = args.length ? args.pop() : (fresh?{}:undefined);
    // register with the host
    var doubl = this._host.register(this);
    if (doubl !== this) { return doubl; }
    // locally created objects get state immediately
    // (while external-id objects need to query uplinks)
<span class="apidocCodeCommentSpan">    /*if (fresh &#x26;&#x26; state) {
     state._version = &#x27;!&#x27;+this._id;
     var pspec = this.spec().add(state._version).add(&#x27;.init&#x27;);
     this.deliver(pspec,state,this._host);
     }*/
</span>    this.reset();
    // find uplinks, subscribe
    this.checkUplink();
    // TODO inplement state push
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Text" id="apidoc.element.swarm.Text">
        function <span class="apidocSignatureSpan">swarm.</span>Text
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SomeSyncable() {
    return parent.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector" id="apidoc.element.swarm.Vector">
        function <span class="apidocSignatureSpan">swarm.</span>Vector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SomeSyncable() {
    return parent.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.WebSocketStream" id="apidoc.element.swarm.WebSocketStream">
        function <span class="apidocSignatureSpan">swarm.</span>WebSocketStream
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketStream(url) {
    var self = this;
    var ln = this.lstn = {};
    this.url = url;
    var ws = this.ws = new WebSocket(url);
    var buf = this.buf = [];
    ws.onopen = function () {
        buf.reverse();
        self.buf = null;
        while (buf.length) {
            self.write(buf.pop());
        }

    };
    ws.onclose = function () { ln.close &#x26;&#x26; ln.close(); };
    ws.onmessage = function (msg) {
        ln.data &#x26;&#x26; ln.data(msg.data);
    };
    ws.onerror = function (err) { ln.error &#x26;&#x26; ln.error(err); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.CollectionMethodsMixin" id="apidoc.module.swarm.CollectionMethodsMixin">module swarm.CollectionMethodsMixin</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.CollectionMethodsMixin.offObjectEvent" id="apidoc.element.swarm.CollectionMethodsMixin.offObjectEvent">
        function <span class="apidocSignatureSpan">swarm.CollectionMethodsMixin.</span>offObjectEvent
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">offObjectEvent = function (callback) {
    this._proxy.off(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.CollectionMethodsMixin.onObjectEvent" id="apidoc.element.swarm.CollectionMethodsMixin.onObjectEvent">
        function <span class="apidocSignatureSpan">swarm.CollectionMethodsMixin.</span>onObjectEvent
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onObjectEvent = function (callback) {
    this._proxy.owner = this;
    this._proxy.on(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.CollectionMethodsMixin.onObjectStateReady" id="apidoc.element.swarm.CollectionMethodsMixin.onObjectStateReady">
        function <span class="apidocSignatureSpan">swarm.CollectionMethodsMixin.</span>onObjectStateReady
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onObjectStateReady = function (callback) { // TODO timeout ?
    var self = this;
    function checker() {
        var notInitedYet = self.filter(function (entry) {
            return !entry._version;
        });
        if (!notInitedYet.length) {
            // all entries are inited
            callback();
        } else {
            // wait for some entry not ready yet
            var randomIdx = (Math.random() * (notInitedYet.length - 1)) | 0;
            notInitedYet[randomIdx].once(&#x27;init&#x27;, checker);
        }
    }
    if (this._version) {
        checker();
    } else {
        this.once(&#x27;init&#x27;, checker);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.EinarosWSStream" id="apidoc.module.swarm.EinarosWSStream">module swarm.EinarosWSStream</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.EinarosWSStream.EinarosWSStream" id="apidoc.element.swarm.EinarosWSStream.EinarosWSStream">
        function <span class="apidocSignatureSpan">swarm.</span>EinarosWSStream
        <span class="apidocSignatureSpan">(ws)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EinarosWSStream(ws) {
    var self = this,
        ln = this.lstn = {},
        buf = [];

    if (typeof ws === &#x27;string&#x27;) { // url passed
        ws = new ws_lib(ws);
    }
    this.ws = ws;
    if (ws.readyState !== 1/*WebSocket.OPEN*/) {
        this.buf = buf; //will wait for &#x22;open&#x22;
    }
    ws.on(&#x27;open&#x27;, function () {
        buf.reverse();
        self.buf = null;
        while (buf.length) {
            self.write(buf.pop());
        }
    });
    ws.on(&#x27;close&#x27;, function () { ln.close &#x26;&#x26; ln.close(); });
    ws.on(&#x27;message&#x27;, function (msg) {
        try {
            ln.data &#x26;&#x26; ln.data(msg);
        } catch (ex) {
            console.error(&#x27;message processing fails&#x27;, ex);
            ln.error &#x26;&#x26; ln.error(ex.message);
        }
    });
    ws.on(&#x27;error&#x27;, function (msg) { ln.error &#x26;&#x26; ln.error(msg); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// start WebSocket server
var wsServer = new ws_lib.Server({ server: httpServer });

// accept incoming WebSockets connections
wsServer.on(&#x27;connection&#x27;, function (ws) {
    console.log(&#x27;new incoming WebSocket connection&#x27;);
    swarmHost.accept(new Swarm.<span class="apidocCodeKeywordSpan">EinarosWSStream</span>(ws), { delay: 50 });
});
```

see [swarm-example](https://github.com/swarmjs/swarm-example/blob/master/server.js) for a nice example of a generic model sync server


## Swarm API Quickstart
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.EinarosWSStream.prototype" id="apidoc.module.swarm.EinarosWSStream.prototype">module swarm.EinarosWSStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.EinarosWSStream.prototype.on" id="apidoc.element.swarm.EinarosWSStream.prototype.on">
        function <span class="apidocSignatureSpan">swarm.EinarosWSStream.prototype.</span>on
        <span class="apidocSignatureSpan">(evname, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (evname, fn) {
    if (evname in this.lstn) {
        throw new Error(&#x27;not supported&#x27;);
    }
    this.lstn[evname] = fn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.EinarosWSStream.prototype.write" id="apidoc.element.swarm.EinarosWSStream.prototype.write">
        function <span class="apidocSignatureSpan">swarm.EinarosWSStream.prototype.</span>write
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data) {
    if (this.buf) {
        this.buf.push(data.toString());
    } else {
        this.ws.send(data.toString());
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.queue = [];
    if (this.id in AsyncLoopbackConnection.pipes) {
        throw new Error(&#x27;duplicate&#x27;);
    }
    AsyncLoopbackConnection.pipes[this.id] = this;
    var pair = this.pair();
    if (pair &#x26;&#x26; pair.queue.length) {
        pair.<span class="apidocCodeKeywordSpan">write</span>();
    }
}
AsyncLoopbackConnection.pipes = {};

env.streams.loopback = AsyncLoopbackConnection;

AsyncLoopbackConnection.prototype.pair = function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.FileStorage" id="apidoc.module.swarm.FileStorage">module swarm.FileStorage</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.FileStorage.FileStorage" id="apidoc.element.swarm.FileStorage.FileStorage">
        function <span class="apidocSignatureSpan">swarm.</span>FileStorage
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FileStorage(dir) {
    Storage.call(this);
    this._host = null; //will be set during Host creation
    this.dir = path.resolve(dir);
    if (!fs.existsSync(this.dir)) {
        fs.mkdirSync(this.dir);
    }
    this._id = &#x27;file&#x27;;
    this.tail = {};

    this.loadLog();
    this.rotateLog();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// npm install swarm
var Swarm = require(&#x27;swarm&#x27;);

var Mouse = require(&#x27;./Mouse.js&#x27;); // see the model definition above

// use file storage
var fileStorage = new Swarm.<span class="apidocCodeKeywordSpan">FileStorage</span>(&#x27;storage&#x27;);

// create the server-side Swarm Host
var swarmHost = new Swarm.Host(&#x27;swarm~nodejs&#x27;, 0, fileStorage);

// create and start the HTTP server
var httpServer = http.createServer();
httpServer.listen(8000, function (err) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.FileStorage.prototype" id="apidoc.module.swarm.FileStorage.prototype">module swarm.FileStorage.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.swarm.FileStorage.prototype.close" id="apidoc.element.swarm.FileStorage.prototype.close">
        function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>close
        <span class="apidocSignatureSpan">(callback, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback, error) {
    if (error) {
        console.log(&#x22;fatal IO error&#x22;, error);
    }
    if (this.logFile) {
        this.rotateLog(true, callback);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }, 1);
};

AsyncLoopbackConnection.prototype.close = function () {
    delete AsyncLoopbackConnection.pipes[this.id];
    var pair = this.pair();
    pair &#x26;&#x26; pair.<span class="apidocCodeKeywordSpan">close</span>();
    this.lstn.close &#x26;&#x26; this.lstn.close();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.FileStorage.prototype.loadLog" id="apidoc.element.swarm.FileStorage.prototype.loadLog">
        function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>loadLog
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadLog = function () {
    if ( !fs.existsSync(this.logFileName()) ) {
        return;
    }
    var json = fs.readFileSync(this.logFileName(), {encoding:&#x22;utf8&#x22;});
    if (!json) { return; }
    var log;
    try {
        log = JSON.parse(json);
    } catch (ex) {
        // open-ended JSON
        log = JSON.parse(json + &#x27;}&#x27;);
    }
    this.tails = log[&#x27;&#x27;];
    delete log[&#x27;&#x27;];
    for(var s in log) {
        var spec = new Spec(s);
        if (spec.pattern()===&#x27;/#!.&#x27;) {
            var ti = spec.filter(&#x27;/#&#x27;);
            var vm = spec.filter(&#x27;!.&#x27;);
            var tail = this.tails[ti] || (this.tails[ti] = {});
            tail[vm]  = log[spec];
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.options = options || {};
    this.lstn = {};
    this._id = id;
    this.tails = {};
    this.store = this.options.persistent ?
        window.localStorage : window.sessionStorage;

    this.<span class="apidocCodeKeywordSpan">loadLog</span>();
    this.installListeners();
}

SharedWebStorage.prototype = new Storage();
SharedWebStorage.prototype.isRoot = false;
module.exports = SharedWebStorage;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.FileStorage.prototype.logFileName" id="apidoc.element.swarm.FileStorage.prototype.logFileName">
        function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>logFileName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logFileName = function () {
    return path.resolve(this.dir, &#x22;_log&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.FileStorage.prototype.readOps" id="apidoc.element.swarm.FileStorage.prototype.readOps">
        function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>readOps
        <span class="apidocSignatureSpan">(ti, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readOps = function (ti, callback) {
    var tail = this.tails[ti];
    if (tail) {
        var unjsoned = {};
        for(var key in tail) {
            unjsoned[key] = tail[key];
        }
        tail = unjsoned;
    }
    callback(null, tail||null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.FileStorage.prototype.readState" id="apidoc.element.swarm.FileStorage.prototype.readState">
        function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>readState
        <span class="apidocSignatureSpan">(ti, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readState = function (ti, callback) {
    var statefn = this.stateFileName(ti);
    // read in the state
    fs.readFile(statefn, function onRead(err, data) { // FIXME fascism
        var state = err ? {_version: &#x27;!0&#x27;} : JSON.parse(data.toString());
        callback(null,state||null); // important: no state is &#x22;null&#x22;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.FileStorage.prototype.rotateLog" id="apidoc.element.swarm.FileStorage.prototype.rotateLog">
        function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>rotateLog
        <span class="apidocSignatureSpan">(noOpen, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rotateLog = function (noOpen, callback) {
    var self = this;
    if (this.logFile) {
        this.logFile.end(&#x27;}&#x27;, callback);
        this.logFile = null;
        callback = undefined;
    }

    if (!noOpen) {

        if (fs.existsSync(this.logFileName())) {
            fs.rename(this.logFileName(),this.logFileName()+&#x27;.bak&#x27;);
        }
        this.logFile = fs.createWriteStream(this.logFileName()); // TODO file swap
        this.logFile.on(&#x27;error&#x27;, function (err) {
            self.close(null,err);
        });

        var json = JSON.stringify(this.tails, undefined, 2);
        json = &#x27;{&#x22;&#x22;:\n&#x27; + json; // open-ended JSON

        this.logFile.write (json, function onFail(err) {
            if (err) { self.close(null,err); }
        });

    }

    if (callback) {
        callback();
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.FileStorage.prototype.stateFileName" id="apidoc.element.swarm.FileStorage.prototype.stateFileName">
        function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>stateFileName
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stateFileName = function (spec) {
    var base = path.resolve(this.dir, spec.type());
    var file = path.resolve(base, spec.id());
    return file; // TODO hashing?
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.FileStorage.prototype.writeOp" id="apidoc.element.swarm.FileStorage.prototype.writeOp">
        function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>writeOp
        <span class="apidocSignatureSpan">(spec, value, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeOp = function (spec, value, cb) {
    var self = this;
    var ti = spec.filter(&#x27;/#&#x27;);
    var vm = spec.filter(&#x27;!.&#x27;);
    var tail = this.tails[ti] || (this.tails[ti] = {});
    if (vm in tail) {
        console.error(&#x27;op replay @storage&#x27;,vm,new Error().stack);
        return;
    }
    var clone = JSON.parse(JSON.stringify(value)); // FIXME performance please
    tail[vm] = clone;
    var record = &#x27;,\n&#x22;&#x27;+spec+&#x27;&#x22;:\t&#x27;+JSON.stringify(clone);
    this.logFile.write (record, function onFail(err) {
        if (err) { self.close(null,err); }
        cb(err);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.FileStorage.prototype.writeState" id="apidoc.element.swarm.FileStorage.prototype.writeState">
        function <span class="apidocSignatureSpan">swarm.FileStorage.prototype.</span>writeState
        <span class="apidocSignatureSpan">(spec, state, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeState = function (spec, state, cb) {
    var self = this;
    var ti = spec.filter(&#x27;/#&#x27;);
    var fileName = this.stateFileName(ti);
    var dir = path.dirname(fileName);
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir);
    }
    var save = JSON.stringify(state, undefined, 2);
    // dump JSON to the tmp file
    delete self.tails[ti]; // TODO save &#x27;em in case write fails
    fs.writeFile(fileName, save, function onSave(err) {
        if (err) {
            console.error(&#x22;failed to flush state; can&#x27;t trim the log&#x22;, err);
        }
        cb(err);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Host" id="apidoc.module.swarm.Host">module swarm.Host</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Host.Host" id="apidoc.element.swarm.Host.Host">
        function <span class="apidocSignatureSpan">swarm.</span>Host
        <span class="apidocSignatureSpan">(id, ms, storage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Host(id, ms, storage) {
    this.objects = {};
    this.sources = {};
    this.storage = storage;
    this._host = this; // :)
    this._lstn = [&#x27;,&#x27;];
    this._id = id;
    this._server = /^swarm~.*/.test(id);
    var clock_fn = env.clockType || SecondPreciseClock;
    this.clock = new clock_fn(this._id, ms||0);

    if (this.storage) {
        this.sources[this._id] = this.storage;
        this.storage._host = this;
    }
    delete this.objects[this.spec()];

    if (!env.multihost) {
        if (env.localhost) {
            throw new Error(&#x27;use multihost mode&#x27;);
        }
        env.localhost = this;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
module.exports = Mouse; // CommonJS
```

### Using the model on the client (app.js)

```js
// 1. create local Host
var swarmHost = new Swarm.<span class="apidocCodeKeywordSpan">Host</span>(&#x27;unique_client_id&#x27;);

// 2. connect to your server
swarmHost.connect(&#x27;ws://localhost:8000/&#x27;);

// 3.a. create an object
var someMouse = new Mouse();
// OR swarmHost.get(&#x27;/Mouse&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host._super" id="apidoc.element.swarm.Host._super">
        function <span class="apidocSignatureSpan">swarm.Host.</span>_super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Syncable() {
    // listeners represented as objects that have deliver() method
    this._lstn = [&#x27;,&#x27;]; // we unshift() uplink listeners and push() downlinks
    // ...so _lstn is like [server1, server2, storage, &#x27;,&#x27;, view, listener]
    // The most correct way to specify a version is the version vector,
    // but that one may consume more space than the data itself in some cases.
    // Hence, _version is not a fully specified version vector (see version()
    // instead). _version is essentially is the greatest operation timestamp
    // (Lamport-like, i.e. &#x22;time+source&#x22;), sometimes amended with additional
    // timestamps. Its main features:
    // (1) changes once the object&#x27;s state changes
    // (2) does it monotonically (in the alphanum order sense)
    this._version = &#x27;&#x27;;
    // make sense of arguments
    var args = Array.prototype.slice.call(arguments);
    this._host = (args.length &#x26;&#x26; args[args.length - 1]._type === &#x27;Host&#x27;) ?
            args.pop() : env.localhost;
    if (Spec.is(args[0])) {
        this._id = new Spec(args.shift()).id() || this._host.time();
    } else if (typeof(args[0]) === &#x27;string&#x27;) {
        this._id = args.shift(); // TODO format
    } else {
        this._id = this._host.time();
        this._version = &#x27;!0&#x27;; // may apply state in the constructor, see Model
    }
    //var state = args.length ? args.pop() : (fresh?{}:undefined);
    // register with the host
    var doubl = this._host.register(this);
    if (doubl !== this) { return doubl; }
    // locally created objects get state immediately
    // (while external-id objects need to query uplinks)
<span class="apidocCodeCommentSpan">    /*if (fresh &#x26;&#x26; state) {
     state._version = &#x27;!&#x27;+this._id;
     var pspec = this.spec().add(state._version).add(&#x27;.init&#x27;);
     this.deliver(pspec,state,this._host);
     }*/
</span>    this.reset();
    // find uplinks, subscribe
    this.checkUplink();
    // TODO inplement state push
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.addReaction" id="apidoc.element.swarm.Host.addReaction">
        function <span class="apidocSignatureSpan">swarm.Host.</span>addReaction
        <span class="apidocSignatureSpan">(op, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addReaction = function (op, fn) {
    var reactions = this.prototype._reactions;
    var list = reactions[op];
    list || (list = reactions[op] = []);
    list.push(fn);
    return {op: op, fn: fn};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.extend" id="apidoc.element.swarm.Host.extend">
        function <span class="apidocSignatureSpan">swarm.Host.</span>extend
        <span class="apidocSignatureSpan">(fn, own)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (fn, own) {
    var parent = this, fnid;
    if (fn.constructor !== Function) {
        var id = fn.toString();
        fn = function SomeSyncable() {
            return parent.apply(this, arguments);
        };
        fnid = id; // if only it worked
    } else { // please call Syncable.constructor.apply(this,args) in your constructor
        fnid = fnname(fn);
    }

    // inheritance trick from backbone.js
    var SyncProto = function () {
        this.constructor = fn;
        this._neutrals = {};
        this._ops = {};
        this._reactions = {};

        var event,
            name;
        if (parent._pt) {
            //copy _neutrals &#x26; _ops from parent
            for (event in parent._pt._neutrals) {
                this._neutrals[event] = parent._pt._neutrals[event];
            }
            for (event in parent._pt._ops) {
                this._ops[event] = parent._pt._ops[event];
            }
        }

        // &#x22;Methods&#x22; are serialized, logged and delivered to replicas
        for (name in own.ops || {}) {
            if (Syncable.reMethodName.test(name)) {
                this._ops[name] = own.ops[name];
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid op name:&#x27;,name);
            }
        }

        // &#x22;Neutrals&#x22; don&#x27;t change the state
        for (name in own.neutrals || {}) {
            if (Syncable.reMethodName.test(name)) {
                this._neutrals[name] = own.neutrals[name];
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid neutral op name:&#x27;,name);
            }
        }

        // &#x22;Remotes&#x22; are serialized and sent upstream (like RPC calls)
        for (name in own.remotes || {}) {
            if (Syncable.reMethodName.test(name)) {
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid rpc name:&#x27;,name);
            }
        }

        // add mixins
        (own.mixins || []).forEach(function (mixin) {
            for (var name in mixin) {
                this[name] = mixin[name];
            }
        }, this);

        // add other members
        for (name in own) {
            if (Syncable.reMethodName.test(name)) {
                var memberType = own[name].constructor;
                if (memberType === Function) { // non-op method
                    // these must change state ONLY by invoking ops
                    this[name] = own[name];
                } else if (memberType===String || memberType===Number) {
                    this[name] = own[name]; // some static constant, OK
                } else if (name in Syncable.memberClasses) {
                    // see above
                    continue;
                } else {
                    console.warn(&#x27;invalid member:&#x27;,name,memberType);
                }
            } else {
                console.warn(&#x27;invalid member name:&#x27;,name);
            }
        }

        // add reactions
        for (name in own.reactions || {}) {
            var reaction = own.reactions[name];
            if (!reaction) { continue; }

            switch (typeof reaction) {
            case &#x27;function&#x27;:
                // handler-function
                this._reactions[name] = [reaction];
                break;
            case &#x27;string&#x27;:
                // handler-method name
                this._reactions[name] = [this[name]];
                break;
            default:
                if (reaction.constructor === Array) {
                    // array of handlers
                    this._reactions[name] = reaction.map(function (item) {
                        switch (typeof item) {
                        case &#x27;function&#x27;:
                            return item;
                        case &#x27;string&#x27;:
                            return this[item];
                        default:
                            throw new Error(&#x27;unexpected reaction type&#x27;);
                        }
                    }, this);
                } else {
                    throw new Error(&#x27;unex ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
these demos are normally online at http://ppyr.us and http://ppyr.us:8001/demo3/index.html respectively.

### Creating your first simple synchronized type

```js
var Swarm = require(&#x27;swarm&#x27;);

var Mouse = Swarm.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;Mouse&#x27;, {
    defaults: {
        name: &#x27;Mickey&#x27;,
        x: 0,
        y: 0
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.hashDistance" id="apidoc.element.swarm.Host.hashDistance">
        function <span class="apidocSignatureSpan">swarm.Host.</span>hashDistance
        <span class="apidocSignatureSpan">(peer, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hashDistance(peer, obj) {
    if ((obj).constructor !== Number) {
        if (obj._id) {
            obj = obj._id;
        }
        obj = env.hashfn(obj);
    }
    if (peer._id) {
        peer = peer._id;
    }
    var dist = 4294967295;
    for (var i = 0; i &#x3c; Host.HASH_POINTS; i++) {
        var hash = env.hashfn(peer._id + &#x27;:&#x27; + i);
        dist = Math.min(dist, hash ^ obj);
    }
    return dist;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.removeReaction" id="apidoc.element.swarm.Host.removeReaction">
        function <span class="apidocSignatureSpan">swarm.Host.</span>removeReaction
        <span class="apidocSignatureSpan">(handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeReaction = function (handle) {
    var op = handle.op,
        fn = handle.fn,
        list = this.prototype._reactions[op],
        i = list.indexOf(fn);
    if (i === -1) {
        throw new Error(&#x27;reaction unknown&#x27;);
    }
    list[i] = undefined; // such a peculiar pattern not to mess up out-of-callback removal
    while (list.length &#x26;&#x26; !list[list.length - 1]) {
        list.pop();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Host.prototype" id="apidoc.module.swarm.Host.prototype">module swarm.Host.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.accept" id="apidoc.element.swarm.Host.prototype.accept">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>accept
        <span class="apidocSignatureSpan">(stream_or_url, pipe_env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accept = function (stream_or_url, pipe_env) {
    new Pipe(this, stream_or_url, pipe_env);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// start WebSocket server
var wsServer = new ws_lib.Server({ server: httpServer });

// accept incoming WebSockets connections
wsServer.on(&#x27;connection&#x27;, function (ws) {
    console.log(&#x27;new incoming WebSocket connection&#x27;);
    swarmHost.<span class="apidocCodeKeywordSpan">accept</span>(new Swarm.EinarosWSStream(ws), { delay: 50 });
});
```

see [swarm-example](https://github.com/swarmjs/swarm-example/blob/master/server.js) for a nice example of a generic model sync server


## Swarm API Quickstart
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.addSource" id="apidoc.element.swarm.Host.prototype.addSource">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>addSource
        <span class="apidocSignatureSpan">(spec, peer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hostAddPeer(spec, peer) {
    //FIXME when their time is off so tell them so
    // if (false) { this.clockOffset; }
    var old = this.sources[peer._id];
    if (old) {
        old.deliver(this.newEventSpec(&#x27;off&#x27;), &#x27;&#x27;, this);
    }

    this.sources[peer._id] = peer;
    if (spec.op() === &#x27;on&#x27;) {
        peer.deliver(this.newEventSpec(&#x27;reon&#x27;), this.clock.ms(), this);
    }
    for (var sp in this.objects) {
        this.objects[sp].checkUplink();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.callReactions" id="apidoc.element.swarm.Host.prototype.callReactions">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>callReactions
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callReactions = function (spec, value, src) {
    var superReactions = syncProto._super.callReactions;
    if (&#x27;function&#x27; === typeof superReactions) {
        superReactions.call(this, spec, value, src);
    }
    var r = syncProto._reactions[spec.op()];
    if (r) {
        r.constructor !== Array &#x26;&#x26; (r = [r]);
        for (var i = 0; i &#x3c; r.length; i++) {
            r[i] &#x26;&#x26; r[i].call(this, spec, value, src);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.checkUplink" id="apidoc.element.swarm.Host.prototype.checkUplink">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>checkUplink
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkUplink = function (spec) {
    //  TBD Host event relay + PEX
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.close" id="apidoc.element.swarm.Host.prototype.close">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb) {
    for(var id in this.sources) {
        if (id===this._id) {continue;}
        this.disconnect(id);
    }
    if (this.storage) {
        this.storage.close(cb);
    } else if (cb) {
        cb();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }, 1);
};

AsyncLoopbackConnection.prototype.close = function () {
    delete AsyncLoopbackConnection.pipes[this.id];
    var pair = this.pair();
    pair &#x26;&#x26; pair.<span class="apidocCodeKeywordSpan">close</span>();
    this.lstn.close &#x26;&#x26; this.lstn.close();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.connect" id="apidoc.element.swarm.Host.prototype.connect">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>connect
        <span class="apidocSignatureSpan">(stream_or_url, pipe_env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (stream_or_url, pipe_env) {
    var pipe = new Pipe(this, stream_or_url, pipe_env);
    pipe.deliver(new Spec(&#x27;/Host#&#x27;+this._id+&#x27;!0.on&#x27;), &#x27;&#x27;, this); //this.newEventSpec
    return pipe;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Using the model on the client (app.js)

```js
// 1. create local Host
var swarmHost = new Swarm.Host(&#x27;unique_client_id&#x27;);

// 2. connect to your server
swarmHost.<span class="apidocCodeKeywordSpan">connect</span>(&#x27;ws://localhost:8000/&#x27;);

// 3.a. create an object
var someMouse = new Mouse();
// OR swarmHost.get(&#x27;/Mouse&#x27;);
// OR new Mouse({x:1, y:2});

// 4.a. a locally created object may be touched immediately
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.constructor" id="apidoc.element.swarm.Host.prototype.constructor">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>constructor
        <span class="apidocSignatureSpan">(id, ms, storage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Host(id, ms, storage) {
    this.objects = {};
    this.sources = {};
    this.storage = storage;
    this._host = this; // :)
    this._lstn = [&#x27;,&#x27;];
    this._id = id;
    this._server = /^swarm~.*/.test(id);
    var clock_fn = env.clockType || SecondPreciseClock;
    this.clock = new clock_fn(this._id, ms||0);

    if (this.storage) {
        this.sources[this._id] = this.storage;
        this.storage._host = this;
    }
    delete this.objects[this.spec()];

    if (!env.multihost) {
        if (env.localhost) {
            throw new Error(&#x27;use multihost mode&#x27;);
        }
        env.localhost = this;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.deliver" id="apidoc.element.swarm.Host.prototype.deliver">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>deliver
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deliver = function (spec, val, repl) {
    if (spec.type() !== &#x27;Host&#x27;) {
        var typeid = spec.filter(&#x27;/#&#x27;);
        var obj = this.get(typeid);
        if (obj) {
            // TODO seeTimestamp()
            obj.deliver(spec, val, repl);
        }
    } else {
        this._super.deliver.apply(this, arguments);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.callbacks===null) { return; }
var that = this.owner || src;
for(var i=0; i&#x3c;this.callbacks.length; i++) {
    var cb = this.callbacks[i];
    if (cb.constructor===Function) {
        cb.call(that,spec,value,src);
    } else {
        cb.<span class="apidocCodeKeywordSpan">deliver</span>(spec,value,src);
    }
}
};

ProxyListener.prototype.on = function (callback) {
if (this.callbacks===null) { this.callbacks = []; }
this.callbacks.push(callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.disconnect" id="apidoc.element.swarm.Host.prototype.disconnect">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>disconnect
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function (id) {
    for (var peer_id in this.sources) {
        if (id &#x26;&#x26; peer_id != id) {
            continue;
        }
        if (peer_id === this._id) {
            // storage
            continue;
        }
        var peer = this.sources[peer_id];
        // normally, .off is sent by a downlink
        peer.deliver(peer.spec().add(this.time(), &#x27;!&#x27;).add(&#x27;.off&#x27;));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.get" id="apidoc.element.swarm.Host.prototype.get">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>get
        <span class="apidocSignatureSpan">(spec, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (spec, callback) {
    if (spec &#x26;&#x26; spec.constructor === Function &#x26;&#x26; spec.prototype._type) {
        spec = &#x27;/&#x27; + spec.prototype._type;
    }
    spec = new Spec(spec);
    var typeid = spec.filter(&#x27;/#&#x27;);
    if (!typeid.has(&#x27;/&#x27;)) {
        throw new Error(&#x27;invalid spec&#x27;);
    }
    var o = typeid.has(&#x27;#&#x27;) &#x26;&#x26; this.objects[typeid];
    if (!o) {
        var t = Syncable.types[spec.type()];
        if (!t) {
            throw new Error(&#x27;type unknown: &#x27; + spec);
        }
        o = new t(typeid, undefined, this);
        if (typeof(callback) === &#x27;function&#x27;) {
            o.on(&#x27;.init&#x27;, callback);
        }
    }
    return o;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var swarmHost = new Swarm.Host(&#x27;unique_client_id&#x27;);

// 2. connect to your server
swarmHost.connect(&#x27;ws://localhost:8000/&#x27;);

// 3.a. create an object
var someMouse = new Mouse();
// OR swarmHost.<span class="apidocCodeKeywordSpan">get</span>(&#x27;/Mouse&#x27;);
// OR new Mouse({x:1, y:2});

// 4.a. a locally created object may be touched immediately
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.getSources" id="apidoc.element.swarm.Host.prototype.getSources">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>getSources
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSources = function (spec) {
    var self = this,
        uplinks = [],
        mindist = 4294967295,
        rePeer = /^swarm~/, // peers, not clients
        target = env.hashfn(spec),
        closestPeer = null;

    if (rePeer.test(this._id)) {
        mindist = Host.hashDistance(this._id, target);
        closestPeer = this.storage;
    } else {
        uplinks.push(self.storage); // client-side cache
    }

    for (var id in this.sources) {
        if (!rePeer.test(id)) {
            continue;
        }
        var dist = Host.hashDistance(id, target);
        if (dist &#x3c; mindist) {
            closestPeer = this.sources[id];
            mindist = dist;
        }
    }
    if (closestPeer) {
        uplinks.push(closestPeer);
    }
    return uplinks;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.init" id="apidoc.element.swarm.Host.prototype.init">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>init
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (spec, val, repl) {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.isServer" id="apidoc.element.swarm.Host.prototype.isServer">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>isServer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isServer = function () {
    return this._server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.isUplinked" id="apidoc.element.swarm.Host.prototype.isUplinked">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>isUplinked
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isUplinked = function () {
    for (var id in this.sources) {
        if (/^swarm~.*/.test(id)) {
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.off" id="apidoc.element.swarm.Host.prototype.off">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>off
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Unsubscribe from collections entries&#x27; events
 * @param {function(*)} callback
 * @this Set|Vector
 */
offObjectEvent: function (callback) {
    this._proxy.<span class="apidocCodeKeywordSpan">off</span>(callback);
},

/**
 * Waits for collection to receive state from cache or uplink and then invokes passed callback
 *
 * @param {function()} callback
 * @this Set|Vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.on" id="apidoc.element.swarm.Host.prototype.on">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.register" id="apidoc.element.swarm.Host.prototype.register">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>register
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">register = function (obj) {
    var spec = obj.spec();
    if (spec in this.objects) {
        return this.objects[spec];
    }
    this.objects[spec] = obj;
    return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.removeSource" id="apidoc.element.swarm.Host.prototype.removeSource">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>removeSource
        <span class="apidocSignatureSpan">(spec, peer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeSource = function (spec, peer) {
    if (spec.type() !== &#x27;Host&#x27;) {
        throw new Error(&#x27;Host.removeSource(/NoHost)&#x27;);
    }

    if (this.sources[peer._id] !== peer) {
        console.error(&#x27;peer unknown&#x27;, peer._id); //throw new Error
        return;
    }
    delete this.sources[peer._id];
    for (var sp in this.objects) {
        var obj = this.objects[sp];
        if (obj.getListenerIndex(peer, true) &#x3e; -1) {
            obj.off(sp, &#x27;&#x27;, peer);
            obj.checkUplink(sp);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.reoff" id="apidoc.element.swarm.Host.prototype.reoff">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>reoff
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.reon" id="apidoc.element.swarm.Host.prototype.reon">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>reon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.time" id="apidoc.element.swarm.Host.prototype.time">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>time
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time = function () {
    var ts = this.clock.issueTimestamp();
    this._version = ts;
    return ts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype.unregister" id="apidoc.element.swarm.Host.prototype.unregister">
        function <span class="apidocSignatureSpan">swarm.Host.prototype.</span>unregister
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unregister = function (obj) {
    var spec = obj.spec();
    // TODO unsubscribe from the uplink - swarm-scale gc
    if (spec in this.objects) {
        delete this.objects[spec];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Host.prototype._neutrals" id="apidoc.module.swarm.Host.prototype._neutrals">module swarm.Host.prototype._neutrals</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Host.prototype._neutrals.error" id="apidoc.element.swarm.Host.prototype._neutrals.error">
        function <span class="apidocSignatureSpan">swarm.Host.prototype._neutrals.</span>error
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (spec, val, repl) {
    console.error(&#x27;something failed:&#x27;, spec, val, &#x27;@&#x27;, (repl &#x26;&#x26; repl._id));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.buf = buf; //will wait for &#x22;open&#x22;
    }
    ws.on(&#x27;close&#x27;, function () { ln.close &#x26;&#x26; ln.close(); });
    ws.on(&#x27;data&#x27;, function (msg) {
        try {
            ln.data &#x26;&#x26; ln.data(msg);
        } catch (ex) {
            console.<span class="apidocCodeKeywordSpan">error</span>(&#x27;message processing fails&#x27;, ex);
            ln.error &#x26;&#x26; ln.error(ex.message);
        }
    });
}

module.exports = SockJSStream;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype._neutrals.off" id="apidoc.element.swarm.Host.prototype._neutrals.off">
        function <span class="apidocSignatureSpan">swarm.Host.prototype._neutrals.</span>off
        <span class="apidocSignatureSpan">(spec, nothing, peer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (spec, nothing, peer) {
    peer.deliver(peer.spec().add(this.time(), &#x27;!&#x27;).add(&#x27;.reoff&#x27;), &#x27;&#x27;, this);
    this.removeSource(spec, peer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Unsubscribe from collections entries&#x27; events
 * @param {function(*)} callback
 * @this Set|Vector
 */
offObjectEvent: function (callback) {
    this._proxy.<span class="apidocCodeKeywordSpan">off</span>(callback);
},

/**
 * Waits for collection to receive state from cache or uplink and then invokes passed callback
 *
 * @param {function()} callback
 * @this Set|Vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype._neutrals.on" id="apidoc.element.swarm.Host.prototype._neutrals.on">
        function <span class="apidocSignatureSpan">swarm.Host.prototype._neutrals.</span>on
        <span class="apidocSignatureSpan">(spec, filter, lstn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hostOn(spec, filter, lstn) {
    if (!filter) {
        // the subscriber needs &#x22;all the events&#x22;
        return this.addSource(spec, lstn);
    }

    if (filter.constructor === Function &#x26;&#x26; filter.id) {
        filter = new Spec(filter.id, &#x27;/&#x27;);
    } else if (filter.constructor === String) {
        filter = new Spec(filter, &#x27;.&#x27;);
    }
    // either suscribe to this Host or to some other object
    if (!filter.has(&#x27;/&#x27;) || filter.type() === &#x27;Host&#x27;) {
        this._super._neutrals.on.call(this, spec, filter, lstn);
    } else {
        var objSpec = new Spec(filter);
        if (!objSpec.has(&#x27;#&#x27;)) {
            throw new Error(&#x27;no id to listen&#x27;);
        }
        objSpec = objSpec.set(&#x27;.on&#x27;).set(spec.version(), &#x27;!&#x27;);
        this.deliver(objSpec, filter, lstn);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype._neutrals.reoff" id="apidoc.element.swarm.Host.prototype._neutrals.reoff">
        function <span class="apidocSignatureSpan">swarm.Host.prototype._neutrals.</span>reoff
        <span class="apidocSignatureSpan">(spec, nothing, peer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hostReOff(spec, nothing, peer) {
    this.removeSource(spec, peer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Host.prototype._neutrals.reon" id="apidoc.element.swarm.Host.prototype._neutrals.reon">
        function <span class="apidocSignatureSpan">swarm.Host.prototype._neutrals.</span>reon
        <span class="apidocSignatureSpan">(spec, ms, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hostReOn(spec, ms, host) {
    if (spec.type() !== &#x27;Host&#x27;) {
        throw new Error(&#x27;Host.reon(/NotHost.reon)&#x27;);
    }
    this.clock.adjustTime(ms);
    this.addSource(spec, host);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Host.prototype._ops" id="apidoc.module.swarm.Host.prototype._ops">module swarm.Host.prototype._ops</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Host.prototype._ops.init" id="apidoc.element.swarm.Host.prototype._ops.init">
        function <span class="apidocSignatureSpan">swarm.Host.prototype._ops.</span>init
        <span class="apidocSignatureSpan">(spec, state, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (spec, state, src) {

    var tail = {}, // ops to be applied on top of the received state
        typeid = spec.filter(&#x27;/#&#x27;),
        lstn = this._lstn,
        a_spec;
    this._lstn = []; // prevent events from being fired

    if (state._version/* &#x26;&#x26; state._version !== &#x27;!0&#x27;*/) {
        // local changes may need to be merged into the received state
        if (this._oplog) {
            for (a_spec in this._oplog) {
                tail[a_spec] = this._oplog[a_spec];
            }
            this._oplog = {};
        }
        this._vector &#x26;&#x26; (this._vector = undefined);
        // zero everything
        for (var key in this) {
            if (this.hasOwnProperty(key) &#x26;&#x26; key.charAt(0) !== &#x27;_&#x27;) {
                this[key] = undefined;
            }
        }
        // set default values
        this.reset();

        this.apply(state);
        this._version = state._version;

        state._oplog &#x26;&#x26; (this._oplog = state._oplog); // FIXME copy
        state._vector &#x26;&#x26; (this._vector = state._vector);
    }
    // add the received tail to the local one
    if (state._tail) {
        for (a_spec in state._tail) {
            tail[a_spec] = state._tail[a_spec];
        }
    }
    // appply the combined tail to the new state
    var specs = [];
    for (a_spec in tail) {
        specs.push(a_spec);
    }
    specs.sort().reverse();
    // there will be some replays, but those will be ignored
    while (a_spec = specs.pop()) {
        this.deliver(typeid.add(a_spec), tail[a_spec], this);
    }

    this._lstn = lstn;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.LamportClock" id="apidoc.module.swarm.LamportClock">module swarm.LamportClock</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.LamportClock.LamportClock" id="apidoc.element.swarm.LamportClock.LamportClock">
        function <span class="apidocSignatureSpan">swarm.</span>LamportClock
        <span class="apidocSignatureSpan">(processId, initTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LamportClock = function (processId, initTime) {
    if (!Spec.reTok.test(processId)) {
        throw new Error(&#x27;invalid process id: &#x27;+processId);
    }
    this.id = processId;
    // sometimes we assume our local clock has some offset
    this.seq = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.LamportClock.prototype" id="apidoc.module.swarm.LamportClock.prototype">module swarm.LamportClock.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.LamportClock.prototype.adjustTime" id="apidoc.element.swarm.LamportClock.prototype.adjustTime">
        function <span class="apidocSignatureSpan">swarm.LamportClock.prototype.</span>adjustTime
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">adjustTime = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LamportClock.prototype.checkTimestamp" id="apidoc.element.swarm.LamportClock.prototype.checkTimestamp">
        function <span class="apidocSignatureSpan">swarm.LamportClock.prototype.</span>checkTimestamp
        <span class="apidocSignatureSpan">(ts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function see(ts) {
    var parsed = this.parseTimestamp(ts);
    if (parsed.seq &#x3e;= this.seq) {
        this.seq = parsed.seq + 1;
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                        seqi = 1; // FIXME repeat ids, double insert
                    }
                }
            }
        }
    }
    if (genTs) {
        this._host.clock.<span class="apidocCodeKeywordSpan">checkTimestamp</span>(genTs);
    }
    this.weave = w1.join(&#x27;&#x27;);
    this.ids = w4;
    this.rebuild();
},
remove: function (spec, rm, src) {
    var w1 = [], w4 = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LamportClock.prototype.issueTimestamp" id="apidoc.element.swarm.LamportClock.prototype.issueTimestamp">
        function <span class="apidocSignatureSpan">swarm.LamportClock.prototype.</span>issueTimestamp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function time() {
    var base = Spec.int2base(this.seq++, 5);
    return base + &#x27;+&#x27; + this.id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LamportClock.prototype.parseTimestamp" id="apidoc.element.swarm.LamportClock.prototype.parseTimestamp">
        function <span class="apidocSignatureSpan">swarm.LamportClock.prototype.</span>parseTimestamp
        <span class="apidocSignatureSpan">(ts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(ts) {
    var m = ts.match(Spec.reTokExt);
    if (!m) {throw new Error(&#x27;malformed timestamp: &#x27;+ts);}
    return {
        seq: Spec.base2int(m[1]),
        process: m[2]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        seq: Spec.base2int(m[1]),
        process: m[2]
    };
};

/** Lamport partial order  imperfect semi-logical*/
LamportClock.prototype.checkTimestamp = function see (ts) {
    var parsed = this.<span class="apidocCodeKeywordSpan">parseTimestamp</span>(ts);
    if (parsed.seq &#x3e;= this.seq) {
        this.seq = parsed.seq + 1;
    }
    return true;
};

LamportClock.prototype.time2date = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LamportClock.prototype.time2date" id="apidoc.element.swarm.LamportClock.prototype.time2date">
        function <span class="apidocSignatureSpan">swarm.LamportClock.prototype.</span>time2date
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time2date = function () {
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.LevelStorage" id="apidoc.module.swarm.LevelStorage">module swarm.LevelStorage</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.LevelStorage.LevelStorage" id="apidoc.element.swarm.LevelStorage.LevelStorage">
        function <span class="apidocSignatureSpan">swarm.</span>LevelStorage
        <span class="apidocSignatureSpan">(id, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LevelStorage(id, options, callback) {
    Storage.call(this);
    this.options = options;
    this._host = null; // will be set by the Host
    this.db = options.db;
    this._id = id;
    this.filename = null;
    if (this.db.constructor===Function) {
        this.db = this.db(options.path||id);
    }
    this.logtails = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.LevelStorage.prototype" id="apidoc.module.swarm.LevelStorage.prototype">module swarm.LevelStorage.prototype</a></h1>






    <h2>
        <a href="#apidoc.element.swarm.LevelStorage.prototype.close" id="apidoc.element.swarm.LevelStorage.prototype.close">
        function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>close
        <span class="apidocSignatureSpan">(callback, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback, error) { // FIXME
    if (error) {
        console.log(&#x22;fatal IO error&#x22;, error);
    }
    if (this.db) {
        this.db.close(callback);
        this.db = null;
    } else {
        callback(); // closed already
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }, 1);
};

AsyncLoopbackConnection.prototype.close = function () {
    delete AsyncLoopbackConnection.pipes[this.id];
    var pair = this.pair();
    pair &#x26;&#x26; pair.<span class="apidocCodeKeywordSpan">close</span>();
    this.lstn.close &#x26;&#x26; this.lstn.close();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LevelStorage.prototype.off" id="apidoc.element.swarm.LevelStorage.prototype.off">
        function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>off
        <span class="apidocSignatureSpan">(spec, val, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (spec, val, src) {
    var ti = spec.filter(&#x27;/#&#x27;);
    delete this.logtails[ti];
    Storage.prototype.off.call(this,spec,val,src);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Unsubscribe from collections entries&#x27; events
 * @param {function(*)} callback
 * @this Set|Vector
 */
offObjectEvent: function (callback) {
    this._proxy.<span class="apidocCodeKeywordSpan">off</span>(callback);
},

/**
 * Waits for collection to receive state from cache or uplink and then invokes passed callback
 *
 * @param {function()} callback
 * @this Set|Vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LevelStorage.prototype.open" id="apidoc.element.swarm.LevelStorage.prototype.open">
        function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>open
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function (callback) {
    this.db.open(this.options.dbOptions||{}, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LevelStorage.prototype.readOps" id="apidoc.element.swarm.LevelStorage.prototype.readOps">
        function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>readOps
        <span class="apidocSignatureSpan">(ti, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readOps = function (ti, callback) {
    var self = this;
    var tail = {}, log = [];
    var i = this.db.iterator({
        gt: ti+&#x27; &#x27;,
        lt: ti+&#x27;0&#x27;
    });
    i.next(function recv(err,key,value){
        if (err) {
            callback(err);
            i.end(function(err){});
        } else if (key) {
            var spec = new Spec(key);
            var vo = spec.filter(&#x27;!.&#x27;);
            tail[vo] = JSON.parse(value.toString());
            log.push(vo);
            i.next(recv);
        } else {
            console.log(&#x27;&#x3c;TAIL&#x27;,self._host &#x26;&#x26; self._host._id,tail);
            self.logtails[ti] = ti in self.logtails ?
                self.logtails[ti].concat(log) : log;
            callback(null, tail);
            i.end(function(err){
                err &#x26;&#x26; console.error(&#x22;can&#x27;t close an iter&#x22;,err);
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LevelStorage.prototype.readState" id="apidoc.element.swarm.LevelStorage.prototype.readState">
        function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>readState
        <span class="apidocSignatureSpan">(ti, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readState = function (ti, callback) {
    var self = this;
    ti = ti.toString();
    this.db.get(ti, {asBuffer:false}, function(err,value){

        var notFound = err &#x26;&#x26; /^NotFound/.test(err.message);
        if (err &#x26;&#x26; !notFound) { return callback(err); }

        if ((err &#x26;&#x26; notFound) || !value) {
            err = null;
            value = {_version: &#x27;!0&#x27;};
        } else {
            value = JSON.parse(value);
        }

        console.log(&#x27;&#x3c;STATE&#x27;,self._host &#x26;&#x26; self._host._id,value);
        callback(err, value);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LevelStorage.prototype.writeOp" id="apidoc.element.swarm.LevelStorage.prototype.writeOp">
        function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>writeOp
        <span class="apidocSignatureSpan">(spec, value, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeOp = function (spec, value, cb) {
    var json = JSON.stringify(value);
    var ti = spec.filter(&#x27;/#&#x27;);
    if (!this.logtails[ti]) {
        this.logtails[ti] = [];
    }
    this.logtails[ti].push(spec);
    console.log(&#x27;&#x3e;OP&#x27;,spec.toString(),json);
    this.db.put(spec.toString(), json, function (err){
        err &#x26;&#x26; console.error(&#x27;op write error&#x27;,err);
        cb(err);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LevelStorage.prototype.writeState" id="apidoc.element.swarm.LevelStorage.prototype.writeState">
        function <span class="apidocSignatureSpan">swarm.LevelStorage.prototype.</span>writeState
        <span class="apidocSignatureSpan">(spec, state, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeState = function (spec, state, cb) {
    console.log(&#x27;&#x3e;STATE&#x27;,state);
    var self = this;
    var ti = spec.filter(&#x27;/#&#x27;);
    //var save = JSON.stringify(state, undefined, 2);
    if (!self.db) {
        console.warn(&#x27;the storage is not open&#x27;, this._host&#x26;&#x26;this._host._id);
        return;
    }

    var json = JSON.stringify(state);
    var cleanup = [], key;
    if (ti in this.logtails) {
        while (key = this.logtails[ti].pop()) {
            cleanup.push({
                key: key,
                type: &#x27;del&#x27;
            });
        }
        delete this.logtails[ti];
    }
    console.log(&#x27;&#x3e;FLUSH&#x27;,json,cleanup.length);
    self.db.put(ti, json, function onSave(err) {
        if (!err &#x26;&#x26; cleanup.length &#x26;&#x26; self.db) {
            console.log(&#x27;&#x3e;CLEAN&#x27;,cleanup);
            self.db.batch(cleanup, function(err){
                err &#x26;&#x26; console.error(&#x27;log trimming failed&#x27;,err);
            });
        }
        err &#x26;&#x26; console.error(&#x22;state write error&#x22;, err);
        cb(err);
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.LongSpec" id="apidoc.module.swarm.LongSpec">module swarm.LongSpec</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.LongSpec.LongSpec" id="apidoc.element.swarm.LongSpec.LongSpec">
        function <span class="apidocSignatureSpan">swarm.</span>LongSpec
        <span class="apidocSignatureSpan">(spec, codeBook)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LongSpec = function (spec, codeBook) {
    var cb = this.codeBook = codeBook || {en:{},de:{}};
    if (!cb.en) { cb.en = {}; }
    if (!cb.de) { // revert en to make de
        cb.de = {};
        for(var tok in cb.en) {
            cb.de[cb.en[tok]] = tok;
        }
    }
    if (!cb.lastCodes) {
        cb.lastCodes = {&#x27;/&#x27;:0x30,&#x27;#&#x27;:0x30,&#x27;!&#x27;:0x30,&#x27;.&#x27;:0x30,&#x27;+&#x27;:0x30};
    }
    // For a larger document, a single LongSpec may be some megabytes long.
    // As we don&#x27;t want to rewrite those megabytes on every keypress, we
    // divide data into chunks.
    this.chunks = [];
    this.chunkLengths = [];
    if (spec) {
        this.append(spec);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator" id="apidoc.element.swarm.LongSpec.Iterator">
        function <span class="apidocSignatureSpan">swarm.LongSpec.</span>Iterator
        <span class="apidocSignatureSpan">(owner, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Iterator(owner, index) {
    this.owner = owner;         // our LongSpec
<span class="apidocCodeCommentSpan">    /*this.chunk = 0;             // the chunk we are in
    this.index = -1;            // token index (position &#x22;before the 1st token&#x22;)
    this.chunkIndex = -1;       // token index within the chunk
    this.prevFull = undefined;  // previous full (non-collapsed) token
    //  seqStart IS the previous match or prev match is trivial
    this.prevCollapsed = 0;
    this.match = null;
    //this.next();*/
</span>    this.skip2chunk(0);
    if (index) {
        if (index.constructor===LongSpec.Iterator) {
            index = index.index;
        }
        this.skip(index);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.int2uni" id="apidoc.element.swarm.LongSpec.int2uni">
        function <span class="apidocSignatureSpan">swarm.LongSpec.</span>int2uni
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">int2uni = function (i) {
    if (i&#x3c;0 || i&#x3e;0x7fffffff) { throw new Error(&#x27;int is out of range&#x27;); }
    return String.fromCharCode( 0x30+(i&#x3e;&#x3e;15), 0x30+(i&#x26;0x7fff) );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.uni2int" id="apidoc.element.swarm.LongSpec.uni2int">
        function <span class="apidocSignatureSpan">swarm.LongSpec.</span>uni2int
        <span class="apidocSignatureSpan">(uni)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uni2int = function (uni) {
    if (!/^[0-\u802f]{2}$/.test(uni)) {
        throw new Error(&#x27;invalid unicode number&#x27;) ;
    }
    return ((uni.charCodeAt(0)-0x30)&#x3c;&#x3c;15) | (uni.charCodeAt(1)-0x30);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.LongSpec.Iterator" id="apidoc.module.swarm.LongSpec.Iterator">module swarm.LongSpec.Iterator</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator.Iterator" id="apidoc.element.swarm.LongSpec.Iterator.Iterator">
        function <span class="apidocSignatureSpan">swarm.LongSpec.</span>Iterator
        <span class="apidocSignatureSpan">(owner, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Iterator(owner, index) {
    this.owner = owner;         // our LongSpec
<span class="apidocCodeCommentSpan">    /*this.chunk = 0;             // the chunk we are in
    this.index = -1;            // token index (position &#x22;before the 1st token&#x22;)
    this.chunkIndex = -1;       // token index within the chunk
    this.prevFull = undefined;  // previous full (non-collapsed) token
    //  seqStart IS the previous match or prev match is trivial
    this.prevCollapsed = 0;
    this.match = null;
    //this.next();*/
</span>    this.skip2chunk(0);
    if (index) {
        if (index.constructor===LongSpec.Iterator) {
            index = index.index;
        }
        this.skip(index);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.LongSpec.Iterator.prototype" id="apidoc.module.swarm.LongSpec.Iterator.prototype">module swarm.LongSpec.Iterator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator.prototype.clone" id="apidoc.element.swarm.LongSpec.Iterator.prototype.clone">
        function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
    var copy = new LongSpec.Iterator(this.owner);
    copy.chunk = this.chunk;
    copy.match = this.match;
    copy.index = this.index;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator.prototype.decode" id="apidoc.element.swarm.LongSpec.Iterator.prototype.decode">
        function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>decode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decode() {
    if (this.match===null) { return undefined; }
    var quant = this.match[1];
    var body = this.match[3];
    var ext = this.match[4];
    var pm=this.prevFull, prevTok, prevQuant, prevBody, prevExt;
    var int1, int2, base1, base2;
    var de = quant;
    if (pm) {
        prevTok=pm[0], prevQuant=pm[1], prevBody=pm[3], prevExt=pm[4];
    }
    if (!body) {
        if (prevBody.length===1) {
            body = prevBody;
        } else {
            var l_1 = prevBody.length-1;
            var int = prevBody.charCodeAt(l_1);
            body = prevBody.substr(0,l_1) + String.fromCharCode(int+this.prevCollapsed+1);
        }
        ext = prevExt;
    }
    switch (body.length) {
        case 1:
            de += this.owner.codeBook.de[quant+body].substr(1); // TODO sep codebooks
            break;
        case 2:
            int1 = LongSpec.uni2int(body);
            base1 = Spec.int2base(int1,5);
            de += base1;
            break;
        case 3:
            int1 = LongSpec.uni2int(body.substr(0,2));
            int2 = LongSpec.uni2int(&#x27;0&#x27;+body.charAt(2));
            base1 = Spec.int2base(int1,5);
            base2 = Spec.int2base(int2,2);
            de += base1 + base2;
            break;
        case 4:
            int1 = LongSpec.uni2int(body.substr(0,2));
            int2 = LongSpec.uni2int(body.substr(2,2));
            base1 = Spec.int2base(int1,5);
            base2 = Spec.int2base(int2,5);
            de += base1 + base2;
            break;
        default:
            de += body;
            break;
    }
    if (ext) {
        var deExt = this.owner.codeBook.de[&#x27;+&#x27;+ext];
        de += deExt;
    }
    return de;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator.prototype.encode" id="apidoc.element.swarm.LongSpec.Iterator.prototype.encode">
        function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>encode
        <span class="apidocSignatureSpan">(de)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encode(de) {
    var re = Spec.reQTokExt;
    re.lastIndex = 0;
    var m=re.exec(de); // this one is de
    if (!m || m[0].length!==de.length) {throw new Error(&#x27;malformed token: &#x27;+de);}
    var tok=m[0], quant=m[1], body=m[3], ext=m[4];
    var pm = this.prevFull; // this one is en
    var prevTok, prevQuant, prevBody, prevExt;
    var enBody, enExt;
    if (pm) {
        prevTok=pm[0], prevQuant=pm[1], prevBody=pm[3], prevExt=pm[4]?&#x27;+&#x27;+pm[4]:undefined;
    }
    if (ext) {
        enExt = this.owner.codeBook.en[&#x27;+&#x27;+ext] || this.owner.allocateCode(&#x27;+&#x27;+ext);
    }
    var maySeq = pm &#x26;&#x26; quant===prevQuant &#x26;&#x26; enExt===prevExt;
    var haveSeq=false, seqBody = &#x27;&#x27;;
    var int1, int2, uni1, uni2;
    //var expected = head + (counter===-1?&#x27;&#x27;:Spec.int2base(counter+inc,1)) + tail;
    if ( body.length&#x3c;=4 ||          // TODO make it a switch
         (quant in LongSpec.quants2code) ||
         (tok in this.owner.codeBook.en) ) {  // 1 symbol by the codebook

        enBody = this.owner.codeBook.en[quant+body] ||
                 this.owner.allocateCode(quant+body);
        enBody = enBody.substr(1); // FIXME separate codebooks 4 quants
        if (maySeq) {// seq coding for dictionary-coded
            seqBody = enBody;
        }
    } else if (body.length===5) { // 2-symbol base-2^15
        var int = Spec.base2int(body);
        enBody = LongSpec.int2uni(int);
        if (maySeq &#x26;&#x26; prevBody.length===2) {
            seqBody = LongSpec.int2uni(int-this.prevCollapsed-1);
        }
    } else if (body.length===7) { // 3-symbol base-2^15
        int1 = Spec.base2int(body.substr(0,5));
        int2 = Spec.base2int(body.substr(5,2));
        uni1 = LongSpec.int2uni(int1);
        uni2 = LongSpec.int2uni(int2).charAt(1);
        enBody = uni1 + uni2;
        if (maySeq &#x26;&#x26; prevBody.length===3) {
            seqBody = uni1 + LongSpec.int2uni(int2-this.prevCollapsed-1).charAt(1);
        }
    } else if (body.length===10) { // 4-symbol 60-bit long number
        int1 = Spec.base2int(body.substr(0,5));
        int2 = Spec.base2int(body.substr(5,5));
        uni1 = LongSpec.int2uni(int1);
        uni2 = LongSpec.int2uni(int2);
        enBody = uni1 + uni2;
        if (maySeq &#x26;&#x26; prevBody.length===4) {
            seqBody = uni1+LongSpec.int2uni(int2-this.prevCollapsed-1);
        }
    } else { // verbatim
        enBody = body;
        seqBody = enBody;
    }
    haveSeq = seqBody===prevBody;
    return haveSeq ? quant : quant+enBody+(enExt||&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator.prototype.end" id="apidoc.element.swarm.LongSpec.Iterator.prototype.end">
        function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
    return this.match===null &#x26;&#x26; this.chunk===this.owner.chunks.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator.prototype.erase" id="apidoc.element.swarm.LongSpec.Iterator.prototype.erase">
        function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>erase
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">erase = function (count) {
    if (this.end()) {return;}
    count = count || 1;
    var chunks = this.owner.chunks;
    var lengths = this.owner.chunkLengths;
    // remember offsets
    var fromChunk = this.chunk;
    var fromOffset = this.match.index;
    var fromChunkIndex = this.chunkIndex; // TODO clone USE 2 iterators or i+c

    count = this.skip(count); // checked for runaway skip()
    // the iterator now is at the first-after-erased pos

    var tillChunk = this.chunk;
    var tillOffset = this.match ? this.match.index : 0; // end()

    var collapsed = this.match &#x26;&#x26; this.match[0].length===1;

    // splice strings, adjust indexes
    if (fromChunk===tillChunk) {
        var chunk = chunks[this.chunk];
        var pre = chunk.substr(0,fromOffset);
        var post = chunk.substr(tillOffset);
        if (collapsed) { // sequence is broken now; needs expansion
            post = this.token() + post.substr(1);
        }
        chunks[this.chunk] = pre + post;
        lengths[this.chunk] -= count;
        this.chunkIndex -= count;
    } else {  // FIXME refac, more tests (+wear)
        if (fromOffset===0) {
            fromChunk--;
        } else {
            chunks[fromChunk] = chunks[fromChunk].substr(0,fromOffset);
            lengths[fromChunk] = fromChunkIndex;
        }
        var midChunks = tillChunk - fromChunk - 1;
        if (midChunks) { // wipe&#x27;em out
            //for(var c=fromChunk+1; c&#x3c;tillChunk; c++) ;
            chunks.splice(fromChunk+1,midChunks);
            lengths.splice(fromChunk+1,midChunks);
        }
        if (tillChunk&#x3c;chunks.length &#x26;&#x26; tillOffset&#x3e;0) {
            chunks[tillChunk] = chunks[tillChunk].substr(this.match.index);
            lengths[tillChunk] -= this.chunkIndex;
            this.chunkIndex = 0;
        }
    }
    this.index -= count;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator.prototype.insert" id="apidoc.element.swarm.LongSpec.Iterator.prototype.insert">
        function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>insert
        <span class="apidocSignatureSpan">(de)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (de) { // insertBefore

    var insStr = this.encode(de);

    var brokenSeq = this.match &#x26;&#x26; this.match[0].length===1;

    var re = LongSpec.Iterator.reTok;
    var chunks = this.owner.chunks, lengths = this.owner.chunkLengths;
    if (this.chunk==chunks.length) { // end(), append
        if (chunks.length&#x3e;0) {
            var ind = this.chunk - 1;
            chunks[ind] += insStr;
            lengths[ind] ++;
        } else {
            chunks.push(insStr);
            lengths.push(1);
            this.chunk++;
        }
    } else {
        var chunkStr = chunks[this.chunk];
        var preEq = chunkStr.substr(0, this.match.index);
        var postEq = chunkStr.substr(this.match.index);
        if (brokenSeq) {
            var me = this.token();
            this.prevFull = undefined;
            var en = this.encode(me);
            chunks[this.chunk] = preEq + insStr + en + postEq.substr(1);
            re.lastIndex = preEq.length + insStr.length;
            this.match = re.exec(chunks[this.chunk]);
        } else {
            chunks[this.chunk] = preEq + insStr + /**/ postEq;
            this.match.index += insStr.length;
        }
        lengths[this.chunk] ++;
        this.chunkIndex ++;
    }
    this.index ++;
    if (insStr.length&#x3e;1) {
        re.lastIndex = 0;
        this.prevFull = re.exec(insStr);
        this.prevCollapsed = 0;
    } else {
        this.prevCollapsed++;
    }

    // may split chunks
    // may join chunks
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
            break;
        case &#x27;=&#x27;:
            skip(val.length);
        }
    }
    rm &#x26;&#x26; this.remove(rm);
    ins &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">insert</span>(ins);
}
});

Text.diff = function diff(was, is) {
var ret = [];
// prefix suffix the rest is change
var pre = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator.prototype.insertBlock" id="apidoc.element.swarm.LongSpec.Iterator.prototype.insertBlock">
        function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>insertBlock
        <span class="apidocSignatureSpan">(de)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertBlock = function (de) { // insertBefore
    var re = Spec.reQTokExt;
    var toks = de.match(re).reverse(), tok;
    while (tok=toks.pop()) {
        this.insert(tok);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator.prototype.next" id="apidoc.element.swarm.LongSpec.Iterator.prototype.next">
        function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>next
        <span class="apidocSignatureSpan">( )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function ( ) {

    if (this.end()) {return;}

    var re = LongSpec.Iterator.reTok;
    re.lastIndex = this.match ? this.match.index+this.match[0].length : 0;
    var chunk = this.owner.chunks[this.chunk];

    if (chunk.length===re.lastIndex) {
        this.chunk++;
        this.chunkIndex = 0;
        if (this.match &#x26;&#x26; this.match[0].length&#x3e;0) {
            this.prevFull = this.match;
            this.prevCollapsed = 0;
        } else if (this.match) {
            this.prevCollapsed++;
        } else { // empty
            this.prevFull = undefined;
            this.prevCollapsed = 0;
        }
        this.match = null;
        this.index ++;
        if (this.end()) {return;}
    }

    if (this.match[0].length&#x3e;1) {
        this.prevFull = this.match;
        this.prevCollapsed = 0;
    } else {
        this.prevCollapsed++;
    }

    this.match = re.exec(chunk);
    this.index++;
    this.chunkIndex++;

    return this.match[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator.prototype.skip" id="apidoc.element.swarm.LongSpec.Iterator.prototype.skip">
        function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>skip
        <span class="apidocSignatureSpan">( count )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function ( count ) {
    // TODO may implement fast-skip of seq-compressed spans
    var lengths = this.owner.chunkLengths, chunks = this.owner.chunks;
    count = count || 1;
    var left = count;
    var leftInChunk = lengths[this.chunk]-this.chunkIndex;
    if ( leftInChunk &#x3c;= count ) { // skip chunks
        left -= leftInChunk; // skip the current chunk
        var c=this.chunk+1;    // how many extra chunks to skip
        while (left&#x3e;chunks[c] &#x26;&#x26; c&#x3c;chunks.length) {
            left-=chunks[++c];
        }
        this.skip2chunk(c);
    }
    if (this.chunk&#x3c;chunks.length) {
        while (left&#x3e;0) {
            this.next();
            left--;
        }
    }
    return count - left;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator.prototype.skip2chunk" id="apidoc.element.swarm.LongSpec.Iterator.prototype.skip2chunk">
        function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>skip2chunk
        <span class="apidocSignatureSpan">( chunk )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip2chunk = function ( chunk ) {
    var chunks = this.owner.chunks;
    if (chunk===undefined) {chunk=chunks.length;}
    this.index = 0;
    for(var c=0; c&#x3c;chunk; c++) { // TODO perf pick the current value
        this.index += this.owner.chunkLengths[c];
    }
    this.chunkIndex = 0;
    this.chunk = chunk;
    var re = LongSpec.Iterator.reTok;
    if ( chunk &#x3c; chunks.length ) {
        re.lastIndex = 0;
        this.match = re.exec(chunks[this.chunk]);
    } else {
        this.match = null;
    }
    if (chunk&#x3e;0) { // (1) chunks must not be empty; (2) a chunk starts with a full token
        var prev = chunks[chunk-1];
        var j = 0;
        while (Spec.quants.indexOf(prev.charAt(prev.length-1-j)) !== -1) { j++; }
        this.prevCollapsed = j;
        var k = 0;
        while (Spec.quants.indexOf(prev.charAt(prev.length-1-j-k))===-1) { k++; }
        re.lastIndex = prev.length-1-j-k;
        this.prevFull = re.exec(prev);
    } else {
        this.prevFull = undefined;
        this.prevCollapsed = 0;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.Iterator.prototype.token" id="apidoc.element.swarm.LongSpec.Iterator.prototype.token">
        function <span class="apidocSignatureSpan">swarm.LongSpec.Iterator.prototype.</span>token
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token = function () {
    return this.decode();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    state: function (spec, text, src) {
        console.log(&#x27;what?&#x27;);
    }
},
ops: {
    insert: function (spec, ins, src) {
        var w1 = [], w4 = [];
        var vt = spec.<span class="apidocCodeKeywordSpan">token</span>(&#x27;!&#x27;), v = vt.bare;
        var ts = v.substr(0, 5), seq = v.substr(5) || &#x27;00&#x27;;
        var seqi = Spec.base2int(seq);
        for (var i = 0; i &#x3c; this.weave.length; i++) {
            var id = this.ids[i];
            w1.push(this.weave.charAt(i));
            w4.push(id);
            if (id in ins) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.LongSpec.prototype" id="apidoc.module.swarm.LongSpec.prototype">module swarm.LongSpec.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.LongSpec.prototype.add" id="apidoc.element.swarm.LongSpec.prototype.add">
        function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>add
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ls_add(spec) {
    var pos = this.end();
    pos.insertBlock(spec);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.prototype.allocateCode" id="apidoc.element.swarm.LongSpec.prototype.allocateCode">
        function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>allocateCode
        <span class="apidocSignatureSpan">(tok)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocateCode = function (tok) {
    var quant = tok.charAt(0);
    //if (Spec.quants.indexOf(quant)===-1) {throw new Error(&#x27;invalid token&#x27;);}
    var en, cb = this.codeBook, lc = cb.lastCodes;
    if (lc[quant]&#x3c;&#x27;z&#x27;.charCodeAt(0)) { // pick a nice letter
        for(var i=1; !en &#x26;&#x26; i&#x3c;tok.length; i++) {
            var x = tok.charAt(i), e = quant+x;
            if (!cb.de[e]) {  en = e;  }
        }
    }
    while (!en &#x26;&#x26; lc[quant]&#x3c;0x802f) {
        var y = String.fromCharCode(lc[quant]++);
        var mayUse = quant + y;
        if ( ! cb.en[mayUse] ) {  en = mayUse;  }
    }
    if (!en) {
        if (tok.length&#x3c;=3) {
            throw new Error(&#x22;out of codes&#x22;);
        }
        en = tok;
    }
    cb.en[tok] = en;
    cb.de[en] = tok;
    return en;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.prototype.append" id="apidoc.element.swarm.LongSpec.prototype.append">
        function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>append
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ls_add(spec) {
    var pos = this.end();
    pos.insertBlock(spec);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.prototype.charLength" id="apidoc.element.swarm.LongSpec.prototype.charLength">
        function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>charLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">charLength = function () {
    var len = 0;
    for(var i=0; i&#x3c;this.chunks.length; i++) {
        len += this.chunks[i].length;
    }
    return len;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.prototype.end" id="apidoc.element.swarm.LongSpec.prototype.end">
        function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
    var e = new LongSpec.Iterator(this);
    e.skip2chunk(this.chunks.length);
    return e;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.prototype.find" id="apidoc.element.swarm.LongSpec.prototype.find">
        function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>find
        <span class="apidocSignatureSpan">(tok, startIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (tok, startIndex) {
    //var en = this.encode(tok).toString(); // don&#x27;t split on +
    var i = this.iterator(startIndex);
    while (!i.end()) {
        if (i.token()===tok) {
            return i;
        }
        i.next();
    }
    return i;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.prototype.indexOf" id="apidoc.element.swarm.LongSpec.prototype.indexOf">
        function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(tok, startAt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (tok, startAt) {
    var iter = this.find(tok,startAt);
    return iter.end() ? -1 : iter.index;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            openTag = &#x27;h&#x27;+format.head;
        else
            openTag = &#x27;p&#x27;;
        html.push(&#x27;&#x3c;&#x27;,openTag,&#x27;&#x3e;&#x27;); // TODO pid
        frg = frg.substr(1);
    }
    //find next struct (lookahead; had \n =&#x3e; check for \t)
    var n = frg.<span class="apidocCodeKeywordSpan">indexOf</span>(&#x27;\n&#x27;,1);
    if (n!==-1) { // repair
        rtf.push(frg.substr(n));
        frg = frg.substr(0,n);
    }
    var atts = meta2attstr(format);
    html.push(&#x27;&#x3c;span&#x27;,atts,&#x27;&#x3e;&#x27;,htmlesc(frg),&#x27;&#x3c;/span&#x3e;&#x27;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.prototype.insert" id="apidoc.element.swarm.LongSpec.prototype.insert">
        function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>insert
        <span class="apidocSignatureSpan">(tok, i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (tok, i) {
    var iter = i.constructor===LongSpec.Iterator ? i : this.iterator(i);
    iter.insertBlock(tok);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
            break;
        case &#x27;=&#x27;:
            skip(val.length);
        }
    }
    rm &#x26;&#x26; this.remove(rm);
    ins &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">insert</span>(ins);
}
});

Text.diff = function diff(was, is) {
var ret = [];
// prefix suffix the rest is change
var pre = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.prototype.iterator" id="apidoc.element.swarm.LongSpec.prototype.iterator">
        function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>iterator
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">iterator = function (index) {
    return new LongSpec.Iterator(this,index);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.prototype.length" id="apidoc.element.swarm.LongSpec.prototype.length">
        function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">length = function () { // TODO .length ?
    var len = 0;
    for(var i=0; i&#x3c;this.chunks.length; i++) {
        len += this.chunkLengths[i];
    }
    return len;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.prototype.toString" id="apidoc.element.swarm.LongSpec.prototype.toString">
        function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    var ret = [];
    for(var i = this.iterator(); !i.end(); i.next()){
        ret.push(i.decode());
    }
    return ret.join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

AsyncLoopbackConnection.prototype.receive = function (string) {
this.lstn.data &#x26;&#x26; this.lstn.data(string);
};

AsyncLoopbackConnection.prototype.write = function (obj) {
var self = this;
obj &#x26;&#x26; self.queue.push(obj.<span class="apidocCodeKeywordSpan">toString</span>());
setTimeout(function () {
    var pair = self.pair();
    if (!pair) {
        return;
    }
    while (self.queue.length) {
        pair.receive(self.queue.shift());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.LongSpec.prototype.tokenAt" id="apidoc.element.swarm.LongSpec.prototype.tokenAt">
        function <span class="apidocSignatureSpan">swarm.LongSpec.prototype.</span>tokenAt
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokenAt = function (pos) {
    var iter = this.iterator(pos);
    return iter.token();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.MinutePreciseClock" id="apidoc.module.swarm.MinutePreciseClock">module swarm.MinutePreciseClock</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.MinutePreciseClock.MinutePreciseClock" id="apidoc.element.swarm.MinutePreciseClock.MinutePreciseClock">
        function <span class="apidocSignatureSpan">swarm.</span>MinutePreciseClock
        <span class="apidocSignatureSpan">(processId, timeOffsetMs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MinutePreciseClock = function (processId, timeOffsetMs) {
    if (!Spec.reTok.test(processId)) {
        throw new Error(&#x27;invalid process id: &#x27;+processId);
    }
    this.id = processId;
    // sometimes we assume our local clock has some offset
    this.clockOffsetMs = 0;
    this.lastIssuedTimestamp = &#x27;&#x27;;
    // although we try hard to use wall clock time, we must
    // obey Lamport logical clock rules, in particular our
    // timestamps must be greater than any other timestamps
    // previously seen
    this.lastTimeSeen = 0;
    this.lastSeqSeen = 0;
    if (timeOffsetMs) {
        this.clockOffsetMs = timeOffsetMs;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.MinutePreciseClock.prototype" id="apidoc.module.swarm.MinutePreciseClock.prototype">module swarm.MinutePreciseClock.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.MinutePreciseClock.prototype.adjustTime" id="apidoc.element.swarm.MinutePreciseClock.prototype.adjustTime">
        function <span class="apidocSignatureSpan">swarm.MinutePreciseClock.prototype.</span>adjustTime
        <span class="apidocSignatureSpan">(trueMs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">adjustTime = function (trueMs) {
    // TODO use min historical offset
    var localTime = new Date().getTime();
    var clockOffsetMs = trueMs - localTime;
    this.clockOffsetMs = clockOffsetMs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.MinutePreciseClock.prototype.checkTimestamp" id="apidoc.element.swarm.MinutePreciseClock.prototype.checkTimestamp">
        function <span class="apidocSignatureSpan">swarm.MinutePreciseClock.prototype.</span>checkTimestamp
        <span class="apidocSignatureSpan">(ts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function see(ts) {
    if (ts&#x3c;this.lastIssuedTimestamp) { return true; }
    var parsed = this.parseTimestamp(ts);
    if (parsed.time&#x3c;this.lastTimeSeen) { return true; }
    var min = this.minutes();
    if (parsed.time&#x3e;min+1) { return false; } // bad clocks somewhere
    this.lastTimeSeen = parsed.time;
    this.lastSeqSeen = parsed.seq;
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                        seqi = 1; // FIXME repeat ids, double insert
                    }
                }
            }
        }
    }
    if (genTs) {
        this._host.clock.<span class="apidocCodeKeywordSpan">checkTimestamp</span>(genTs);
    }
    this.weave = w1.join(&#x27;&#x27;);
    this.ids = w4;
    this.rebuild();
},
remove: function (spec, rm, src) {
    var w1 = [], w4 = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.MinutePreciseClock.prototype.issueTimestamp" id="apidoc.element.swarm.MinutePreciseClock.prototype.issueTimestamp">
        function <span class="apidocSignatureSpan">swarm.MinutePreciseClock.prototype.</span>issueTimestamp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">issueTimestamp = function () {
    var time = this.minutes();
    if (this.lastTimeSeen&#x3e;time) { time = this.lastTimeSeen; }
    if (time&#x3e;this.lastTimeSeen) { this.lastSeqSeen = -1; }
    this.lastTimeSeen = time;
    var seq = ++this.lastSeqSeen;
    if (seq&#x3e;=(1&#x3c;&#x3c;18)) {throw new Error(&#x27;max event freq is 4000Hz&#x27;);}

    var baseTime = Spec.int2base(time, 4), baseSeq;
    if (seq&#x3c;64) {
        baseSeq = Spec.int2base(seq, 1);
    } else {
        baseSeq = Spec.int2base(seq, 3);
    }

    this.lastIssuedTimestamp = baseTime + baseSeq + &#x27;+&#x27; + this.id;
    return this.lastIssuedTimestamp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.MinutePreciseClock.prototype.minutes" id="apidoc.element.swarm.MinutePreciseClock.prototype.minutes">
        function <span class="apidocSignatureSpan">swarm.MinutePreciseClock.prototype.</span>minutes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minutes = function () {
    var millis = new Date().getTime();
    millis -= MinutePreciseClock.EPOCH;
    millis += this.clockOffsetMs;
    return (millis/60000) | 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var millis = new Date().getTime();
millis -= MinutePreciseClock.EPOCH;
millis += this.clockOffsetMs;
return (millis/60000) | 0;
};

MinutePreciseClock.prototype.issueTimestamp = function () {
var time = this.<span class="apidocCodeKeywordSpan">minutes</span>();
if (this.lastTimeSeen&#x3e;time) { time = this.lastTimeSeen; }
if (time&#x3e;this.lastTimeSeen) { this.lastSeqSeen = -1; }
this.lastTimeSeen = time;
var seq = ++this.lastSeqSeen;
if (seq&#x3e;=(1&#x3c;&#x3c;18)) {throw new Error(&#x27;max event freq is 4000Hz&#x27;);}

var baseTime = Spec.int2base(time, 4), baseSeq;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.MinutePreciseClock.prototype.parseTimestamp" id="apidoc.element.swarm.MinutePreciseClock.prototype.parseTimestamp">
        function <span class="apidocSignatureSpan">swarm.MinutePreciseClock.prototype.</span>parseTimestamp
        <span class="apidocSignatureSpan">(ts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(ts) {
    var m = ts.match(Spec.reTokExt);
    if (!m) {throw new Error(&#x27;malformed timestamp: &#x27;+ts);}
    var timeseq=m[1]; //, process=m[2];
    var time = timeseq.substr(0,4), seq = timeseq.substr(4);
    if (seq.length!==1 &#x26;&#x26; seq.length!==3) {
        throw new Error(&#x27;malformed timestamp value: &#x27;+timeseq);
    }
    return {
        time: Spec.base2int(time),
        seq: Spec.base2int(seq)
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        seq: Spec.base2int(m[1]),
        process: m[2]
    };
};

/** Lamport partial order  imperfect semi-logical*/
LamportClock.prototype.checkTimestamp = function see (ts) {
    var parsed = this.<span class="apidocCodeKeywordSpan">parseTimestamp</span>(ts);
    if (parsed.seq &#x3e;= this.seq) {
        this.seq = parsed.seq + 1;
    }
    return true;
};

LamportClock.prototype.time2date = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.MinutePreciseClock.prototype.time2date" id="apidoc.element.swarm.MinutePreciseClock.prototype.time2date">
        function <span class="apidocSignatureSpan">swarm.MinutePreciseClock.prototype.</span>time2date
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time2date = function () {
    // parse etc
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Model" id="apidoc.module.swarm.Model">module swarm.Model</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Model.Model" id="apidoc.element.swarm.Model.Model">
        function <span class="apidocSignatureSpan">swarm.</span>Model
        <span class="apidocSignatureSpan">(idOrState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Model(idOrState) {
    var ret = Model._super.apply(this, arguments);
    /// TODO: combine with state push, make clean
    if (ret === this &#x26;&#x26; idOrState &#x26;&#x26; idOrState.constructor !== String &#x26;&#x26; !Spec.is(idOrState)) {
        this.deliver(this.spec().add(this._id, &#x27;!&#x27;).add(&#x27;.set&#x27;), idOrState);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model._super" id="apidoc.element.swarm.Model._super">
        function <span class="apidocSignatureSpan">swarm.Model.</span>_super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Syncable() {
    // listeners represented as objects that have deliver() method
    this._lstn = [&#x27;,&#x27;]; // we unshift() uplink listeners and push() downlinks
    // ...so _lstn is like [server1, server2, storage, &#x27;,&#x27;, view, listener]
    // The most correct way to specify a version is the version vector,
    // but that one may consume more space than the data itself in some cases.
    // Hence, _version is not a fully specified version vector (see version()
    // instead). _version is essentially is the greatest operation timestamp
    // (Lamport-like, i.e. &#x22;time+source&#x22;), sometimes amended with additional
    // timestamps. Its main features:
    // (1) changes once the object&#x27;s state changes
    // (2) does it monotonically (in the alphanum order sense)
    this._version = &#x27;&#x27;;
    // make sense of arguments
    var args = Array.prototype.slice.call(arguments);
    this._host = (args.length &#x26;&#x26; args[args.length - 1]._type === &#x27;Host&#x27;) ?
            args.pop() : env.localhost;
    if (Spec.is(args[0])) {
        this._id = new Spec(args.shift()).id() || this._host.time();
    } else if (typeof(args[0]) === &#x27;string&#x27;) {
        this._id = args.shift(); // TODO format
    } else {
        this._id = this._host.time();
        this._version = &#x27;!0&#x27;; // may apply state in the constructor, see Model
    }
    //var state = args.length ? args.pop() : (fresh?{}:undefined);
    // register with the host
    var doubl = this._host.register(this);
    if (doubl !== this) { return doubl; }
    // locally created objects get state immediately
    // (while external-id objects need to query uplinks)
<span class="apidocCodeCommentSpan">    /*if (fresh &#x26;&#x26; state) {
     state._version = &#x27;!&#x27;+this._id;
     var pspec = this.spec().add(state._version).add(&#x27;.init&#x27;);
     this.deliver(pspec,state,this._host);
     }*/
</span>    this.reset();
    // find uplinks, subscribe
    this.checkUplink();
    // TODO inplement state push
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.addReaction" id="apidoc.element.swarm.Model.addReaction">
        function <span class="apidocSignatureSpan">swarm.Model.</span>addReaction
        <span class="apidocSignatureSpan">(methodOrField, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addReaction = function (methodOrField, fn) {
    var proto = this.prototype;
    if (typeof (proto[methodOrField]) === &#x27;function&#x27;) { // it is a field name
        return Syncable.addReaction.call(this, methodOrField, fn);
    } else {
        var wrapper = function (spec, val) {
            if (methodOrField in val) {
                fn.apply(this, arguments);
            }
        };
        wrapper._rwrap = true;
        return Syncable.addReaction.call(this, &#x27;set&#x27;, wrapper);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.extend" id="apidoc.element.swarm.Model.extend">
        function <span class="apidocSignatureSpan">swarm.Model.</span>extend
        <span class="apidocSignatureSpan">(fn, own)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (fn, own) {
    var parent = this, fnid;
    if (fn.constructor !== Function) {
        var id = fn.toString();
        fn = function SomeSyncable() {
            return parent.apply(this, arguments);
        };
        fnid = id; // if only it worked
    } else { // please call Syncable.constructor.apply(this,args) in your constructor
        fnid = fnname(fn);
    }

    // inheritance trick from backbone.js
    var SyncProto = function () {
        this.constructor = fn;
        this._neutrals = {};
        this._ops = {};
        this._reactions = {};

        var event,
            name;
        if (parent._pt) {
            //copy _neutrals &#x26; _ops from parent
            for (event in parent._pt._neutrals) {
                this._neutrals[event] = parent._pt._neutrals[event];
            }
            for (event in parent._pt._ops) {
                this._ops[event] = parent._pt._ops[event];
            }
        }

        // &#x22;Methods&#x22; are serialized, logged and delivered to replicas
        for (name in own.ops || {}) {
            if (Syncable.reMethodName.test(name)) {
                this._ops[name] = own.ops[name];
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid op name:&#x27;,name);
            }
        }

        // &#x22;Neutrals&#x22; don&#x27;t change the state
        for (name in own.neutrals || {}) {
            if (Syncable.reMethodName.test(name)) {
                this._neutrals[name] = own.neutrals[name];
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid neutral op name:&#x27;,name);
            }
        }

        // &#x22;Remotes&#x22; are serialized and sent upstream (like RPC calls)
        for (name in own.remotes || {}) {
            if (Syncable.reMethodName.test(name)) {
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid rpc name:&#x27;,name);
            }
        }

        // add mixins
        (own.mixins || []).forEach(function (mixin) {
            for (var name in mixin) {
                this[name] = mixin[name];
            }
        }, this);

        // add other members
        for (name in own) {
            if (Syncable.reMethodName.test(name)) {
                var memberType = own[name].constructor;
                if (memberType === Function) { // non-op method
                    // these must change state ONLY by invoking ops
                    this[name] = own[name];
                } else if (memberType===String || memberType===Number) {
                    this[name] = own[name]; // some static constant, OK
                } else if (name in Syncable.memberClasses) {
                    // see above
                    continue;
                } else {
                    console.warn(&#x27;invalid member:&#x27;,name,memberType);
                }
            } else {
                console.warn(&#x27;invalid member name:&#x27;,name);
            }
        }

        // add reactions
        for (name in own.reactions || {}) {
            var reaction = own.reactions[name];
            if (!reaction) { continue; }

            switch (typeof reaction) {
            case &#x27;function&#x27;:
                // handler-function
                this._reactions[name] = [reaction];
                break;
            case &#x27;string&#x27;:
                // handler-method name
                this._reactions[name] = [this[name]];
                break;
            default:
                if (reaction.constructor === Array) {
                    // array of handlers
                    this._reactions[name] = reaction.map(function (item) {
                        switch (typeof item) {
                        case &#x27;function&#x27;:
                            return item;
                        case &#x27;string&#x27;:
                            return this[item];
                        default:
                            throw new Error(&#x27;unexpected reaction type&#x27;);
                        }
                    }, this);
                } else {
                    throw new Error(&#x27;unex ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
these demos are normally online at http://ppyr.us and http://ppyr.us:8001/demo3/index.html respectively.

### Creating your first simple synchronized type

```js
var Swarm = require(&#x27;swarm&#x27;);

var Mouse = Swarm.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;Mouse&#x27;, {
    defaults: {
        name: &#x27;Mickey&#x27;,
        x: 0,
        y: 0
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.removeReaction" id="apidoc.element.swarm.Model.removeReaction">
        function <span class="apidocSignatureSpan">swarm.Model.</span>removeReaction
        <span class="apidocSignatureSpan">(handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeReaction = function (handle) {
    var op = handle.op,
        fn = handle.fn,
        list = this.prototype._reactions[op],
        i = list.indexOf(fn);
    if (i === -1) {
        throw new Error(&#x27;reaction unknown&#x27;);
    }
    list[i] = undefined; // such a peculiar pattern not to mess up out-of-callback removal
    while (list.length &#x26;&#x26; !list[list.length - 1]) {
        list.pop();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Model.prototype" id="apidoc.module.swarm.Model.prototype">module swarm.Model.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Model.prototype.callReactions" id="apidoc.element.swarm.Model.prototype.callReactions">
        function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>callReactions
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callReactions = function (spec, value, src) {
    var superReactions = syncProto._super.callReactions;
    if (&#x27;function&#x27; === typeof superReactions) {
        superReactions.call(this, spec, value, src);
    }
    var r = syncProto._reactions[spec.op()];
    if (r) {
        r.constructor !== Array &#x26;&#x26; (r = [r]);
        for (var i = 0; i &#x3c; r.length; i++) {
            r[i] &#x26;&#x26; r[i].call(this, spec, value, src);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype.constructor" id="apidoc.element.swarm.Model.prototype.constructor">
        function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>constructor
        <span class="apidocSignatureSpan">(idOrState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Model(idOrState) {
    var ret = Model._super.apply(this, arguments);
    /// TODO: combine with state push, make clean
    if (ret === this &#x26;&#x26; idOrState &#x26;&#x26; idOrState.constructor !== String &#x26;&#x26; !Spec.is(idOrState)) {
        this.deliver(this.spec().add(this._id, &#x27;!&#x27;).add(&#x27;.set&#x27;), idOrState);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype.distillLog" id="apidoc.element.swarm.Model.prototype.distillLog">
        function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>distillLog
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distillLog = function () {
    // explain
    var sets = [],
        cumul = {},
        heads = {},
        spec;
    for (var s in this._oplog) {
        spec = new Spec(s);
        //if (spec.op() === &#x27;set&#x27;) {
        sets.push(spec);
        //}
    }
    sets.sort();
    for (var i = sets.length - 1; i &#x3e;= 0; i--) {
        spec = sets[i];
        var val = this._oplog[spec],
            notempty = false;
        for (var field in val) {
            if (field in cumul) {
                delete val[field];
            } else {
                notempty = cumul[field] = val[field]; //store last value of the field
            }
        }
        var source = spec.source();
        notempty || (heads[source] &#x26;&#x26; delete this._oplog[spec]);
        heads[source] = true;
    }
    return cumul;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype.fill" id="apidoc.element.swarm.Model.prototype.fill">
        function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>fill
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fill = function (key) { // TODO goes to Model to support references
    if (!this.hasOwnProperty(key)) {
        throw new Error(&#x27;no such entry&#x27;);
    }

    //if (!Spec.is(this[key]))
    //    throw new Error(&#x27;not a specifier&#x27;);
    var spec = new Spec(this[key]).filter(&#x27;/#&#x27;);
    if (spec.pattern() !== &#x27;/#&#x27;) {
        throw new Error(&#x27;incomplete spec&#x27;);
    }

    this[key] = this._host.get(spec);
<span class="apidocCodeCommentSpan">    /* TODO new this.refType(id) || new Swarm.types[type](id);
     on(&#x27;init&#x27;, function(){
     self.emit(&#x27;fill&#x27;,key,this)
     self.emit(&#x27;full&#x27;,key,this)
     });*/
</span>}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype.off" id="apidoc.element.swarm.Model.prototype.off">
        function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>off
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Unsubscribe from collections entries&#x27; events
 * @param {function(*)} callback
 * @this Set|Vector
 */
offObjectEvent: function (callback) {
    this._proxy.<span class="apidocCodeKeywordSpan">off</span>(callback);
},

/**
 * Waits for collection to receive state from cache or uplink and then invokes passed callback
 *
 * @param {function()} callback
 * @this Set|Vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype.on" id="apidoc.element.swarm.Model.prototype.on">
        function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype.packState" id="apidoc.element.swarm.Model.prototype.packState">
        function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>packState
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">packState = function (state) {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype.save" id="apidoc.element.swarm.Model.prototype.save">
        function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>save
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">save = function () {
    var cumul = this.distillLog(),
        changes = {},
        pojo = this.pojo(),
        field;
    for (field in pojo) {
        if (this[field] !== cumul[field]) {// TODO nesteds
            changes[field] = this[field];
        }
    }
    for (field in cumul) {
        if (!(field in pojo)) {
            changes[field] = null; // JSON has no undefined
        }
    }
    this.set(changes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype.set" id="apidoc.element.swarm.Model.prototype.set">
        function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// 3.a. create an object
var someMouse = new Mouse();
// OR swarmHost.get(&#x27;/Mouse&#x27;);
// OR new Mouse({x:1, y:2});

// 4.a. a locally created object may be touched immediately
someMouse.<span class="apidocCodeKeywordSpan">set</span>({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.on(&#x27;init&#x27;, function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype.unpackState" id="apidoc.element.swarm.Model.prototype.unpackState">
        function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>unpackState
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unpackState = function (state) {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype.validate" id="apidoc.element.swarm.Model.prototype.validate">
        function <span class="apidocSignatureSpan">swarm.Model.prototype.</span>validate
        <span class="apidocSignatureSpan">(spec, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (spec, val) {
    if (spec.op() !== &#x27;set&#x27;) {
        return &#x27;&#x27;;
    } // no idea
    for (var key in val) {
        if (!Syncable.reFieldName.test(key)) {
            return &#x27;bad field name&#x27;;
        }
    }
    return &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Model.prototype._neutrals" id="apidoc.module.swarm.Model.prototype._neutrals">module swarm.Model.prototype._neutrals</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Model.prototype._neutrals.error" id="apidoc.element.swarm.Model.prototype._neutrals.error">
        function <span class="apidocSignatureSpan">swarm.Model.prototype._neutrals.</span>error
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (spec, val, repl) {
    console.error(&#x27;something failed:&#x27;, spec, val, &#x27;@&#x27;, (repl &#x26;&#x26; repl._id));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.buf = buf; //will wait for &#x22;open&#x22;
    }
    ws.on(&#x27;close&#x27;, function () { ln.close &#x26;&#x26; ln.close(); });
    ws.on(&#x27;data&#x27;, function (msg) {
        try {
            ln.data &#x26;&#x26; ln.data(msg);
        } catch (ex) {
            console.<span class="apidocCodeKeywordSpan">error</span>(&#x27;message processing fails&#x27;, ex);
            ln.error &#x26;&#x26; ln.error(ex.message);
        }
    });
}

module.exports = SockJSStream;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype._neutrals.off" id="apidoc.element.swarm.Model.prototype._neutrals.off">
        function <span class="apidocSignatureSpan">swarm.Model.prototype._neutrals.</span>off
        <span class="apidocSignatureSpan">(spec, base, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (spec, base, repl) {
    var ls = this._lstn;
    if (typeof(repl) === &#x27;function&#x27;) { // TODO ugly
        for (var i = 0; i &#x3c; ls.length; i++) {
            if (ls[i] &#x26;&#x26; ls[i].fn === repl &#x26;&#x26; ls[i].key === base) {
                repl = ls[i];
                break;
            }
        }
    }
    Syncable._pt._neutrals.off.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Unsubscribe from collections entries&#x27; events
 * @param {function(*)} callback
 * @this Set|Vector
 */
offObjectEvent: function (callback) {
    this._proxy.<span class="apidocCodeKeywordSpan">off</span>(callback);
},

/**
 * Waits for collection to receive state from cache or uplink and then invokes passed callback
 *
 * @param {function()} callback
 * @this Set|Vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype._neutrals.on" id="apidoc.element.swarm.Model.prototype._neutrals.on">
        function <span class="apidocSignatureSpan">swarm.Model.prototype._neutrals.</span>on
        <span class="apidocSignatureSpan">(spec, base, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (spec, base, repl) {
    //  support the model.on(&#x27;field&#x27;,callback_fn) pattern
    if (typeof(repl) === &#x27;function&#x27; &#x26;&#x26;
            typeof(base) === &#x27;string&#x27; &#x26;&#x26;
            (base in this.constructor.defaults)) {
        var stub = {
            fn: repl,
            key: base,
            self: this,
            _op: &#x27;set&#x27;,
            deliver: function (spec, val, src) {
                if (this.key in val) {
                    this.fn.call(this.self, spec, val, src);
                }
            }
        };
        repl = stub;
        base = &#x27;&#x27;;
    }
    // this will delay response if we have no state yet
    Syncable._pt._neutrals.on.call(this, spec, base, repl);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype._neutrals.reoff" id="apidoc.element.swarm.Model.prototype._neutrals.reoff">
        function <span class="apidocSignatureSpan">swarm.Model.prototype._neutrals.</span>reoff
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reoff = function (spec, val, repl) {
    var idx = this.getListenerIndex(repl); //TODO ??? uplinks_only?
    if (idx &#x3e; -1) {
        this._lstn.splice(idx, 1);
    }
    if (this._id) {
        this.checkUplink();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype._neutrals.reon" id="apidoc.element.swarm.Model.prototype._neutrals.reon">
        function <span class="apidocSignatureSpan">swarm.Model.prototype._neutrals.</span>reon
        <span class="apidocSignatureSpan">(spec, filter, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reon = function (spec, filter, repl) {
    if (filter) {  // a diff is requested
        var base = Spec.as(filter).tok(&#x27;!&#x27;);
        var diff = this.diff(base);
        if (diff) {
            repl.deliver(spec.set(&#x27;.init&#x27;), diff, this);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Model.prototype._ops" id="apidoc.module.swarm.Model.prototype._ops">module swarm.Model.prototype._ops</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Model.prototype._ops.init" id="apidoc.element.swarm.Model.prototype._ops.init">
        function <span class="apidocSignatureSpan">swarm.Model.prototype._ops.</span>init
        <span class="apidocSignatureSpan">(spec, state, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (spec, state, src) {

    var tail = {}, // ops to be applied on top of the received state
        typeid = spec.filter(&#x27;/#&#x27;),
        lstn = this._lstn,
        a_spec;
    this._lstn = []; // prevent events from being fired

    if (state._version/* &#x26;&#x26; state._version !== &#x27;!0&#x27;*/) {
        // local changes may need to be merged into the received state
        if (this._oplog) {
            for (a_spec in this._oplog) {
                tail[a_spec] = this._oplog[a_spec];
            }
            this._oplog = {};
        }
        this._vector &#x26;&#x26; (this._vector = undefined);
        // zero everything
        for (var key in this) {
            if (this.hasOwnProperty(key) &#x26;&#x26; key.charAt(0) !== &#x27;_&#x27;) {
                this[key] = undefined;
            }
        }
        // set default values
        this.reset();

        this.apply(state);
        this._version = state._version;

        state._oplog &#x26;&#x26; (this._oplog = state._oplog); // FIXME copy
        state._vector &#x26;&#x26; (this._vector = state._vector);
    }
    // add the received tail to the local one
    if (state._tail) {
        for (a_spec in state._tail) {
            tail[a_spec] = state._tail[a_spec];
        }
    }
    // appply the combined tail to the new state
    var specs = [];
    for (a_spec in tail) {
        specs.push(a_spec);
    }
    specs.sort().reverse();
    // there will be some replays, but those will be ignored
    while (a_spec = specs.pop()) {
        this.deliver(typeid.add(a_spec), tail[a_spec], this);
    }

    this._lstn = lstn;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Model.prototype._ops.set" id="apidoc.element.swarm.Model.prototype._ops.set">
        function <span class="apidocSignatureSpan">swarm.Model.prototype._ops.</span>set
        <span class="apidocSignatureSpan">(spec, value, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (spec, value, repl) {
    var version = spec.version(),
        vermet = spec.filter(&#x27;!.&#x27;).toString();
    if (version &#x3c; this._version.substr(1)) {
        this._oplog[vermet] = value;
        this.distillLog(); // may amend the value
        value = this._oplog[vermet];
    }
    value &#x26;&#x26; this.apply(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// 3.a. create an object
var someMouse = new Mouse();
// OR swarmHost.get(&#x27;/Mouse&#x27;);
// OR new Mouse({x:1, y:2});

// 4.a. a locally created object may be touched immediately
someMouse.<span class="apidocCodeKeywordSpan">set</span>({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.on(&#x27;init&#x27;, function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Pipe" id="apidoc.module.swarm.Pipe">module swarm.Pipe</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Pipe.Pipe" id="apidoc.element.swarm.Pipe.Pipe">
        function <span class="apidocSignatureSpan">swarm.</span>Pipe
        <span class="apidocSignatureSpan">(host, stream, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pipe(host, stream, opts) {
    var self = this;
    self.opts = opts || {};
    if (!stream || !host) {
        throw new Error(&#x27;new Pipe(host,stream[,opts])&#x27;);
    }
    self._id = null;
    self.host = host;
    // uplink/downlink state flag;
    //  true: this side initiated handshake &#x3e;.on &#x3c;.reon
    //  false: this side received handshake &#x3c;.on &#x3e;.reon
    //  undefined: nothing sent/received OR had a .reoff
    this.isOnSent = undefined;
    this.reconnectDelay = self.opts.reconnectDelay || 1000;
    self.serializer = self.opts.serializer || JSON;
    self.katimer = null;
    self.send_timer = null;
    self.lastSendTS = self.lastRecvTS = self.time();
    self.bundle = {};
    // don&#x27;t send immediately, delay to bundle more messages
    self.delay = self.opts.delay || -1;
    //self.reconnectDelay = self.opts.reconnectDelay || 1000;
    if (typeof(stream.write) !== &#x27;function&#x27;) { // TODO nicer
        var url = stream.toString();
        var m = url.match(/(\w+):.*/);
        if (!m) {
            throw new Error(&#x27;invalid url &#x27; + url);
        }
        var proto = m[1].toLowerCase();
        var fn = env.streams[proto];
        if (!fn) {
            throw new Error(&#x27;protocol not supported: &#x27; + proto);
        }
        self.url = url;
        stream = new fn(url);
    }
    self.connect(stream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Pipe.prototype" id="apidoc.module.swarm.Pipe.prototype">module swarm.Pipe.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Pipe.prototype.close" id="apidoc.element.swarm.Pipe.prototype.close">
        function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>close
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pc(error) {
    env.log(dotClose, error ? &#x27;error: &#x27; + error : &#x27;correct&#x27;, this, this.host);
    if (error &#x26;&#x26; this.host &#x26;&#x26; this.url) {
        var uplink_uri = this.url,
            host = this.host,
            pipe_opts = this.opts;
        //reconnect delay for next disconnection
        pipe_opts.reconnectDelay = Math.min(30000, this.reconnectDelay &#x3c;&#x3c; 1);
        // schedule a retry
        setTimeout(function () {
            host.connect(uplink_uri, pipe_opts);
        }, this.reconnectDelay);

        this.url = null; //to prevent second reconnection timer
    }
    if (this.host) {
        if (this.isOnSent !== undefined &#x26;&#x26; this._id) {
            // emulate normal off
            var offspec = this.host.newEventSpec(this.isOnSent ? &#x27;off&#x27; : &#x27;reoff&#x27;);
            this.host.deliver(offspec, &#x27;&#x27;, this);
        }
        this.host = null; // can&#x27;t pass any more messages
    }
    if (this.katimer) {
        clearInterval(this.katimer);
        this.katimer = null;
    }
    if (this.stream) {
        try {
            this.stream.close();
        } catch (ex) {}
        this.stream = null;
    }
    this._id = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }, 1);
};

AsyncLoopbackConnection.prototype.close = function () {
    delete AsyncLoopbackConnection.pipes[this.id];
    var pair = this.pair();
    pair &#x26;&#x26; pair.<span class="apidocCodeKeywordSpan">close</span>();
    this.lstn.close &#x26;&#x26; this.lstn.close();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Pipe.prototype.connect" id="apidoc.element.swarm.Pipe.prototype.connect">
        function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>connect
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pc(stream) {
    var self = this;
    self.stream = stream;

    self.stream.on(&#x27;data&#x27;, function onMsg(data) {
        data = data.toString();
        env.trace &#x26;&#x26; env.log(dotIn, data, this, this.host);
        self.lastRecvTS = self.time();
        var json = self.serializer.parse(data);
        try {
            self._id ? self.parseBundle(json) : self.parseHandshake(json);
        } catch (ex) {
            console.error(&#x27;error processing message&#x27;, ex, ex.stack);
            //this.deliver(this.host.newEventSpec(&#x27;error&#x27;), ex.message);
            this.close();
        }
        self.reconnectDelay = self.opts.reconnectDelay || 1000;
    });

    self.stream.on(&#x27;close&#x27;, function onConnectionClosed(reason) {
        self.stream = null; // needs no further attention
        self.close(&#x22;stream closed&#x22;);
    });

    self.stream.on(&#x27;error&#x27;, function (err) {
        self.close(&#x27;stream error event: &#x27; + err);
    });

    self.katimer = setInterval(self.keepAliveFn.bind(self), (Pipe.TIMEOUT / 4 + Math.random() * 100) | 0);

    // NOPE client only finally, initiate handshake
    // self.host.connect(self);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Using the model on the client (app.js)

```js
// 1. create local Host
var swarmHost = new Swarm.Host(&#x27;unique_client_id&#x27;);

// 2. connect to your server
swarmHost.<span class="apidocCodeKeywordSpan">connect</span>(&#x27;ws://localhost:8000/&#x27;);

// 3.a. create an object
var someMouse = new Mouse();
// OR swarmHost.get(&#x27;/Mouse&#x27;);
// OR new Mouse({x:1, y:2});

// 4.a. a locally created object may be touched immediately
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Pipe.prototype.deliver" id="apidoc.element.swarm.Pipe.prototype.deliver">
        function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>deliver
        <span class="apidocSignatureSpan">(spec, val, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pd(spec, val, src) {
    var self = this;
    val &#x26;&#x26; val.constructor === Spec &#x26;&#x26; (val = val.toString());
    if (spec.type() === &#x27;Host&#x27;) {
        switch (spec.op()) {
        case &#x27;reoff&#x27;:
            setTimeout(function itsOverReally() {
                self.isOnSent = undefined;
                self.close();
            }, 1);
            break;
        case &#x27;off&#x27;:
            setTimeout(function tickingBomb() {
                self.close();
            }, 5000);
            break;
        case &#x27;on&#x27;:
            this.isOnSent = true;
        case &#x27;reon&#x27;:
            this.isOnSent = false;
        }
    }
    this.bundle[spec] = val === undefined ? null : val; // TODO aggregation
    if (this.delay === -1) {
        this.sendBundle();
    } else if (!this.send_timer) {
        var now = this.time(),
            gap = now - this.lastSendTS,
            timeout = gap &#x3e; this.delay ? this.delay : this.delay - gap;
        this.send_timer = setTimeout(this.sendBundle.bind(this), timeout); // hmmm...
    } // else {} // just wait
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.callbacks===null) { return; }
var that = this.owner || src;
for(var i=0; i&#x3c;this.callbacks.length; i++) {
    var cb = this.callbacks[i];
    if (cb.constructor===Function) {
        cb.call(that,spec,value,src);
    } else {
        cb.<span class="apidocCodeKeywordSpan">deliver</span>(spec,value,src);
    }
}
};

ProxyListener.prototype.on = function (callback) {
if (this.callbacks===null) { this.callbacks = []; }
this.callbacks.push(callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Pipe.prototype.keepAliveFn" id="apidoc.element.swarm.Pipe.prototype.keepAliveFn">
        function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>keepAliveFn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keepAliveFn = function () {
    var now = this.time(),
        sinceRecv = now - this.lastRecvTS,
        sinceSend = now - this.lastSendTS;
    if (sinceSend &#x3e; Pipe.TIMEOUT / 2) {
        this.sendBundle();
    }
    if (sinceRecv &#x3e; Pipe.TIMEOUT) {
        this.close(&#x22;stream timeout&#x22;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Pipe.prototype.parseBundle" id="apidoc.element.swarm.Pipe.prototype.parseBundle">
        function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>parseBundle
        <span class="apidocSignatureSpan">(bundle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pb(bundle) {
    var spec_list = [], spec, self = this;
    //parse specifiers
    for (spec in bundle) { spec &#x26;&#x26; spec_list.push(new Spec(spec)); }
    spec_list.sort().reverse();
    while (spec = spec_list.pop()) {
        spec = Spec.as(spec);
        this.host.deliver(spec, bundle[spec], this);
        if (spec.type() === &#x27;Host&#x27; &#x26;&#x26; spec.op() === &#x27;reoff&#x27;) { //TODO check #id
            setTimeout(function () {
                self.isOnSent = undefined;
                self.close();
            }, 1);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Pipe.prototype.parseHandshake" id="apidoc.element.swarm.Pipe.prototype.parseHandshake">
        function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>parseHandshake
        <span class="apidocSignatureSpan">(handshake)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ph(handshake) {
    var spec, value, key;
    for (key in handshake) {
        spec = new Spec(key);
        value = handshake[key];
        break; // 8)-
    }
    if (!spec) {
        throw new Error(&#x27;handshake has no spec&#x27;);
    }
    if (spec.type() !== &#x27;Host&#x27;) {
        env.warn(&#x22;non-Host handshake&#x22;);
    }
    if (spec.id() === this.host._id) {
        throw new Error(&#x27;self hs&#x27;);
    }
    this._id = spec.id();
    var op = spec.op();
    var evspec = spec.set(this.host._id, &#x27;#&#x27;);

    if (op in {on: 1, reon: 1, off: 1, reoff: 1}) {// access denied TODO
        this.host.deliver(evspec, value, this);
    } else {
        throw new Error(&#x27;invalid handshake&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Pipe.prototype.sendBundle" id="apidoc.element.swarm.Pipe.prototype.sendBundle">
        function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>sendBundle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pS() {
    var payload = this.serializer.stringify(this.bundle);
    this.bundle = {};
    if (!this.stream) {
        this.send_timer = null;
        return; // too late
    }

    try {
        env.trace &#x26;&#x26; env.log(dotOut, payload, this, this.host);
        this.stream.write(payload);
        this.lastSendTS = this.time();
    } catch (ex) {
        env.error(&#x27;stream error on write: &#x27; + ex, ex.stack);
        if (this._id) {
            this.close(&#x27;stream error&#x27;, ex);
        }
    } finally {
        this.send_timer = null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Pipe.prototype.spec" id="apidoc.element.swarm.Pipe.prototype.spec">
        function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>spec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spec = function () {
    return this._id ? new Spec(&#x27;/Host#&#x27; + this._id) : &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Pipe.prototype.time" id="apidoc.element.swarm.Pipe.prototype.time">
        function <span class="apidocSignatureSpan">swarm.Pipe.prototype.</span>time
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">time = function () { return new Date().getTime(); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.ProxyListener" id="apidoc.module.swarm.ProxyListener">module swarm.ProxyListener</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.ProxyListener.ProxyListener" id="apidoc.element.swarm.ProxyListener.ProxyListener">
        function <span class="apidocSignatureSpan">swarm.</span>ProxyListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyListener() {
    this.callbacks = null;
    this.owner = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.ProxyListener.prototype" id="apidoc.module.swarm.ProxyListener.prototype">module swarm.ProxyListener.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.ProxyListener.prototype.deliver" id="apidoc.element.swarm.ProxyListener.prototype.deliver">
        function <span class="apidocSignatureSpan">swarm.ProxyListener.prototype.</span>deliver
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deliver = function (spec, value, src) {
    if (this.callbacks===null) { return; }
    var that = this.owner || src;
    for(var i=0; i&#x3c;this.callbacks.length; i++) {
        var cb = this.callbacks[i];
        if (cb.constructor===Function) {
            cb.call(that,spec,value,src);
        } else {
            cb.deliver(spec,value,src);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.callbacks===null) { return; }
var that = this.owner || src;
for(var i=0; i&#x3c;this.callbacks.length; i++) {
    var cb = this.callbacks[i];
    if (cb.constructor===Function) {
        cb.call(that,spec,value,src);
    } else {
        cb.<span class="apidocCodeKeywordSpan">deliver</span>(spec,value,src);
    }
}
};

ProxyListener.prototype.on = function (callback) {
if (this.callbacks===null) { this.callbacks = []; }
this.callbacks.push(callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.ProxyListener.prototype.off" id="apidoc.element.swarm.ProxyListener.prototype.off">
        function <span class="apidocSignatureSpan">swarm.ProxyListener.prototype.</span>off
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (callback) {
    if (this.callbacks===null) { return; }
    var i = this.callbacks.indexOf(callback);
    if (i!==-1) {
        this.callbacks.splice(i,1);
    } else {
        console.warn(&#x27;listener unknown&#x27;, callback);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Unsubscribe from collections entries&#x27; events
 * @param {function(*)} callback
 * @this Set|Vector
 */
offObjectEvent: function (callback) {
    this._proxy.<span class="apidocCodeKeywordSpan">off</span>(callback);
},

/**
 * Waits for collection to receive state from cache or uplink and then invokes passed callback
 *
 * @param {function()} callback
 * @this Set|Vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.ProxyListener.prototype.on" id="apidoc.element.swarm.ProxyListener.prototype.on">
        function <span class="apidocSignatureSpan">swarm.ProxyListener.prototype.</span>on
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (callback) {
    if (this.callbacks===null) { this.callbacks = []; }
    this.callbacks.push(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.ReactMixin" id="apidoc.module.swarm.ReactMixin">module swarm.ReactMixin</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.ReactMixin.componentWillMount" id="apidoc.element.swarm.ReactMixin.componentWillMount">
        function <span class="apidocSignatureSpan">swarm.ReactMixin.</span>componentWillMount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillMount = function () {
    var spec = this.props.spec || this.props.key;
    if (!Spec.is(spec)) {
        if (spec &#x26;&#x26; this.constructor.modelType) {
            var id = spec;
            spec = new Spec(this.constructor.modelType,&#x27;/&#x27;); // TODO fn!!!
            spec = spec.add(id,&#x27;#&#x27;);
        } else {
            throw new Error(&#x27;not a specifier: &#x27;+spec+&#x27; at &#x27;+this._rootNodeID);
        }
    }
    this.sync = env.localhost.get(spec);
    this.setState({version:&#x27;&#x27;});
    if (!env.isServer) {
        var sync = this.sync;
        sync.on(&#x27;init&#x27;, this); // TODO single listener
        sync.on(this);
        if (this.props.listenEntries) {
            sync.onObjectEvent(this);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.ReactMixin.componentWillUnmount" id="apidoc.element.swarm.ReactMixin.componentWillUnmount">
        function <span class="apidocSignatureSpan">swarm.ReactMixin.</span>componentWillUnmount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillUnmount = function () {
    if (!env.isServer) {
        var sync = this.sync;
        sync.off(this);
        sync.off(this); // FIXME: remove after TODO: prevent second subscription
        if (this.props.listenEntries) {
            sync.offObjectEvent(this);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.ReactMixin.deliver" id="apidoc.element.swarm.ReactMixin.deliver">
        function <span class="apidocSignatureSpan">swarm.ReactMixin.</span>deliver
        <span class="apidocSignatureSpan">(spec, val, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deliver = function (spec, val, source) {
    var sync = this.sync;
    var version = sync._version;
    if (this.props.listenEntries) {
        var opId = &#x27;!&#x27; + spec.version();
        if (version !== opId) {
            version = opId;
        }
    }
    this.setState({version: version});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.callbacks===null) { return; }
var that = this.owner || src;
for(var i=0; i&#x3c;this.callbacks.length; i++) {
    var cb = this.callbacks[i];
    if (cb.constructor===Function) {
        cb.call(that,spec,value,src);
    } else {
        cb.<span class="apidocCodeKeywordSpan">deliver</span>(spec,value,src);
    }
}
};

ProxyListener.prototype.on = function (callback) {
if (this.callbacks===null) { this.callbacks = []; }
this.callbacks.push(callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.ReactMixin.shouldComponentUpdate" id="apidoc.element.swarm.ReactMixin.shouldComponentUpdate">
        function <span class="apidocSignatureSpan">swarm.ReactMixin.</span>shouldComponentUpdate
        <span class="apidocSignatureSpan">(nextProps, nextState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shouldComponentUpdate = function (nextProps, nextState) {
    return this.props !== nextProps || this.state.version !== nextState.version;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.SecondPreciseClock" id="apidoc.module.swarm.SecondPreciseClock">module swarm.SecondPreciseClock</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.SecondPreciseClock.SecondPreciseClock" id="apidoc.element.swarm.SecondPreciseClock.SecondPreciseClock">
        function <span class="apidocSignatureSpan">swarm.</span>SecondPreciseClock
        <span class="apidocSignatureSpan">(processId, timeOffsetMs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SecondPreciseClock = function (processId, timeOffsetMs) {
    if (!Spec.reTok.test(processId)) {
        throw new Error(&#x27;invalid process id: &#x27;+processId);
    }
    this.id = processId;
    // sometimes we assume our local clock has some offset
    this.clockOffsetMs = 0;
    this.lastTimestamp = &#x27;&#x27;;
    // although we try hard to use wall clock time, we must
    // obey Lamport logical clock rules, in particular our
    // timestamps must be greater than any other timestamps
    // previously seen
    this.lastTimeSeen = 0;
    this.lastSeqSeen = 0;
    if (timeOffsetMs) {
        this.clockOffsetMs = timeOffsetMs;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.SecondPreciseClock.prototype" id="apidoc.module.swarm.SecondPreciseClock.prototype">module swarm.SecondPreciseClock.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.SecondPreciseClock.prototype.adjustTime" id="apidoc.element.swarm.SecondPreciseClock.prototype.adjustTime">
        function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>adjustTime
        <span class="apidocSignatureSpan">(trueMs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">adjustTime = function (trueMs) {
    var localTime = this.ms();
    var clockOffsetMs = trueMs - localTime;
    this.clockOffsetMs = clockOffsetMs;
    var lastTS = this.lastTimeSeen;
    this.lastTimeSeen = 0;
    this.lastSeqSeen = 0;
    this.lastTimestamp = &#x27;&#x27;;
    if ( this.seconds()+1 &#x3c; lastTS ) {
        console.error(&#x22;risky clock reset&#x22;,this.lastTimestamp);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SecondPreciseClock.prototype.checkTimestamp" id="apidoc.element.swarm.SecondPreciseClock.prototype.checkTimestamp">
        function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>checkTimestamp
        <span class="apidocSignatureSpan">(ts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function see(ts) {
    if (ts&#x3c;this.lastTimestamp) { return true; }
    var parsed = this.parseTimestamp(ts);
    if (parsed.time&#x3c;this.lastTimeSeen) { return true; }
    var sec = this.seconds();
    if (parsed.time&#x3e;sec+1) {
        return false; // back to the future
    }
    this.lastTimeSeen = parsed.time;
    this.lastSeqSeen = parsed.seq;
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                        seqi = 1; // FIXME repeat ids, double insert
                    }
                }
            }
        }
    }
    if (genTs) {
        this._host.clock.<span class="apidocCodeKeywordSpan">checkTimestamp</span>(genTs);
    }
    this.weave = w1.join(&#x27;&#x27;);
    this.ids = w4;
    this.rebuild();
},
remove: function (spec, rm, src) {
    var w1 = [], w4 = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SecondPreciseClock.prototype.issueTimestamp" id="apidoc.element.swarm.SecondPreciseClock.prototype.issueTimestamp">
        function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>issueTimestamp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function time() {
    var res = this.seconds();
    if (this.lastTimeSeen&#x3e;res) { res = this.lastTimeSeen; }
    if (res&#x3e;this.lastTimeSeen) { this.lastSeqSeen = -1; }
    this.lastTimeSeen = res;
    var seq = ++this.lastSeqSeen;
    if (seq&#x3e;=(1&#x3c;&#x3c;12)) {throw new Error(&#x27;max event freq is 4000Hz&#x27;);}

    var baseTimeSeq = Spec.int2base(res, 5);
    if (seq&#x3e;0) { baseTimeSeq+=Spec.int2base(seq, 2); }

    this.lastTimestamp = baseTimeSeq + &#x27;+&#x27; + this.id;
    return this.lastTimestamp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SecondPreciseClock.prototype.ms" id="apidoc.element.swarm.SecondPreciseClock.prototype.ms">
        function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>ms
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ms = function () {
    var millis = new Date().getTime();
    millis -= SecondPreciseClock.EPOCH;
    return millis;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SecondPreciseClock.prototype.parseTimestamp" id="apidoc.element.swarm.SecondPreciseClock.prototype.parseTimestamp">
        function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>parseTimestamp
        <span class="apidocSignatureSpan">(ts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(ts) {
    var m = ts.match(Spec.reTokExt);
    if (!m) {throw new Error(&#x27;malformed timestamp: &#x27;+ts);}
    var timeseq=m[1]; //, process=m[2];
    var time = timeseq.substr(0,5), seq = timeseq.substr(5);
    if (seq&#x26;&#x26;seq.length!==2) {
        throw new Error(&#x27;malformed timestamp value: &#x27;+timeseq);
    }
    return {
        time: Spec.base2int(time),
        seq: seq ? Spec.base2int(seq) : 0
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        seq: Spec.base2int(m[1]),
        process: m[2]
    };
};

/** Lamport partial order  imperfect semi-logical*/
LamportClock.prototype.checkTimestamp = function see (ts) {
    var parsed = this.<span class="apidocCodeKeywordSpan">parseTimestamp</span>(ts);
    if (parsed.seq &#x3e;= this.seq) {
        this.seq = parsed.seq + 1;
    }
    return true;
};

LamportClock.prototype.time2date = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SecondPreciseClock.prototype.seconds" id="apidoc.element.swarm.SecondPreciseClock.prototype.seconds">
        function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>seconds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seconds = function () {
    var millis = this.ms();
    millis += this.clockOffsetMs;
    return (millis/1000) | 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SecondPreciseClock.prototype.timestamp2date" id="apidoc.element.swarm.SecondPreciseClock.prototype.timestamp2date">
        function <span class="apidocSignatureSpan">swarm.SecondPreciseClock.prototype.</span>timestamp2date
        <span class="apidocSignatureSpan">(ts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timestamp2date = function (ts) {
    var parsed = this.parseTimestamp(ts);
    var millis = parsed.time * 1000 + SecondPreciseClock.EPOCH;
    return new Date(millis);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Set" id="apidoc.module.swarm.Set">module swarm.Set</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Set.Set" id="apidoc.element.swarm.Set.Set">
        function <span class="apidocSignatureSpan">swarm.</span>Set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SomeSyncable() {
    return parent.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set._super" id="apidoc.element.swarm.Set._super">
        function <span class="apidocSignatureSpan">swarm.Set.</span>_super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Syncable() {
    // listeners represented as objects that have deliver() method
    this._lstn = [&#x27;,&#x27;]; // we unshift() uplink listeners and push() downlinks
    // ...so _lstn is like [server1, server2, storage, &#x27;,&#x27;, view, listener]
    // The most correct way to specify a version is the version vector,
    // but that one may consume more space than the data itself in some cases.
    // Hence, _version is not a fully specified version vector (see version()
    // instead). _version is essentially is the greatest operation timestamp
    // (Lamport-like, i.e. &#x22;time+source&#x22;), sometimes amended with additional
    // timestamps. Its main features:
    // (1) changes once the object&#x27;s state changes
    // (2) does it monotonically (in the alphanum order sense)
    this._version = &#x27;&#x27;;
    // make sense of arguments
    var args = Array.prototype.slice.call(arguments);
    this._host = (args.length &#x26;&#x26; args[args.length - 1]._type === &#x27;Host&#x27;) ?
            args.pop() : env.localhost;
    if (Spec.is(args[0])) {
        this._id = new Spec(args.shift()).id() || this._host.time();
    } else if (typeof(args[0]) === &#x27;string&#x27;) {
        this._id = args.shift(); // TODO format
    } else {
        this._id = this._host.time();
        this._version = &#x27;!0&#x27;; // may apply state in the constructor, see Model
    }
    //var state = args.length ? args.pop() : (fresh?{}:undefined);
    // register with the host
    var doubl = this._host.register(this);
    if (doubl !== this) { return doubl; }
    // locally created objects get state immediately
    // (while external-id objects need to query uplinks)
<span class="apidocCodeCommentSpan">    /*if (fresh &#x26;&#x26; state) {
     state._version = &#x27;!&#x27;+this._id;
     var pspec = this.spec().add(state._version).add(&#x27;.init&#x27;);
     this.deliver(pspec,state,this._host);
     }*/
</span>    this.reset();
    // find uplinks, subscribe
    this.checkUplink();
    // TODO inplement state push
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.addReaction" id="apidoc.element.swarm.Set.addReaction">
        function <span class="apidocSignatureSpan">swarm.Set.</span>addReaction
        <span class="apidocSignatureSpan">(op, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addReaction = function (op, fn) {
    var reactions = this.prototype._reactions;
    var list = reactions[op];
    list || (list = reactions[op] = []);
    list.push(fn);
    return {op: op, fn: fn};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.extend" id="apidoc.element.swarm.Set.extend">
        function <span class="apidocSignatureSpan">swarm.Set.</span>extend
        <span class="apidocSignatureSpan">(fn, own)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (fn, own) {
    var parent = this, fnid;
    if (fn.constructor !== Function) {
        var id = fn.toString();
        fn = function SomeSyncable() {
            return parent.apply(this, arguments);
        };
        fnid = id; // if only it worked
    } else { // please call Syncable.constructor.apply(this,args) in your constructor
        fnid = fnname(fn);
    }

    // inheritance trick from backbone.js
    var SyncProto = function () {
        this.constructor = fn;
        this._neutrals = {};
        this._ops = {};
        this._reactions = {};

        var event,
            name;
        if (parent._pt) {
            //copy _neutrals &#x26; _ops from parent
            for (event in parent._pt._neutrals) {
                this._neutrals[event] = parent._pt._neutrals[event];
            }
            for (event in parent._pt._ops) {
                this._ops[event] = parent._pt._ops[event];
            }
        }

        // &#x22;Methods&#x22; are serialized, logged and delivered to replicas
        for (name in own.ops || {}) {
            if (Syncable.reMethodName.test(name)) {
                this._ops[name] = own.ops[name];
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid op name:&#x27;,name);
            }
        }

        // &#x22;Neutrals&#x22; don&#x27;t change the state
        for (name in own.neutrals || {}) {
            if (Syncable.reMethodName.test(name)) {
                this._neutrals[name] = own.neutrals[name];
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid neutral op name:&#x27;,name);
            }
        }

        // &#x22;Remotes&#x22; are serialized and sent upstream (like RPC calls)
        for (name in own.remotes || {}) {
            if (Syncable.reMethodName.test(name)) {
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid rpc name:&#x27;,name);
            }
        }

        // add mixins
        (own.mixins || []).forEach(function (mixin) {
            for (var name in mixin) {
                this[name] = mixin[name];
            }
        }, this);

        // add other members
        for (name in own) {
            if (Syncable.reMethodName.test(name)) {
                var memberType = own[name].constructor;
                if (memberType === Function) { // non-op method
                    // these must change state ONLY by invoking ops
                    this[name] = own[name];
                } else if (memberType===String || memberType===Number) {
                    this[name] = own[name]; // some static constant, OK
                } else if (name in Syncable.memberClasses) {
                    // see above
                    continue;
                } else {
                    console.warn(&#x27;invalid member:&#x27;,name,memberType);
                }
            } else {
                console.warn(&#x27;invalid member name:&#x27;,name);
            }
        }

        // add reactions
        for (name in own.reactions || {}) {
            var reaction = own.reactions[name];
            if (!reaction) { continue; }

            switch (typeof reaction) {
            case &#x27;function&#x27;:
                // handler-function
                this._reactions[name] = [reaction];
                break;
            case &#x27;string&#x27;:
                // handler-method name
                this._reactions[name] = [this[name]];
                break;
            default:
                if (reaction.constructor === Array) {
                    // array of handlers
                    this._reactions[name] = reaction.map(function (item) {
                        switch (typeof item) {
                        case &#x27;function&#x27;:
                            return item;
                        case &#x27;string&#x27;:
                            return this[item];
                        default:
                            throw new Error(&#x27;unexpected reaction type&#x27;);
                        }
                    }, this);
                } else {
                    throw new Error(&#x27;unex ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
these demos are normally online at http://ppyr.us and http://ppyr.us:8001/demo3/index.html respectively.

### Creating your first simple synchronized type

```js
var Swarm = require(&#x27;swarm&#x27;);

var Mouse = Swarm.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;Mouse&#x27;, {
    defaults: {
        name: &#x27;Mickey&#x27;,
        x: 0,
        y: 0
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.removeReaction" id="apidoc.element.swarm.Set.removeReaction">
        function <span class="apidocSignatureSpan">swarm.Set.</span>removeReaction
        <span class="apidocSignatureSpan">(handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeReaction = function (handle) {
    var op = handle.op,
        fn = handle.fn,
        list = this.prototype._reactions[op],
        i = list.indexOf(fn);
    if (i === -1) {
        throw new Error(&#x27;reaction unknown&#x27;);
    }
    list[i] = undefined; // such a peculiar pattern not to mess up out-of-callback removal
    while (list.length &#x26;&#x26; !list[list.length - 1]) {
        list.pop();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Set.prototype" id="apidoc.module.swarm.Set.prototype">module swarm.Set.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.addObject" id="apidoc.element.swarm.Set.prototype.addObject">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>addObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addObject = function (obj) {
    var specs = {};
    specs[obj.spec()] = 1;
    this.change(specs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.callReactions" id="apidoc.element.swarm.Set.prototype.callReactions">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>callReactions
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callReactions = function (spec, value, src) {
    var superReactions = syncProto._super.callReactions;
    if (&#x27;function&#x27; === typeof superReactions) {
        superReactions.call(this, spec, value, src);
    }
    var r = syncProto._reactions[spec.op()];
    if (r) {
        r.constructor !== Array &#x26;&#x26; (r = [r]);
        for (var i = 0; i &#x3c; r.length; i++) {
            r[i] &#x26;&#x26; r[i].call(this, spec, value, src);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.change" id="apidoc.element.swarm.Set.prototype.change">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>change
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.constructor" id="apidoc.element.swarm.Set.prototype.constructor">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SomeSyncable() {
    return parent.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.distillLog" id="apidoc.element.swarm.Set.prototype.distillLog">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>distillLog
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distillLog = function () {
    // explain
    var sets = [],
        cumul = {},
        heads = {},
        spec;
    for (var s in this._oplog) {
        spec = new Spec(s);
        //if (spec.op() === &#x27;set&#x27;) {
        sets.push(spec);
        //}
    }
    sets.sort();
    for (var i = sets.length - 1; i &#x3e;= 0; i--) {
        spec = sets[i];
        var val = this._oplog[spec],
            notempty = false;
        for (var field in val) {
            if (field in cumul) {
                delete val[field];
            } else {
                notempty = cumul[field] = val[field]; //store last value of the field
            }
        }
        var source = spec.source();
        notempty || (heads[source] &#x26;&#x26; delete this._oplog[spec]);
        heads[source] = true;
    }
    return cumul;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.distillOp" id="apidoc.element.swarm.Set.prototype.distillOp">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>distillOp
        <span class="apidocSignatureSpan">(spec, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distillOp = function (spec, val) {
    if (spec.version() &#x3e; this._version) {
        return val; // no concurrent op
    }
    var opkey = spec.filter(&#x27;!.&#x27;);
    this._oplog[opkey] = val;
    this.distillLog(); // may amend the value
    return this._oplog[opkey] || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.every" id="apidoc.element.swarm.Set.prototype.every">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>every
        <span class="apidocSignatureSpan">(cb, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">every = function (cb, thisArg) {
    var index = 0;
    for (var spec in this._objects) {
        if (!cb.call(thisArg, this._objects[spec], index++)) {
            return false;
        }
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.filter" id="apidoc.element.swarm.Set.prototype.filter">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>filter
        <span class="apidocSignatureSpan">(cb, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (cb, thisArg) {
    var res = [];
    this.forEach(function (entry, idx) {
        if (cb.call(thisArg, entry, idx)) {
            res.push(entry);
        }
    });
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function htmlesc (text) {
return text;
}

/// range/ids -???  first, all   then...

function rtf2txt (rtf) {
var txt = rtf.<span class="apidocCodeKeywordSpan">filter</span>(function(o){ return o &#x26;&#x26; o.constructor===String });
return txt.join(&#x27;&#x27;);
}

function meta2attstr (meta) {
var ret = [], styles={}, classes={}, atts={}, structs={};
var kv = {&#x27;:&#x27;:styles,&#x27;_&#x27;:classes,&#x27;=&#x27;:atts,&#x27;s&#x27;:structs};
var re_meta = /^(\w[\w_\-]*)([:_=]?)$/, m;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.forEach" id="apidoc.element.swarm.Set.prototype.forEach">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>forEach
        <span class="apidocSignatureSpan">(cb, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (cb, thisArg) {
    var index = 0;
    for (var spec in this._objects) {
        cb.call(thisArg, this._objects[spec], index++);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.get" id="apidoc.element.swarm.Set.prototype.get">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>get
        <span class="apidocSignatureSpan">(key_spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key_spec) {
    key_spec = new Spec(key_spec).filter(&#x27;/#&#x27;);
    if (key_spec.pattern() !== &#x27;/#&#x27;) {
        throw new Error(&#x22;invalid spec&#x22;);
    }
    return this._objects[key_spec];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var swarmHost = new Swarm.Host(&#x27;unique_client_id&#x27;);

// 2. connect to your server
swarmHost.connect(&#x27;ws://localhost:8000/&#x27;);

// 3.a. create an object
var someMouse = new Mouse();
// OR swarmHost.<span class="apidocCodeKeywordSpan">get</span>(&#x27;/Mouse&#x27;);
// OR new Mouse({x:1, y:2});

// 4.a. a locally created object may be touched immediately
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.list" id="apidoc.element.swarm.Set.prototype.list">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>list
        <span class="apidocSignatureSpan">(order)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">list = function (order) {
    var ret = [];
    for (var key in this._objects) {
        ret.push(this._objects[key]);
    }
    ret.sort(order);
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.map" id="apidoc.element.swarm.Set.prototype.map">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>map
        <span class="apidocSignatureSpan">(cb, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (cb, thisArg) {
    var res = [];
    this.forEach(function (entry, idx) {
        res.push(cb.call(thisArg, entry, idx));
    });
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.offObjectEvent" id="apidoc.element.swarm.Set.prototype.offObjectEvent">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>offObjectEvent
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">offObjectEvent = function (callback) {
    this._proxy.off(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.onObjectEvent" id="apidoc.element.swarm.Set.prototype.onObjectEvent">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>onObjectEvent
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onObjectEvent = function (callback) {
    this._proxy.owner = this;
    this._proxy.on(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.onObjectStateReady" id="apidoc.element.swarm.Set.prototype.onObjectStateReady">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>onObjectStateReady
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onObjectStateReady = function (callback) { // TODO timeout ?
    var self = this;
    function checker() {
        var notInitedYet = self.filter(function (entry) {
            return !entry._version;
        });
        if (!notInitedYet.length) {
            // all entries are inited
            callback();
        } else {
            // wait for some entry not ready yet
            var randomIdx = (Math.random() * (notInitedYet.length - 1)) | 0;
            notInitedYet[randomIdx].once(&#x27;init&#x27;, checker);
        }
    }
    if (this._version) {
        checker();
    } else {
        this.once(&#x27;init&#x27;, checker);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.pojo" id="apidoc.element.swarm.Set.prototype.pojo">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>pojo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pojo = function () {
    // invoke super.pojo()
    var result = Syncable._pt.pojo.apply(this, arguments);
    result.entries = Object.keys(this._objects);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.removeObject" id="apidoc.element.swarm.Set.prototype.removeObject">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>removeObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObject = function (obj) {
    var spec = obj._id ? obj.spec() : new Spec(obj).filter(&#x27;/#&#x27;);
    if (spec.pattern() !== &#x27;/#&#x27;) {
        throw new Error(&#x27;invalid spec: &#x27; + spec);
    }
    var specs = {};
    specs[spec] = 0;
    this.change(specs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype.validate" id="apidoc.element.swarm.Set.prototype.validate">
        function <span class="apidocSignatureSpan">swarm.Set.prototype.</span>validate
        <span class="apidocSignatureSpan">(spec, val, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (spec, val, src) {
    if (spec.op() !== &#x27;change&#x27;) {
        return &#x27;&#x27;;
    }

    for (var key_spec in val) {
        // member spec validity
        if (Spec.pattern(key_spec) !== &#x27;/#&#x27;) {
            return &#x27;invalid spec: &#x27; + key_spec;
        }
    }
    return &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Set.prototype._neutrals" id="apidoc.module.swarm.Set.prototype._neutrals">module swarm.Set.prototype._neutrals</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Set.prototype._neutrals.error" id="apidoc.element.swarm.Set.prototype._neutrals.error">
        function <span class="apidocSignatureSpan">swarm.Set.prototype._neutrals.</span>error
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (spec, val, repl) {
    console.error(&#x27;something failed:&#x27;, spec, val, &#x27;@&#x27;, (repl &#x26;&#x26; repl._id));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.buf = buf; //will wait for &#x22;open&#x22;
    }
    ws.on(&#x27;close&#x27;, function () { ln.close &#x26;&#x26; ln.close(); });
    ws.on(&#x27;data&#x27;, function (msg) {
        try {
            ln.data &#x26;&#x26; ln.data(msg);
        } catch (ex) {
            console.<span class="apidocCodeKeywordSpan">error</span>(&#x27;message processing fails&#x27;, ex);
            ln.error &#x26;&#x26; ln.error(ex.message);
        }
    });
}

module.exports = SockJSStream;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype._neutrals.off" id="apidoc.element.swarm.Set.prototype._neutrals.off">
        function <span class="apidocSignatureSpan">swarm.Set.prototype._neutrals.</span>off
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (spec, val, repl) {
    var idx = this.getListenerIndex(repl); //TODO ??? uplinks_only?
    if (idx &#x3e; -1) {
        this._lstn.splice(idx, 1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Unsubscribe from collections entries&#x27; events
 * @param {function(*)} callback
 * @this Set|Vector
 */
offObjectEvent: function (callback) {
    this._proxy.<span class="apidocCodeKeywordSpan">off</span>(callback);
},

/**
 * Waits for collection to receive state from cache or uplink and then invokes passed callback
 *
 * @param {function()} callback
 * @this Set|Vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype._neutrals.on" id="apidoc.element.swarm.Set.prototype._neutrals.on">
        function <span class="apidocSignatureSpan">swarm.Set.prototype._neutrals.</span>on
        <span class="apidocSignatureSpan">(spec, filter, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (spec, filter, repl) {   // WELL  on() is not an op, right?
    // if no listener is supplied then the object is only
    // guaranteed to exist till the next Host.gc() run
    if (!repl) { return; }

    var self = this;
    // stateless objects fire no events; essentially, on() is deferred
    if (!this._version &#x26;&#x26; filter) { // TODO solidify
        this._lstn.push({
            _op: &#x27;reon&#x27;,
            _src: repl,
            deliver: function () {
                var i = self._lstn.indexOf(this);
                self._lstn.splice(i, 1);
                self.deliver(spec, filter, repl);
            }
        });
        return; // defer this call till uplinks are ready
    }
    // make all listeners uniform objects
    if (repl.constructor === Function) {
        repl = {
            sink: repl,
            that: this,
            deliver: function () { // .deliver is invoked on an event
                this.sink.apply(this.that, arguments);
            }
        };
    }

    if (filter) {
        filter = new Spec(filter, &#x27;.&#x27;);
        var baseVersion = filter.filter(&#x27;!&#x27;),
            filter_by_op = filter.get(&#x27;.&#x27;);

        if (filter_by_op === &#x27;init&#x27;) {
            var diff_if_needed = baseVersion ? this.diff(baseVersion) : &#x27;&#x27;;
            repl.deliver(spec.set(&#x27;.init&#x27;), diff_if_needed, this); //??
            // FIXME use once()
            return;
        }
        if (filter_by_op) {
            repl = {
                sink: repl,
                _op: filter_by_op,
                deliver: function deliverWithFilter(spec, val, src) {
                    if (spec.op() === filter_by_op) {
                        this.sink.deliver(spec, val, src);
                    }
                }
            };
        }

        if (!baseVersion.isEmpty()) {
            var diff = this.diff(baseVersion);
            diff &#x26;&#x26; repl.deliver(spec.set(&#x27;.init&#x27;), diff, this); // 2downlink
            repl.deliver(spec.set(&#x27;.reon&#x27;), this.version().toString(), this);
        }
    }

    this._lstn.push(repl);
    // TODO repeated subscriptions: send a diff, otherwise ignore
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype._neutrals.reoff" id="apidoc.element.swarm.Set.prototype._neutrals.reoff">
        function <span class="apidocSignatureSpan">swarm.Set.prototype._neutrals.</span>reoff
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reoff = function (spec, val, repl) {
    var idx = this.getListenerIndex(repl); //TODO ??? uplinks_only?
    if (idx &#x3e; -1) {
        this._lstn.splice(idx, 1);
    }
    if (this._id) {
        this.checkUplink();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype._neutrals.reon" id="apidoc.element.swarm.Set.prototype._neutrals.reon">
        function <span class="apidocSignatureSpan">swarm.Set.prototype._neutrals.</span>reon
        <span class="apidocSignatureSpan">(spec, filter, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reon = function (spec, filter, repl) {
    if (filter) {  // a diff is requested
        var base = Spec.as(filter).tok(&#x27;!&#x27;);
        var diff = this.diff(base);
        if (diff) {
            repl.deliver(spec.set(&#x27;.init&#x27;), diff, this);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Set.prototype._ops" id="apidoc.module.swarm.Set.prototype._ops">module swarm.Set.prototype._ops</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Set.prototype._ops.change" id="apidoc.element.swarm.Set.prototype._ops.change">
        function <span class="apidocSignatureSpan">swarm.Set.prototype._ops.</span>change
        <span class="apidocSignatureSpan">(spec, value, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">change = function (spec, value, repl) {
    value = this.distillOp(spec, value);
    var key_spec;
    for (key_spec in value) {
        if (value[key_spec] === 1) {
            if (!this._objects[key_spec]) { // only if object not in the set
                this._objects[key_spec] = this._host.get(key_spec);
                this._objects[key_spec].on(this._proxy);
            }
        } else if (value[key_spec] === 0) {
            if (this._objects[key_spec]) {
                this._objects[key_spec].off(this._proxy);
                delete this._objects[key_spec];
            }
        } else {
            env.log(this.spec(), &#x27;unexpected val&#x27;, JSON.stringify(value));
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Set.prototype._ops.init" id="apidoc.element.swarm.Set.prototype._ops.init">
        function <span class="apidocSignatureSpan">swarm.Set.prototype._ops.</span>init
        <span class="apidocSignatureSpan">(spec, state, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (spec, state, src) {

    var tail = {}, // ops to be applied on top of the received state
        typeid = spec.filter(&#x27;/#&#x27;),
        lstn = this._lstn,
        a_spec;
    this._lstn = []; // prevent events from being fired

    if (state._version/* &#x26;&#x26; state._version !== &#x27;!0&#x27;*/) {
        // local changes may need to be merged into the received state
        if (this._oplog) {
            for (a_spec in this._oplog) {
                tail[a_spec] = this._oplog[a_spec];
            }
            this._oplog = {};
        }
        this._vector &#x26;&#x26; (this._vector = undefined);
        // zero everything
        for (var key in this) {
            if (this.hasOwnProperty(key) &#x26;&#x26; key.charAt(0) !== &#x27;_&#x27;) {
                this[key] = undefined;
            }
        }
        // set default values
        this.reset();

        this.apply(state);
        this._version = state._version;

        state._oplog &#x26;&#x26; (this._oplog = state._oplog); // FIXME copy
        state._vector &#x26;&#x26; (this._vector = state._vector);
    }
    // add the received tail to the local one
    if (state._tail) {
        for (a_spec in state._tail) {
            tail[a_spec] = state._tail[a_spec];
        }
    }
    // appply the combined tail to the new state
    var specs = [];
    for (a_spec in tail) {
        specs.push(a_spec);
    }
    specs.sort().reverse();
    // there will be some replays, but those will be ignored
    while (a_spec = specs.pop()) {
        this.deliver(typeid.add(a_spec), tail[a_spec], this);
    }

    this._lstn = lstn;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.SharedWebStorage" id="apidoc.module.swarm.SharedWebStorage">module swarm.SharedWebStorage</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.SharedWebStorage.SharedWebStorage" id="apidoc.element.swarm.SharedWebStorage.SharedWebStorage">
        function <span class="apidocSignatureSpan">swarm.</span>SharedWebStorage
        <span class="apidocSignatureSpan">(id, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SharedWebStorage(id, options) {
    this.options = options || {};
    this.lstn = {};
    this._id = id;
    this.tails = {};
    this.store = this.options.persistent ?
        window.localStorage : window.sessionStorage;

    this.loadLog();
    this.installListeners();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.SharedWebStorage.prototype" id="apidoc.module.swarm.SharedWebStorage.prototype">module swarm.SharedWebStorage.prototype</a></h1>






    <h2>
        <a href="#apidoc.element.swarm.SharedWebStorage.prototype.installListeners" id="apidoc.element.swarm.SharedWebStorage.prototype.installListeners">
        function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>installListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">installListeners = function () {
    var self = this;
    function onStorageChange(ev) {
        if (Spec.is(ev.key) &#x26;&#x26; ev.newValue) {
            self.onOp(new Spec(ev.key), JSON.parse(ev.newValue));
        }
    }
    window.addEventListener(&#x27;storage&#x27;, onStorageChange, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.lstn = {};
    this._id = id;
    this.tails = {};
    this.store = this.options.persistent ?
        window.localStorage : window.sessionStorage;

    this.loadLog();
    this.<span class="apidocCodeKeywordSpan">installListeners</span>();
}

SharedWebStorage.prototype = new Storage();
SharedWebStorage.prototype.isRoot = false;
module.exports = SharedWebStorage;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SharedWebStorage.prototype.loadLog" id="apidoc.element.swarm.SharedWebStorage.prototype.loadLog">
        function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>loadLog
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadLog = function () {
    // scan/sort specs for existing records
    var store = this.store;
    var ti;
    for (var i = 0; i &#x3c; store.length; i++) {
        var key = store.key(i);
        if (!Spec.is(key)) { continue; }
        var spec = new Spec(key);
        if (spec.pattern() !== &#x27;/#!.&#x27;) {
            continue; // ops only
        }
        ti = spec.filter(&#x27;/#&#x27;);
        var tail = this.tails[ti];
        if (!tail) {
            tail = this.tails[ti] = [];
        }
        tail.push(spec.filter(&#x27;!.&#x27;));
    }
    for (ti in this.tails) {
        this.tails[ti].sort();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.options = options || {};
    this.lstn = {};
    this._id = id;
    this.tails = {};
    this.store = this.options.persistent ?
        window.localStorage : window.sessionStorage;

    this.<span class="apidocCodeKeywordSpan">loadLog</span>();
    this.installListeners();
}

SharedWebStorage.prototype = new Storage();
SharedWebStorage.prototype.isRoot = false;
module.exports = SharedWebStorage;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SharedWebStorage.prototype.onOp" id="apidoc.element.swarm.SharedWebStorage.prototype.onOp">
        function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>onOp
        <span class="apidocSignatureSpan">(spec, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onOp = function (spec, value) {
    var ti = spec.filter(&#x27;/#&#x27;);
    var vo = spec.filter(&#x27;!.&#x27;);
    if (!vo.toString()) {
        return; // state, not an op
    }
    var tail = this.tails[ti];
    if (!tail) {
        tail = this.tails[ti] = [];
    } else if (tail.indexOf(vo)!==-1) {
        return; // replay
    }
    tail.push(vo);
    this.emit(spec,value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};


SharedWebStorage.prototype.installListeners = function () {
    var self = this;
    function onStorageChange(ev) {
        if (Spec.is(ev.key) &#x26;&#x26; ev.newValue) {
            self.<span class="apidocCodeKeywordSpan">onOp</span>(new Spec(ev.key), JSON.parse(ev.newValue));
        }
    }
    window.addEventListener(&#x27;storage&#x27;, onStorageChange, false);
};


SharedWebStorage.prototype.loadLog = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SharedWebStorage.prototype.readOps" id="apidoc.element.swarm.SharedWebStorage.prototype.readOps">
        function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>readOps
        <span class="apidocSignatureSpan">(ti, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readOps = function (ti, callback) {
    var tail = this.tails[ti];
    var parsed = null;
    for(var k=0; tail &#x26;&#x26; k&#x3c;tail.length; k++) {
        var spec = tail[k];
        var value = this.store.getItem(ti+spec);
        if (!value) {continue;} // it happens
        parsed = parsed || {};
        parsed[spec] = JSON.parse(value);
    }
    callback(null, parsed);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SharedWebStorage.prototype.readState" id="apidoc.element.swarm.SharedWebStorage.prototype.readState">
        function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>readState
        <span class="apidocSignatureSpan">(spec, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readState = function (spec, callback) {
    spec = new Spec(spec);
    var ti = spec.filter(&#x27;/#&#x27;);
    var state = this.store.getItem(ti);
    callback(null, (state&#x26;&#x26;JSON.parse(state)) || null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SharedWebStorage.prototype.writeOp" id="apidoc.element.swarm.SharedWebStorage.prototype.writeOp">
        function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>writeOp
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wsOp(spec, value, src) {
    var ti = spec.filter(&#x27;/#&#x27;);
    var vm = spec.filter(&#x27;!.&#x27;);
    var tail = this.tails[ti] || (this.tails[ti] = []);
    tail.push(vm);
    var json = JSON.stringify(value);
    this.store.setItem(spec, json);
    if (this.options.trigger) {
        var otherStore = !this.options.persistent ?
            window.localStorage : window.sessionStorage;
        if (!otherStore.getItem(spec)) {
            otherStore.setItem(spec,json);
            otherStore.removeItem(spec,json);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SharedWebStorage.prototype.writeState" id="apidoc.element.swarm.SharedWebStorage.prototype.writeState">
        function <span class="apidocSignatureSpan">swarm.SharedWebStorage.prototype.</span>writeState
        <span class="apidocSignatureSpan">(spec, state, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wsPatch(spec, state, src) {
    var ti = spec.filter(&#x27;/#&#x27;);
    this.store.setItem(ti, JSON.stringify(state));
    var tail = this.tails[ti];
    if (tail) {
        for(var k=0; k&#x3c;tail.length; k++) {
            this.store.removeItem(ti + tail[k]);
        }
        delete this.tails[ti];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.SockJSServerStream" id="apidoc.module.swarm.SockJSServerStream">module swarm.SockJSServerStream</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.SockJSServerStream.SockJSServerStream" id="apidoc.element.swarm.SockJSServerStream.SockJSServerStream">
        function <span class="apidocSignatureSpan">swarm.</span>SockJSServerStream
        <span class="apidocSignatureSpan">(ws)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SockJSStream(ws) {
    var ln = this.lstn = {},
        buf = [];

    if (typeof ws === &#x27;string&#x27;) { // url passed
        throw new Error(&#x27;client-side connections not supported yet&#x27;);
    }
    this.ws = ws;
    if (ws.readyState !== 1/*WebSocket.OPEN*/) {
        this.buf = buf; //will wait for &#x22;open&#x22;
    }
    ws.on(&#x27;close&#x27;, function () { ln.close &#x26;&#x26; ln.close(); });
    ws.on(&#x27;data&#x27;, function (msg) {
        try {
            ln.data &#x26;&#x26; ln.data(msg);
        } catch (ex) {
            console.error(&#x27;message processing fails&#x27;, ex);
            ln.error &#x26;&#x26; ln.error(ex.message);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.SockJSServerStream.prototype" id="apidoc.module.swarm.SockJSServerStream.prototype">module swarm.SockJSServerStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.SockJSServerStream.prototype.on" id="apidoc.element.swarm.SockJSServerStream.prototype.on">
        function <span class="apidocSignatureSpan">swarm.SockJSServerStream.prototype.</span>on
        <span class="apidocSignatureSpan">(evname, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (evname, fn) {
    if (evname in this.lstn) {
        throw new Error(&#x27;not supported&#x27;);
    }
    this.lstn[evname] = fn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.SockJSServerStream.prototype.write" id="apidoc.element.swarm.SockJSServerStream.prototype.write">
        function <span class="apidocSignatureSpan">swarm.SockJSServerStream.prototype.</span>write
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data) {
    if (this.buf) {
        this.buf.push(data.toString());
    } else {
        this.ws.write(data.toString());
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.queue = [];
    if (this.id in AsyncLoopbackConnection.pipes) {
        throw new Error(&#x27;duplicate&#x27;);
    }
    AsyncLoopbackConnection.pipes[this.id] = this;
    var pair = this.pair();
    if (pair &#x26;&#x26; pair.queue.length) {
        pair.<span class="apidocCodeKeywordSpan">write</span>();
    }
}
AsyncLoopbackConnection.pipes = {};

env.streams.loopback = AsyncLoopbackConnection;

AsyncLoopbackConnection.prototype.pair = function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Spec" id="apidoc.module.swarm.Spec">module swarm.Spec</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Spec.Spec" id="apidoc.element.swarm.Spec.Spec">
        function <span class="apidocSignatureSpan">swarm.</span>Spec
        <span class="apidocSignatureSpan">(str, quant)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Spec(str, quant) {
    if (str &#x26;&#x26; str.constructor === Spec) {
        str = str.value;
    } else { // later we assume value has valid format
        str = (str || &#x27;&#x27;).toString();
        if (quant &#x26;&#x26; str.charAt(0) &#x3e;= &#x27;0&#x27;) {
            str = quant + str;
        }
        if (str.replace(Spec.reQTokExt, &#x27;&#x27;)) {
            throw new Error(&#x27;malformed specifier: &#x27; + str);
        }
    }
    this.value = str;
    this.index = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.Map" id="apidoc.element.swarm.Spec.Map">
        function <span class="apidocSignatureSpan">swarm.Spec.</span>Map
        <span class="apidocSignatureSpan">(vec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VersionVectorAsAMap(vec) {
    this.map = {};
    if (vec) {
        this.add(vec);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.as" id="apidoc.element.swarm.Spec.as">
        function <span class="apidocSignatureSpan">swarm.Spec.</span>as
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">as = function (spec) {
    if (!spec) {
        return new Spec(&#x27;&#x27;);
    } else {
        return spec.constructor === Spec ? spec : new Spec(spec);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.base2int" id="apidoc.element.swarm.Spec.base2int">
        function <span class="apidocSignatureSpan">swarm.Spec.</span>base2int
        <span class="apidocSignatureSpan">(base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base2int = function (base) {
    var ret = 0, l = base.match(Spec.re64l);
    for (var shift = 0; l.length; shift += 6) {
        ret += Spec.base64.indexOf(l.pop()) &#x3c;&#x3c; shift;
    }
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return base + &#x27;+&#x27; + this.id;
};

LamportClock.prototype.parseTimestamp = function parse (ts) {
var m = ts.match(Spec.reTokExt);
if (!m) {throw new Error(&#x27;malformed timestamp: &#x27;+ts);}
return {
    seq: Spec.<span class="apidocCodeKeywordSpan">base2int</span>(m[1]),
    process: m[2]
};
};

/** Lamport partial order  imperfect semi-logical*/
LamportClock.prototype.checkTimestamp = function see (ts) {
var parsed = this.parseTimestamp(ts);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.int2base" id="apidoc.element.swarm.Spec.int2base">
        function <span class="apidocSignatureSpan">swarm.Spec.</span>int2base
        <span class="apidocSignatureSpan">(i, padlen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">int2base = function (i, padlen) {
    if (i &#x3c; 0 || i &#x3e;= (1 &#x3c;&#x3c; 30)) {
        throw new Error(&#x27;out of range&#x27;);
    }
    var ret = &#x27;&#x27;, togo = padlen || 5;
    for (; i || (togo &#x3e; 0); i &#x3e;&#x3e;= 6, togo--) {
        ret = Spec.base64.charAt(i &#x26; 63) + ret;
    }
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.seq = 0;
};

LamportClock.prototype.adjustTime = function () {
};

LamportClock.prototype.issueTimestamp = function time () {
var base = Spec.<span class="apidocCodeKeywordSpan">int2base</span>(this.seq++, 5);
return base + &#x27;+&#x27; + this.id;
};

LamportClock.prototype.parseTimestamp = function parse (ts) {
var m = ts.match(Spec.reTokExt);
if (!m) {throw new Error(&#x27;malformed timestamp: &#x27;+ts);}
return {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.is" id="apidoc.element.swarm.Spec.is">
        function <span class="apidocSignatureSpan">swarm.Spec.</span>is
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is = function (str) {
    if (str === null || str === undefined) {
        return false;
    }
    return str.constructor === Spec || &#x27;&#x27; === str.toString().replace(Spec.reQTokExt, &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.emit(spec,value);
};


SharedWebStorage.prototype.installListeners = function () {
    var self = this;
    function onStorageChange(ev) {
        if (Spec.<span class="apidocCodeKeywordSpan">is</span>(ev.key) &#x26;&#x26; ev.newValue) {
            self.onOp(new Spec(ev.key), JSON.parse(ev.newValue));
        }
    }
    window.addEventListener(&#x27;storage&#x27;, onStorageChange, false);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.parseToken" id="apidoc.element.swarm.Spec.parseToken">
        function <span class="apidocSignatureSpan">swarm.Spec.</span>parseToken
        <span class="apidocSignatureSpan">(token_body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseToken = function (token_body) {
    Spec.reTokExt.lastIndex = -1;
    var m = Spec.reTokExt.exec(token_body);
    if (!m) {
        return null;
    }
    return {bare: m[1], ext: m[2] || &#x27;swarm&#x27;}; // FIXME not generic
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.pattern" id="apidoc.element.swarm.Spec.pattern">
        function <span class="apidocSignatureSpan">swarm.Spec.</span>pattern
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pattern = function (spec) {
    return spec.toString().replace(Spec.reQTokExt, &#x27;$1&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// scan/sort specs for existing records
var store = this.store;
var ti;
for (var i = 0; i &#x3c; store.length; i++) {
    var key = store.key(i);
    if (!Spec.is(key)) { continue; }
    var spec = new Spec(key);
    if (spec.<span class="apidocCodeKeywordSpan">pattern</span>() !== &#x27;/#!.&#x27;) {
        continue; // ops only
    }
    ti = spec.filter(&#x27;/#&#x27;);
    var tail = this.tails[ti];
    if (!tail) {
        tail = this.tails[ti] = [];
    }
...</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Spec.Map" id="apidoc.module.swarm.Spec.Map">module swarm.Spec.Map</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Spec.Map.Map" id="apidoc.element.swarm.Spec.Map.Map">
        function <span class="apidocSignatureSpan">swarm.Spec.</span>Map
        <span class="apidocSignatureSpan">(vec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VersionVectorAsAMap(vec) {
    this.map = {};
    if (vec) {
        this.add(vec);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Spec.Map.prototype" id="apidoc.module.swarm.Spec.Map.prototype">module swarm.Spec.Map.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Spec.Map.prototype.add" id="apidoc.element.swarm.Spec.Map.prototype.add">
        function <span class="apidocSignatureSpan">swarm.Spec.Map.prototype.</span>add
        <span class="apidocSignatureSpan">(versionVector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (versionVector) {
    var vec = new Spec(versionVector, &#x27;!&#x27;), tok;
    while (undefined !== (tok = vec.token(&#x27;!&#x27;))) {
        var time = tok.bare, source = tok.ext || &#x27;swarm&#x27;;
        if (time &#x3e; (this.map[source] || &#x27;&#x27;)) {
            this.map[source] = time;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.Map.prototype.covers" id="apidoc.element.swarm.Spec.Map.prototype.covers">
        function <span class="apidocSignatureSpan">swarm.Spec.Map.prototype.</span>covers
        <span class="apidocSignatureSpan">(version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">covers = function (version) {
    Spec.reTokExt.lastIndex = 0;
    var m = Spec.reTokExt.exec(version);
    var ts = m[1], src = m[2] || &#x27;swarm&#x27;;
    return ts &#x3c;= (this.map[src] || &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.Map.prototype.maxTs" id="apidoc.element.swarm.Spec.Map.prototype.maxTs">
        function <span class="apidocSignatureSpan">swarm.Spec.Map.prototype.</span>maxTs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxTs = function () {
    var ts = null,
        map = this.map;
    for (var src in map) {
        if (!ts || ts &#x3c; map[src]) {
            ts = map[src];
        }
    }
    return ts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.Map.prototype.toString" id="apidoc.element.swarm.Spec.Map.prototype.toString">
        function <span class="apidocSignatureSpan">swarm.Spec.Map.prototype.</span>toString
        <span class="apidocSignatureSpan">(trim)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (trim) {
    trim = trim || {top: 10, rot: &#x27;0&#x27;};
    var top = trim.top || 10,
        rot = &#x27;!&#x27; + (trim.rot || &#x27;0&#x27;),
        ret = [],
        map = this.map;
    for (var src in map) {
        ret.push(&#x27;!&#x27; + map[src] + (src === &#x27;swarm&#x27; ? &#x27;&#x27; : &#x27;+&#x27; + src));
    }
    ret.sort().reverse();
    while (ret.length &#x3e; top || ret[ret.length - 1] &#x3c;= rot) {
        ret.pop();
    }
    return ret.join(&#x27;&#x27;) || &#x27;!0&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

AsyncLoopbackConnection.prototype.receive = function (string) {
this.lstn.data &#x26;&#x26; this.lstn.data(string);
};

AsyncLoopbackConnection.prototype.write = function (obj) {
var self = this;
obj &#x26;&#x26; self.queue.push(obj.<span class="apidocCodeKeywordSpan">toString</span>());
setTimeout(function () {
    var pair = self.pair();
    if (!pair) {
        return;
    }
    while (self.queue.length) {
        pair.receive(self.queue.shift());
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Spec.prototype" id="apidoc.module.swarm.Spec.prototype">module swarm.Spec.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.add" id="apidoc.element.swarm.Spec.prototype.add">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>add
        <span class="apidocSignatureSpan">(spec, quant)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (spec, quant) {
    if (spec.constructor !== Spec) {
        spec = new Spec(spec, quant);
    }
    return new Spec(this.value + spec.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.filter" id="apidoc.element.swarm.Spec.prototype.filter">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>filter
        <span class="apidocSignatureSpan">(quants)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (quants) {
    var filterfn = //typeof(quants)===&#x27;function&#x27; ? quants :
                function (token, quant) {
                    return quants.indexOf(quant) !== -1 ? token : &#x27;&#x27;;
                };
    return new Spec(this.value.replace(Spec.reQTokExt, filterfn));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function htmlesc (text) {
return text;
}

/// range/ids -???  first, all   then...

function rtf2txt (rtf) {
var txt = rtf.<span class="apidocCodeKeywordSpan">filter</span>(function(o){ return o &#x26;&#x26; o.constructor===String });
return txt.join(&#x27;&#x27;);
}

function meta2attstr (meta) {
var ret = [], styles={}, classes={}, atts={}, structs={};
var kv = {&#x27;:&#x27;:styles,&#x27;_&#x27;:classes,&#x27;=&#x27;:atts,&#x27;s&#x27;:structs};
var re_meta = /^(\w[\w_\-]*)([:_=]?)$/, m;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.fits" id="apidoc.element.swarm.Spec.prototype.fits">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>fits
        <span class="apidocSignatureSpan">(specFilter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fits = function (specFilter) {
    var myToks = this.value.match(Spec.reQTokExt);
    var filterToks = specFilter.match(Spec.reQTokExt), tok;
    while (tok=filterToks.pop()) {
        if (myToks.indexOf(tok) === -1) {
            return false;
        }
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.get" id="apidoc.element.swarm.Spec.prototype.get">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>get
        <span class="apidocSignatureSpan">(quant)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function specGet(quant) {
    var i = this.value.indexOf(quant);
    if (i === -1) {
        return &#x27;&#x27;;
    }
    Spec.reQTokExt.lastIndex = i;
    var m = Spec.reQTokExt.exec(this.value);
    return m &#x26;&#x26; m[2];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var swarmHost = new Swarm.Host(&#x27;unique_client_id&#x27;);

// 2. connect to your server
swarmHost.connect(&#x27;ws://localhost:8000/&#x27;);

// 3.a. create an object
var someMouse = new Mouse();
// OR swarmHost.<span class="apidocCodeKeywordSpan">get</span>(&#x27;/Mouse&#x27;);
// OR new Mouse({x:1, y:2});

// 4.a. a locally created object may be touched immediately
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.has" id="apidoc.element.swarm.Spec.prototype.has">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>has
        <span class="apidocSignatureSpan">(quant)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function specHas(quant) {
    if (quant.length===1) {
        return this.value.indexOf(quant) !== -1;
    } else {
        var toks = this.value.match(Spec.reQTokExt);
        return toks.indexOf(quant) !== -1;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.id" id="apidoc.element.swarm.Spec.prototype.id">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>id
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">id = function () { return this.get(&#x27;#&#x27;); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.isEmpty" id="apidoc.element.swarm.Spec.prototype.isEmpty">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
    return this.value===&#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.op" id="apidoc.element.swarm.Spec.prototype.op">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>op
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">op = function () { return this.get(&#x27;.&#x27;); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
    // this will be triggered by every state change, be it
    // local or remote
    console.log(&#x27;event: &#x27;, spec.<span class="apidocCodeKeywordSpan">op</span>(), val);
    // outputs:
    // set {x:3, y:4}
});
```

### Creating a simple NodeJS sync server
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.pattern" id="apidoc.element.swarm.Spec.prototype.pattern">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>pattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pattern = function () {
    return Spec.pattern(this.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// scan/sort specs for existing records
var store = this.store;
var ti;
for (var i = 0; i &#x3c; store.length; i++) {
    var key = store.key(i);
    if (!Spec.is(key)) { continue; }
    var spec = new Spec(key);
    if (spec.<span class="apidocCodeKeywordSpan">pattern</span>() !== &#x27;/#!.&#x27;) {
        continue; // ops only
    }
    ti = spec.filter(&#x27;/#&#x27;);
    var tail = this.tails[ti];
    if (!tail) {
        tail = this.tails[ti] = [];
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.set" id="apidoc.element.swarm.Spec.prototype.set">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>set
        <span class="apidocSignatureSpan">(spec, quant)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function specSet(spec, quant) {
    var ret = new Spec(spec, quant);
    var m;
    Spec.reQTokExt.lastIndex = 0;
    while (null !== (m = Spec.reQTokExt.exec(this.value))) {
        if (!ret.has(m[1])) {
            ret = ret.add(m[0]);
        }
    }
    return ret.sort();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// 3.a. create an object
var someMouse = new Mouse();
// OR swarmHost.get(&#x27;/Mouse&#x27;);
// OR new Mouse({x:1, y:2});

// 4.a. a locally created object may be touched immediately
someMouse.<span class="apidocCodeKeywordSpan">set</span>({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.on(&#x27;init&#x27;, function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.sort" id="apidoc.element.swarm.Spec.prototype.sort">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>sort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function () {
    function Q(a, b) {
        var qa = a.charAt(0), qb = b.charAt(0), q = Spec.quants;
        return (q.indexOf(qa) - q.indexOf(qb)) || (a &#x3c; b);
    }

    var split = this.value.match(Spec.reQTokExt);
    return new Spec(split ? split.sort(Q).join(&#x27;&#x27;) : &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var tail = this.tails[ti];
    if (!tail) {
        tail = this.tails[ti] = [];
    }
    tail.push(spec.filter(&#x27;!.&#x27;));
}
for (ti in this.tails) {
    this.tails[ti].<span class="apidocCodeKeywordSpan">sort</span>();
}
};


SharedWebStorage.prototype.writeOp = function wsOp(spec, value, src) {
var ti = spec.filter(&#x27;/#&#x27;);
var vm = spec.filter(&#x27;!.&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.source" id="apidoc.element.swarm.Spec.prototype.source">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>source
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">source = function () { return this.token(&#x27;!&#x27;).ext; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.toString" id="apidoc.element.swarm.Spec.prototype.toString">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () { return this.value; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

AsyncLoopbackConnection.prototype.receive = function (string) {
this.lstn.data &#x26;&#x26; this.lstn.data(string);
};

AsyncLoopbackConnection.prototype.write = function (obj) {
var self = this;
obj &#x26;&#x26; self.queue.push(obj.<span class="apidocCodeKeywordSpan">toString</span>());
setTimeout(function () {
    var pair = self.pair();
    if (!pair) {
        return;
    }
    while (self.queue.length) {
        pair.receive(self.queue.shift());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.tok" id="apidoc.element.swarm.Spec.prototype.tok">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>tok
        <span class="apidocSignatureSpan">(quant)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function specGet(quant) {
    var i = this.value.indexOf(quant);
    if (i === -1) { return &#x27;&#x27;; }
    Spec.reQTokExt.lastIndex = i;
    var m = Spec.reQTokExt.exec(this.value);
    return m &#x26;&#x26; m[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.token" id="apidoc.element.swarm.Spec.prototype.token">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>token
        <span class="apidocSignatureSpan">(quant)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token = function (quant) {
    var at = quant ? this.value.indexOf(quant, this.index) : this.index;
    if (at === -1) {
        return undefined;
    }
    Spec.reQTokExt.lastIndex = at;
    var m = Spec.reQTokExt.exec(this.value);
    this.index = Spec.reQTokExt.lastIndex;
    if (!m) {
        return undefined;
    }
    return {quant: m[1], body: m[2], bare: m[3], ext: m[4]};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    state: function (spec, text, src) {
        console.log(&#x27;what?&#x27;);
    }
},
ops: {
    insert: function (spec, ins, src) {
        var w1 = [], w4 = [];
        var vt = spec.<span class="apidocCodeKeywordSpan">token</span>(&#x27;!&#x27;), v = vt.bare;
        var ts = v.substr(0, 5), seq = v.substr(5) || &#x27;00&#x27;;
        var seqi = Spec.base2int(seq);
        for (var i = 0; i &#x3c; this.weave.length; i++) {
            var id = this.ids[i];
            w1.push(this.weave.charAt(i));
            w4.push(id);
            if (id in ins) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.type" id="apidoc.element.swarm.Spec.prototype.type">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">type = function () { return this.get(&#x27;/&#x27;); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.typeid" id="apidoc.element.swarm.Spec.prototype.typeid">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>typeid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeid = function () { return this.filter(&#x27;/#&#x27;); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Spec.prototype.version" id="apidoc.element.swarm.Spec.prototype.version">
        function <span class="apidocSignatureSpan">swarm.Spec.prototype.</span>version
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">version = function () { return this.get(&#x27;!&#x27;); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    this.weave = w1.join(&#x27;&#x27;);
    this.ids = w4;
    this.rebuild();
},
remove: function (spec, rm, src) {
    var w1 = [], w4 = [];
    var v = spec.<span class="apidocCodeKeywordSpan">version</span>();
    for (var i = 0; i &#x3c; this.weave.length; i++) {
        w1.push(this.weave.charAt(i));
        w4.push(this.ids[i]);
        if (this.ids[i] in rm) {
            w1.push(&#x27;\u0008&#x27;);
            w4.push(v);
        }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Storage" id="apidoc.module.swarm.Storage">module swarm.Storage</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Storage.Storage" id="apidoc.element.swarm.Storage.Storage">
        function <span class="apidocSignatureSpan">swarm.</span>Storage
        <span class="apidocSignatureSpan">(async)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Storage(async) {
    this.async = !!async || false;
    this.states = {};
    this.tails = {};
    this.counts = {};
    this._host = null;
    // many implementations do not push changes
    // so there are no listeners
    this.lstn = null;
    this._id = &#x27;some_storage&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Storage.prototype" id="apidoc.module.swarm.Storage.prototype">module swarm.Storage.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.swarm.Storage.prototype.anyOp" id="apidoc.element.swarm.Storage.prototype.anyOp">
        function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>anyOp
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anyOp = function (spec, value, src) {
    var self = this;
    var ti = spec.filter(&#x27;/#&#x27;);
    this.writeOp(spec, value, function (err) {
        if (err) {
            this.close(err); // the log is sacred
        }
    });
    self.counts[ti] = self.counts[ti] || 0;
    if (++self.counts[ti]&#x3e;self.MAX_LOG_SIZE) {
        // The storage piggybacks on the object&#x27;s state/log handling logic
        // First, it adds an op to the log tail unless the log is too long...
        // ...otherwise it sends back a subscription effectively requesting
        // the state, on state arrival zeroes the tail.
        delete self.counts[ti];
        src.deliver(spec.set(&#x27;.reon&#x27;), &#x27;!0.init&#x27;, self);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Storage.prototype.close" id="apidoc.element.swarm.Storage.prototype.close">
        function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
    if (callback) { callback(); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }, 1);
};

AsyncLoopbackConnection.prototype.close = function () {
    delete AsyncLoopbackConnection.pipes[this.id];
    var pair = this.pair();
    pair &#x26;&#x26; pair.<span class="apidocCodeKeywordSpan">close</span>();
    this.lstn.close &#x26;&#x26; this.lstn.close();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Storage.prototype.deliver" id="apidoc.element.swarm.Storage.prototype.deliver">
        function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>deliver
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deliver = function (spec, value, src) {
    var ret;
    switch (spec.op()) {
        // A storage is always an &#x22;uplink&#x22; so it never receives reon, reoff.
    case &#x27;on&#x27;:
        ret = this.on(spec, value, src); break;
    case &#x27;off&#x27;:
        ret = this.off(spec, value, src); break;
    case &#x27;init&#x27;:
        if (value._version) { // state
            ret = this.init(spec, value, src);
        } else { // patch
            var ti = spec.filter(&#x27;/#&#x27;);
            var specs = [], s;
            for(s in value._tail) {  specs.push(s);  }
            specs.sort();
            while (s=specs.pop()) {
                ret = this.anyOp( ti.add(s), value._tail[s], src);
            }
        }
        break;
    default:
        ret = this.anyOp(spec, value, src);
    }
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.callbacks===null) { return; }
var that = this.owner || src;
for(var i=0; i&#x3c;this.callbacks.length; i++) {
    var cb = this.callbacks[i];
    if (cb.constructor===Function) {
        cb.call(that,spec,value,src);
    } else {
        cb.<span class="apidocCodeKeywordSpan">deliver</span>(spec,value,src);
    }
}
};

ProxyListener.prototype.on = function (callback) {
if (this.callbacks===null) { this.callbacks = []; }
this.callbacks.push(callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Storage.prototype.emit" id="apidoc.element.swarm.Storage.prototype.emit">
        function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>emit
        <span class="apidocSignatureSpan">(spec, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (spec, value) {
    var ti = spec.filter(&#x27;/#&#x27;);
    var ln = this.lstn[ti];
    if (!ln) {return;}
    if (ln &#x26;&#x26; ln.constructor===Array) {
        for(var i=0; ln &#x26;&#x26; i&#x3c;ln.length; i++) {
            var l = ln[i];
            if (l &#x26;&#x26; l.constructor===Function) {
                l(spec,value,this);
            } else if (l &#x26;&#x26; l.deliver) {
                l.deliver(spec,value,this);
            }
        }
    } else if (ln &#x26;&#x26; ln.deliver) {
        ln.deliver(spec,value,this);
    } else if (ln &#x26;&#x26; ln.constructor===Function) {
        ln(spec,value,this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tail = this.tails[ti];
if (!tail) {
    tail = this.tails[ti] = [];
} else if (tail.indexOf(vo)!==-1) {
    return; // replay
}
tail.push(vo);
this.<span class="apidocCodeKeywordSpan">emit</span>(spec,value);
};


SharedWebStorage.prototype.installListeners = function () {
var self = this;
function onStorageChange(ev) {
    if (Spec.is(ev.key) &#x26;&#x26; ev.newValue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Storage.prototype.init" id="apidoc.element.swarm.Storage.prototype.init">
        function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>init
        <span class="apidocSignatureSpan">(spec, state, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (spec, state, src) {
    var ti = spec.filter(&#x27;/#&#x27;), self=this;
    var saveops = this.tails[ti];
    this.writeState(spec, state, function (err) {
        if (err) {
            console.error(&#x27;state dump error:&#x27;, err);
        } else {
            var tail = self.tails[ti] || (self.tails[ti] = {});
            for(var op in saveops) { // OK, let&#x27;s keep that in the log
                tail[op] = saveops[op];
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Storage.prototype.off" id="apidoc.element.swarm.Storage.prototype.off">
        function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>off
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (spec, value, src) {
    if (!this.lstn) {
        return;
    }
    var ti = spec.filter(&#x27;/#&#x27;);
    var ls = this.lstn[ti];
    if (ls === src) {
        delete this.lstn[ti];
    } else if (ls &#x26;&#x26; ls.constructor === Array) {
        var cleared = ls.filter(function (v) {return v !== src;});
        if (cleared.length) {
            this.lstn[ti] = cleared;
        } else {
            delete this.lstn[ti];
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Unsubscribe from collections entries&#x27; events
 * @param {function(*)} callback
 * @this Set|Vector
 */
offObjectEvent: function (callback) {
    this._proxy.<span class="apidocCodeKeywordSpan">off</span>(callback);
},

/**
 * Waits for collection to receive state from cache or uplink and then invokes passed callback
 *
 * @param {function()} callback
 * @this Set|Vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Storage.prototype.on" id="apidoc.element.swarm.Storage.prototype.on">
        function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>on
        <span class="apidocSignatureSpan">(spec, base, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function storageOn(spec, base, src) {
    var ti = spec.filter(&#x27;/#&#x27;);

    if (this.lstn) {
        var ls = this.lstn[ti];
        if (ls === undefined) {
            ls = src;
        } else if (ls !== src) {
            if (ls.constructor !== Array) {
                ls = [ls];
            }
            ls.push(src);
        }
        this.lstn[ti] = ls;
    }

    var self = this;
    var state;
    var tail;

    function sendResponse() {
        if (!state) {
            if (self.isRoot) {// &#x26;&#x26; !spec.token(&#x27;#&#x27;).ext) {
                // make 0 state for a global object TODO move to Host
                state = {_version: &#x27;!0&#x27;};
            }
        }
        if (tail) {
            if (!state) {state={};}
            state._tail = state._tail || {};
            for (var s in tail) {
                state._tail[s] = tail[s];
            }
        }
        var tiv = ti.add(spec.version(), &#x27;!&#x27;);
        if (state) {
            src.deliver(tiv.add(&#x27;.init&#x27;), state, self);
            src.deliver(tiv.add(&#x27;.reon&#x27;), Syncable.stateVersionVector(state), self); // TODO and the tail
        } else {
            src.deliver(tiv.add(&#x27;.reon&#x27;), &#x27;!0&#x27;, self); // state unknown
        }
    }

    this.readState(ti, function (err, s) {
        state = s || null;
        if (tail !== undefined) {
            sendResponse();
        }
    });

    this.readOps(ti, function (err, t) {
        tail = t || null;
        if (state !== undefined) {
            sendResponse();
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Storage.prototype.readOps" id="apidoc.element.swarm.Storage.prototype.readOps">
        function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>readOps
        <span class="apidocSignatureSpan">(ti, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readOps = function (ti, callback) {
    var tail = JSON.parse(this.tails[ti] || null);
    callback(null, tail);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Storage.prototype.readState" id="apidoc.element.swarm.Storage.prototype.readState">
        function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>readState
        <span class="apidocSignatureSpan">(ti, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readState = function (ti, callback) {
    var state = JSON.parse(this.states[ti] || null);

    function sendResponse() {
        callback(null, state);
    }

    // may force async behavior
    this.async ? setTimeout(sendResponse, 1) : sendResponse();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Storage.prototype.writeOp" id="apidoc.element.swarm.Storage.prototype.writeOp">
        function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>writeOp
        <span class="apidocSignatureSpan">(spec, value, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeOp = function (spec, value, cb) {
    var ti = spec.filter(&#x27;/#&#x27;);
    var vm = spec.filter(&#x27;!.&#x27;);
    var tail = this.tails[ti] || (this.tails[ti] = {});
    if (tail[vm]) {
        console.error(&#x27;op replay @storage&#x27;+vm+new Error().stack);
    }
    tail[vm] = JSON.stringify(value);
    cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Storage.prototype.writeState" id="apidoc.element.swarm.Storage.prototype.writeState">
        function <span class="apidocSignatureSpan">swarm.Storage.prototype.</span>writeState
        <span class="apidocSignatureSpan">(spec, state, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeState = function (spec, state, cb) {
    var ti = spec.filter(&#x27;/#&#x27;);
    this.states[ti] = JSON.stringify(state);
    // tail is zeroed on state flush
    delete this.tails[ti];
    // callback is mandatory
    cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Syncable" id="apidoc.module.swarm.Syncable">module swarm.Syncable</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Syncable.Syncable" id="apidoc.element.swarm.Syncable.Syncable">
        function <span class="apidocSignatureSpan">swarm.</span>Syncable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Syncable() {
    // listeners represented as objects that have deliver() method
    this._lstn = [&#x27;,&#x27;]; // we unshift() uplink listeners and push() downlinks
    // ...so _lstn is like [server1, server2, storage, &#x27;,&#x27;, view, listener]
    // The most correct way to specify a version is the version vector,
    // but that one may consume more space than the data itself in some cases.
    // Hence, _version is not a fully specified version vector (see version()
    // instead). _version is essentially is the greatest operation timestamp
    // (Lamport-like, i.e. &#x22;time+source&#x22;), sometimes amended with additional
    // timestamps. Its main features:
    // (1) changes once the object&#x27;s state changes
    // (2) does it monotonically (in the alphanum order sense)
    this._version = &#x27;&#x27;;
    // make sense of arguments
    var args = Array.prototype.slice.call(arguments);
    this._host = (args.length &#x26;&#x26; args[args.length - 1]._type === &#x27;Host&#x27;) ?
            args.pop() : env.localhost;
    if (Spec.is(args[0])) {
        this._id = new Spec(args.shift()).id() || this._host.time();
    } else if (typeof(args[0]) === &#x27;string&#x27;) {
        this._id = args.shift(); // TODO format
    } else {
        this._id = this._host.time();
        this._version = &#x27;!0&#x27;; // may apply state in the constructor, see Model
    }
    //var state = args.length ? args.pop() : (fresh?{}:undefined);
    // register with the host
    var doubl = this._host.register(this);
    if (doubl !== this) { return doubl; }
    // locally created objects get state immediately
    // (while external-id objects need to query uplinks)
<span class="apidocCodeCommentSpan">    /*if (fresh &#x26;&#x26; state) {
     state._version = &#x27;!&#x27;+this._id;
     var pspec = this.spec().add(state._version).add(&#x27;.init&#x27;);
     this.deliver(pspec,state,this._host);
     }*/
</span>    this.reset();
    // find uplinks, subscribe
    this.checkUplink();
    // TODO inplement state push
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable._super" id="apidoc.element.swarm.Syncable._super">
        function <span class="apidocSignatureSpan">swarm.Syncable.</span>_super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Syncable() {
    // listeners represented as objects that have deliver() method
    this._lstn = [&#x27;,&#x27;]; // we unshift() uplink listeners and push() downlinks
    // ...so _lstn is like [server1, server2, storage, &#x27;,&#x27;, view, listener]
    // The most correct way to specify a version is the version vector,
    // but that one may consume more space than the data itself in some cases.
    // Hence, _version is not a fully specified version vector (see version()
    // instead). _version is essentially is the greatest operation timestamp
    // (Lamport-like, i.e. &#x22;time+source&#x22;), sometimes amended with additional
    // timestamps. Its main features:
    // (1) changes once the object&#x27;s state changes
    // (2) does it monotonically (in the alphanum order sense)
    this._version = &#x27;&#x27;;
    // make sense of arguments
    var args = Array.prototype.slice.call(arguments);
    this._host = (args.length &#x26;&#x26; args[args.length - 1]._type === &#x27;Host&#x27;) ?
            args.pop() : env.localhost;
    if (Spec.is(args[0])) {
        this._id = new Spec(args.shift()).id() || this._host.time();
    } else if (typeof(args[0]) === &#x27;string&#x27;) {
        this._id = args.shift(); // TODO format
    } else {
        this._id = this._host.time();
        this._version = &#x27;!0&#x27;; // may apply state in the constructor, see Model
    }
    //var state = args.length ? args.pop() : (fresh?{}:undefined);
    // register with the host
    var doubl = this._host.register(this);
    if (doubl !== this) { return doubl; }
    // locally created objects get state immediately
    // (while external-id objects need to query uplinks)
<span class="apidocCodeCommentSpan">    /*if (fresh &#x26;&#x26; state) {
     state._version = &#x27;!&#x27;+this._id;
     var pspec = this.spec().add(state._version).add(&#x27;.init&#x27;);
     this.deliver(pspec,state,this._host);
     }*/
</span>    this.reset();
    // find uplinks, subscribe
    this.checkUplink();
    // TODO inplement state push
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.addReaction" id="apidoc.element.swarm.Syncable.addReaction">
        function <span class="apidocSignatureSpan">swarm.Syncable.</span>addReaction
        <span class="apidocSignatureSpan">(op, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addReaction = function (op, fn) {
    var reactions = this.prototype._reactions;
    var list = reactions[op];
    list || (list = reactions[op] = []);
    list.push(fn);
    return {op: op, fn: fn};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.extend" id="apidoc.element.swarm.Syncable.extend">
        function <span class="apidocSignatureSpan">swarm.Syncable.</span>extend
        <span class="apidocSignatureSpan">(fn, own)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (fn, own) {
    var parent = this, fnid;
    if (fn.constructor !== Function) {
        var id = fn.toString();
        fn = function SomeSyncable() {
            return parent.apply(this, arguments);
        };
        fnid = id; // if only it worked
    } else { // please call Syncable.constructor.apply(this,args) in your constructor
        fnid = fnname(fn);
    }

    // inheritance trick from backbone.js
    var SyncProto = function () {
        this.constructor = fn;
        this._neutrals = {};
        this._ops = {};
        this._reactions = {};

        var event,
            name;
        if (parent._pt) {
            //copy _neutrals &#x26; _ops from parent
            for (event in parent._pt._neutrals) {
                this._neutrals[event] = parent._pt._neutrals[event];
            }
            for (event in parent._pt._ops) {
                this._ops[event] = parent._pt._ops[event];
            }
        }

        // &#x22;Methods&#x22; are serialized, logged and delivered to replicas
        for (name in own.ops || {}) {
            if (Syncable.reMethodName.test(name)) {
                this._ops[name] = own.ops[name];
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid op name:&#x27;,name);
            }
        }

        // &#x22;Neutrals&#x22; don&#x27;t change the state
        for (name in own.neutrals || {}) {
            if (Syncable.reMethodName.test(name)) {
                this._neutrals[name] = own.neutrals[name];
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid neutral op name:&#x27;,name);
            }
        }

        // &#x22;Remotes&#x22; are serialized and sent upstream (like RPC calls)
        for (name in own.remotes || {}) {
            if (Syncable.reMethodName.test(name)) {
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid rpc name:&#x27;,name);
            }
        }

        // add mixins
        (own.mixins || []).forEach(function (mixin) {
            for (var name in mixin) {
                this[name] = mixin[name];
            }
        }, this);

        // add other members
        for (name in own) {
            if (Syncable.reMethodName.test(name)) {
                var memberType = own[name].constructor;
                if (memberType === Function) { // non-op method
                    // these must change state ONLY by invoking ops
                    this[name] = own[name];
                } else if (memberType===String || memberType===Number) {
                    this[name] = own[name]; // some static constant, OK
                } else if (name in Syncable.memberClasses) {
                    // see above
                    continue;
                } else {
                    console.warn(&#x27;invalid member:&#x27;,name,memberType);
                }
            } else {
                console.warn(&#x27;invalid member name:&#x27;,name);
            }
        }

        // add reactions
        for (name in own.reactions || {}) {
            var reaction = own.reactions[name];
            if (!reaction) { continue; }

            switch (typeof reaction) {
            case &#x27;function&#x27;:
                // handler-function
                this._reactions[name] = [reaction];
                break;
            case &#x27;string&#x27;:
                // handler-method name
                this._reactions[name] = [this[name]];
                break;
            default:
                if (reaction.constructor === Array) {
                    // array of handlers
                    this._reactions[name] = reaction.map(function (item) {
                        switch (typeof item) {
                        case &#x27;function&#x27;:
                            return item;
                        case &#x27;string&#x27;:
                            return this[item];
                        default:
                            throw new Error(&#x27;unexpected reaction type&#x27;);
                        }
                    }, this);
                } else {
                    throw new Error(&#x27;unex ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
these demos are normally online at http://ppyr.us and http://ppyr.us:8001/demo3/index.html respectively.

### Creating your first simple synchronized type

```js
var Swarm = require(&#x27;swarm&#x27;);

var Mouse = Swarm.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;Mouse&#x27;, {
    defaults: {
        name: &#x27;Mickey&#x27;,
        x: 0,
        y: 0
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.isOpSink" id="apidoc.element.swarm.Syncable.isOpSink">
        function <span class="apidocSignatureSpan">swarm.Syncable.</span>isOpSink
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isOpSink = function (obj) {
    if (!obj) { return false; }
    if (obj.constructor === Function) { return true; }
    if (obj.deliver &#x26;&#x26; obj.deliver.constructor === Function) { return true; }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.listenerEquals" id="apidoc.element.swarm.Syncable.listenerEquals">
        function <span class="apidocSignatureSpan">swarm.Syncable.</span>listenerEquals
        <span class="apidocSignatureSpan">(ln, other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerEquals = function (ln, other) {
    return !!ln &#x26;&#x26; ((ln === other) ||
        (ln._src &#x26;&#x26; ln._src === other) ||
        (ln.fn &#x26;&#x26; ln.fn === other) ||
        (ln.sink &#x26;&#x26; ln.sink === other));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.removeReaction" id="apidoc.element.swarm.Syncable.removeReaction">
        function <span class="apidocSignatureSpan">swarm.Syncable.</span>removeReaction
        <span class="apidocSignatureSpan">(handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeReaction = function (handle) {
    var op = handle.op,
        fn = handle.fn,
        list = this.prototype._reactions[op],
        i = list.indexOf(fn);
    if (i === -1) {
        throw new Error(&#x27;reaction unknown&#x27;);
    }
    list[i] = undefined; // such a peculiar pattern not to mess up out-of-callback removal
    while (list.length &#x26;&#x26; !list[list.length - 1]) {
        list.pop();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.stateVersionVector" id="apidoc.element.swarm.Syncable.stateVersionVector">
        function <span class="apidocSignatureSpan">swarm.Syncable.</span>stateVersionVector
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stateVersionVector(state) {
    var op,
        map = new Spec.Map( (state._version||&#x27;!0&#x27;) + (state._vector || &#x27;&#x27;) );
    if (state._oplog) {
        for (op in state._oplog) {
            map.add(op);
        }
    }
    if (state._tail) {
        for (op in state._tail) {
            map.add(op);
        }
    }
    return map.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Syncable.prototype" id="apidoc.module.swarm.Syncable.prototype">module swarm.Syncable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.acl" id="apidoc.element.swarm.Syncable.prototype.acl">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>acl
        <span class="apidocSignatureSpan">(spec, val, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acl = function (spec, val, src) {
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.apply" id="apidoc.element.swarm.Syncable.prototype.apply">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>apply
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (values) {
    for (var key in values) {
        if (Syncable.reFieldName.test(key)) { // skip special fields
            var def = this.constructor.defaults[key];
            this[key] = def &#x26;&#x26; def.type ?
                new def.type(values[key]) : values[key];
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

WebSocketStream.prototype.on = function (evname, fn) {
    if (evname in this.lstn) {
        var self = this,
            prev_fn = this.lstn[evname];
        this.lstn[evname] = function () {
            prev_fn.<span class="apidocCodeKeywordSpan">apply</span>(self, arguments);
            fn.apply(self, arguments);
        };
    } else {
        this.lstn[evname] = fn;
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.callReactions" id="apidoc.element.swarm.Syncable.prototype.callReactions">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>callReactions
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callReactions = function (spec, value, src) {
    var superReactions = syncProto._super.callReactions;
    if (&#x27;function&#x27; === typeof superReactions) {
        superReactions.call(this, spec, value, src);
    }
    var r = syncProto._reactions[spec.op()];
    if (r) {
        r.constructor !== Array &#x26;&#x26; (r = [r]);
        for (var i = 0; i &#x3c; r.length; i++) {
            r[i] &#x26;&#x26; r[i].call(this, spec, value, src);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.checkUplink" id="apidoc.element.swarm.Syncable.prototype.checkUplink">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>checkUplink
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkUplink = function () {
    var new_uplinks = this._host.getSources(this.spec()).slice(),
        up, self = this;
    // the plan is to eliminate extra subscriptions and to
    // establish missing ones; that only affects outbound subs
    for (var i = 0; i &#x3c; this._lstn.length &#x26;&#x26; this._lstn[i] != &#x27;,&#x27;; i++) {
        up = this._lstn[i];
        if (!up) {
            continue;
        }
        up._src &#x26;&#x26; (up = up._src); // unready
        var up_idx = new_uplinks.indexOf(up);
        if (up_idx === -1) { // don&#x27;t need this uplink anymore
            up.deliver(this.newEventSpec(&#x27;off&#x27;), &#x27;&#x27;, this);
        } else {
            new_uplinks[up_idx] = undefined;
        }
    }
    // subscribe to the new
    for (i = 0; i &#x3c; new_uplinks.length; i++) {
        up = new_uplinks[i];
        if (!up) {
            continue;
        }
        var onspec = this.newEventSpec(&#x27;on&#x27;);
        this._lstn.unshift({
            _op: &#x27;reon&#x27;,
            _src: up,
            deliver: function (spec, base, src) {
                if (spec.version() !== onspec.version()) {
                    return;
                } // not mine

                var i = self.getListenerIndex(this);
                self._lstn[i] = up;
            }
        });
        up.deliver(onspec, this.version().toString(), this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.close" id="apidoc.element.swarm.Syncable.prototype.close">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    var l = this._lstn,
        s = this.spec(),
        uplink;

    this._id = null; // no id - no object; prevent relinking
    while ((uplink = l.shift()) &#x26;&#x26; uplink !== &#x27;,&#x27;) {
        uplink.off(s, null, this);
    }
    while (l.length) {
        l.pop().deliver(s.set(&#x27;.reoff&#x27;), null, this);
    }
    this._host.unregister(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }, 1);
};

AsyncLoopbackConnection.prototype.close = function () {
    delete AsyncLoopbackConnection.pipes[this.id];
    var pair = this.pair();
    pair &#x26;&#x26; pair.<span class="apidocCodeKeywordSpan">close</span>();
    this.lstn.close &#x26;&#x26; this.lstn.close();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.constructor" id="apidoc.element.swarm.Syncable.prototype.constructor">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Syncable() {
    // listeners represented as objects that have deliver() method
    this._lstn = [&#x27;,&#x27;]; // we unshift() uplink listeners and push() downlinks
    // ...so _lstn is like [server1, server2, storage, &#x27;,&#x27;, view, listener]
    // The most correct way to specify a version is the version vector,
    // but that one may consume more space than the data itself in some cases.
    // Hence, _version is not a fully specified version vector (see version()
    // instead). _version is essentially is the greatest operation timestamp
    // (Lamport-like, i.e. &#x22;time+source&#x22;), sometimes amended with additional
    // timestamps. Its main features:
    // (1) changes once the object&#x27;s state changes
    // (2) does it monotonically (in the alphanum order sense)
    this._version = &#x27;&#x27;;
    // make sense of arguments
    var args = Array.prototype.slice.call(arguments);
    this._host = (args.length &#x26;&#x26; args[args.length - 1]._type === &#x27;Host&#x27;) ?
            args.pop() : env.localhost;
    if (Spec.is(args[0])) {
        this._id = new Spec(args.shift()).id() || this._host.time();
    } else if (typeof(args[0]) === &#x27;string&#x27;) {
        this._id = args.shift(); // TODO format
    } else {
        this._id = this._host.time();
        this._version = &#x27;!0&#x27;; // may apply state in the constructor, see Model
    }
    //var state = args.length ? args.pop() : (fresh?{}:undefined);
    // register with the host
    var doubl = this._host.register(this);
    if (doubl !== this) { return doubl; }
    // locally created objects get state immediately
    // (while external-id objects need to query uplinks)
<span class="apidocCodeCommentSpan">    /*if (fresh &#x26;&#x26; state) {
     state._version = &#x27;!&#x27;+this._id;
     var pspec = this.spec().add(state._version).add(&#x27;.init&#x27;);
     this.deliver(pspec,state,this._host);
     }*/
</span>    this.reset();
    // find uplinks, subscribe
    this.checkUplink();
    // TODO inplement state push
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.deliver" id="apidoc.element.swarm.Syncable.prototype.deliver">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>deliver
        <span class="apidocSignatureSpan">(spec, value, lstn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deliver = function (spec, value, lstn) {
    spec = Spec.as(spec);
    var opver = &#x27;!&#x27; + spec.version();
    var error;

    function fail(msg, ex) {
        console.error(msg, spec, value, (ex &#x26;&#x26; ex.stack) || ex || new Error(msg));
        if (typeof(lstn) === &#x27;function&#x27;) {
            lstn(spec.set(&#x27;.fail&#x27;), msg);
        } else if (lstn &#x26;&#x26; typeof(lstn.error) === &#x27;function&#x27;) {
            lstn.error(spec, msg);
        } // else { } no callback provided
    }

    // sanity checks
    if (spec.pattern() !== &#x27;/#!.&#x27;) {
        return fail(&#x27;malformed spec&#x27;, spec);
    }
    if (!this._id) {
        return fail(&#x27;undead object invoked&#x27;);
    }
    if (error = this.validate(spec, value)) {
        return fail(&#x27;invalid input, &#x27; + error, value);
    }
    if (!this.acl(spec, value, lstn)) {
        return fail(&#x27;access violation&#x27;, spec);
    }

    env.debug &#x26;&#x26; env.log(spec, value, lstn);

    try {
        var call = spec.op();
        if (this._ops[call]) {  // FIXME name=&#x3e;impl table
            if (this.isReplay(spec)) { // it happens
                console.warn(&#x27;replay&#x27;, spec);
                return;
            }
            // invoke the implementation
            this._ops[call].call(this, spec, value, lstn); // NOTE: no return value
            // once applied, may remember in the log...
            if (spec.op() !== &#x27;init&#x27;) {
                this._oplog &#x26;&#x26; (this._oplog[spec.filter(&#x27;!.&#x27;)] = value);
                // this._version is practically a label that lets you know whether
                // the state has changed. Also, it allows to detect some cases of
                // concurrent change, as it is always set to the maximum version id
                // received by this object. Still, only the full version vector may
                // precisely and uniquely specify the current version (see version()).
                this._version = (opver &#x3e; this._version) ? opver : this._version + opver;
            } else {
                value = this.diff(&#x27;!0&#x27;);
            }
            // ...and relay further to downstream replicas and various listeners
            this.emit(spec, value, lstn);
        } else if (this._neutrals[call]) {
            // invoke the implementation
            this._neutrals[call].call(this, spec, value, lstn);
            // and relay to listeners
            this.emit(spec, value, lstn);
        } else {
            this.unimplemented(spec, value, lstn);
        }
    } catch (ex) { // log and rethrow; don&#x27;t relay further; don&#x27;t log
        return fail(&#x22;method execution failed&#x22;, ex);
    }

    // to force async signatures we eat the returned value silently
    return spec;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.callbacks===null) { return; }
var that = this.owner || src;
for(var i=0; i&#x3c;this.callbacks.length; i++) {
    var cb = this.callbacks[i];
    if (cb.constructor===Function) {
        cb.call(that,spec,value,src);
    } else {
        cb.<span class="apidocCodeKeywordSpan">deliver</span>(spec,value,src);
    }
}
};

ProxyListener.prototype.on = function (callback) {
if (this.callbacks===null) { this.callbacks = []; }
this.callbacks.push(callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.diff" id="apidoc.element.swarm.Syncable.prototype.diff">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>diff
        <span class="apidocSignatureSpan">(base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff = function (base) {
    //var vid = new Spec(this._version).get(&#x27;!&#x27;); // first !token
    //var spec = vid + &#x27;.patch&#x27;;
    if (!this._version) { return undefined; }
    this.distillLog(); // TODO optimize?
    var patch, spec;
    if (base &#x26;&#x26; base != &#x27;!0&#x27; &#x26;&#x26; base != &#x27;0&#x27;) { // FIXME ugly
        var map = new Spec.Map(base || &#x27;&#x27;);
        for (spec in this._oplog) {
            if (!map.covers(new Spec(spec).version())) {
                patch = patch || {_tail: {}}; // NOTE: no _version
                patch._tail[spec] = this._oplog[spec];
            }
        }
    } else {
        patch = {_version: &#x27;!0&#x27;, _tail: {}}; // zero state plus the tail
        for (spec in this._oplog) {
            patch._tail[spec] = this._oplog[spec];
        }
    }
    return patch;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 pos += m[0].length;
 }

 this.tids = tids;*/
this.text = this.weave.replace(/[^\u0008][\u0008]+/mg, &#x27;&#x27;).substr(1);
    },
    set: function (newText) {
var patch = Text.<span class="apidocCodeKeywordSpan">diff</span>(this.text, newText);
var rm = null, ins = null, weave = this.weave;
var re_atom = /[^\u0008]([^\u0008][\u0008]+)*/mg;
var atom;

function skip(n) {
    for (n = n || 1; n &#x3e; 0; n--) {
        atom = re_atom.exec(weave);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.distillLog" id="apidoc.element.swarm.Syncable.prototype.distillLog">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>distillLog
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distillLog = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.emit" id="apidoc.element.swarm.Syncable.prototype.emit">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>emit
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (spec, value, src) {
    var ls = this._lstn,
        op = spec.op(),
        is_neutrals = op in this._neutrals;
    if (ls) {
        var notify = [];
        for (var i = 0; i &#x3c; ls.length; i++) {
            var l = ls[i];
            // skip empties, deferreds and the source
            if (!l || l === &#x27;,&#x27; || l === src) { continue; }
            if (is_neutrals &#x26;&#x26; l._op !== op) { continue; }
            if (l._op &#x26;&#x26; l._op !== op) { continue; }
            notify.push(l);
        }
        for (i = 0; i &#x3c; notify.length; i++) { // screw it I want my &#x27;this&#x27;
            try {
                notify[i].deliver(spec, value, this);
            } catch (ex) {
                console.error(ex.message, ex.stack);
            }
        }
    }
    this.callReactions(spec, value, src);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tail = this.tails[ti];
if (!tail) {
    tail = this.tails[ti] = [];
} else if (tail.indexOf(vo)!==-1) {
    return; // replay
}
tail.push(vo);
this.<span class="apidocCodeKeywordSpan">emit</span>(spec,value);
};


SharedWebStorage.prototype.installListeners = function () {
var self = this;
function onStorageChange(ev) {
    if (Spec.is(ev.key) &#x26;&#x26; ev.newValue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.error" id="apidoc.element.swarm.Syncable.prototype.error">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.buf = buf; //will wait for &#x22;open&#x22;
    }
    ws.on(&#x27;close&#x27;, function () { ln.close &#x26;&#x26; ln.close(); });
    ws.on(&#x27;data&#x27;, function (msg) {
        try {
            ln.data &#x26;&#x26; ln.data(msg);
        } catch (ex) {
            console.<span class="apidocCodeKeywordSpan">error</span>(&#x27;message processing fails&#x27;, ex);
            ln.error &#x26;&#x26; ln.error(ex.message);
        }
    });
}

module.exports = SockJSStream;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.gc" id="apidoc.element.swarm.Syncable.prototype.gc">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>gc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gc = function () {
    var l = this._lstn;
    if (!l.length || (l.length === 1 &#x26;&#x26; !l[0])) {
        this.close();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.getListenerIndex" id="apidoc.element.swarm.Syncable.prototype.getListenerIndex">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>getListenerIndex
        <span class="apidocSignatureSpan">(search_for, uplinks_only)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getListenerIndex = function (search_for, uplinks_only) {
    var i = this._lstn.indexOf(search_for),
        l;
    if (i &#x3e; -1) { return i; }

    for (i = 0, l = this._lstn.length; i &#x3c; l; i++) {
        var ln = this._lstn[i];
        if (uplinks_only &#x26;&#x26; ln === &#x27;,&#x27;) {
            return -1;
        }
        if (Syncable.listenerEquals(ln, search_for)) {
            return i;
        }
    }
    return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.hasState" id="apidoc.element.swarm.Syncable.prototype.hasState">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>hasState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasState = function () {
    return !!this._version;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.init" id="apidoc.element.swarm.Syncable.prototype.init">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.isReplay" id="apidoc.element.swarm.Syncable.prototype.isReplay">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>isReplay
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isReplay = function (spec) {
    if (!this._version) { return false; }
    if (spec.op() === &#x27;init&#x27;) { return false; } // these are .on !vids
    var opver = spec.version();
    if (opver &#x3e; this._version.substr(1)) { return false; }
    if (spec.filter(&#x27;!.&#x27;).toString() in this._oplog) { return true; }// TODO log trimming, vvectors?
    return this.version().covers(opver); // heavyweight
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.newEventSpec" id="apidoc.element.swarm.Syncable.prototype.newEventSpec">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>newEventSpec
        <span class="apidocSignatureSpan">(op)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newEventSpec = function (op) {
    return this.spec().add(this._host.time(), &#x27;!&#x27;).add(op, &#x27;.&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.off" id="apidoc.element.swarm.Syncable.prototype.off">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>off
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Unsubscribe from collections entries&#x27; events
 * @param {function(*)} callback
 * @this Set|Vector
 */
offObjectEvent: function (callback) {
    this._proxy.<span class="apidocCodeKeywordSpan">off</span>(callback);
},

/**
 * Waits for collection to receive state from cache or uplink and then invokes passed callback
 *
 * @param {function()} callback
 * @this Set|Vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.on" id="apidoc.element.swarm.Syncable.prototype.on">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.once" id="apidoc.element.swarm.Syncable.prototype.once">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>once
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (filter, cb) {
    this.on(filter, function onceWrap(spec, val, src) {
        // &#x22;this&#x22; is the object (Syncable)
        if (cb.constructor === Function) {
            cb.call(this, spec, val, src);
        } else {
            cb.deliver(spec, val, src);
        }
        this.off(filter, onceWrap);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
    if (!notInitedYet.length) {
        // all entries are inited
        callback();
    } else {
        // wait for some entry not ready yet
        var randomIdx = (Math.random() * (notInitedYet.length - 1)) | 0;
        notInitedYet[randomIdx].<span class="apidocCodeKeywordSpan">once</span>(&#x27;init&#x27;, checker);
    }
}
if (this._version) {
    checker();
} else {
    this.once(&#x27;init&#x27;, checker);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.pojo" id="apidoc.element.swarm.Syncable.prototype.pojo">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>pojo
        <span class="apidocSignatureSpan">(addVersionInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pojo = function (addVersionInfo) {
    var pojo = {},
        defs = this.constructor.defaults;
    for (var key in this) {
        if (this.hasOwnProperty(key)) {
            if (Syncable.reFieldName.test(key) &#x26;&#x26; this[key] !== undefined) {
                var def = defs[key],
                    val = this[key];
                pojo[key] = def &#x26;&#x26; def.type ?
                (val.toJSON &#x26;&#x26; val.toJSON()) || val.toString() :
                        (val &#x26;&#x26; val._id ? val._id : val); // TODO prettify
            }
        }
    }
    if (addVersionInfo) {
        pojo._id = this._id; // not necassary
        pojo._version = this._version;
        this._vector &#x26;&#x26; (pojo._vector = this._vector);
        this._oplog &#x26;&#x26; (pojo._oplog = this._oplog); //TODO copy
    }
    return pojo;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.reoff" id="apidoc.element.swarm.Syncable.prototype.reoff">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>reoff
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.reon" id="apidoc.element.swarm.Syncable.prototype.reon">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>reon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.reset" id="apidoc.element.swarm.Syncable.prototype.reset">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
    var defs = this.constructor.defaults;
    for (var name in defs) {
        var def = defs[name];
        if (def.type) {
            this[name] = def.value ? new def.type(def.value) : new def.type();
        } else {
            this[name] = def.value;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.spec" id="apidoc.element.swarm.Syncable.prototype.spec">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>spec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spec = function () { return new Spec(&#x27;/&#x27; + this._type + &#x27;#&#x27; + this._id); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.stateSpec" id="apidoc.element.swarm.Syncable.prototype.stateSpec">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>stateSpec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stateSpec = function () {
    return this.spec() + (this._version || &#x27;&#x27;); //?
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.trigger" id="apidoc.element.swarm.Syncable.prototype.trigger">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>trigger
        <span class="apidocSignatureSpan">(event, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trigger = function (event, params) {
    var spec = this.newEventSpec(event);
    this.deliver(spec, params);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.unimplemented" id="apidoc.element.swarm.Syncable.prototype.unimplemented">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>unimplemented
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unimplemented = function (spec, val, repl) {
    console.warn(&#x22;method not implemented:&#x22;, spec);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.validate" id="apidoc.element.swarm.Syncable.prototype.validate">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>validate
        <span class="apidocSignatureSpan">(spec, val, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (spec, val, src) {
    if (spec.pattern() !== &#x27;/#!.&#x27;) {
        return &#x27;incomplete event spec&#x27;;
    }
    if (this.clock &#x26;&#x26; spec.type()!==&#x27;Host&#x27; &#x26;&#x26; !this.clock.checkTimestamp(spec.version())) {
        return &#x27;invalid timestamp &#x27;+spec;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype.version" id="apidoc.element.swarm.Syncable.prototype.version">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype.</span>version
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">version = function () {
    // distillLog() may drop some operations; still, those need to be counted
    // in the version vector; so, their Lamport ids must be saved in this._vector
    var map = new Spec.Map(this._version + (this._vector || &#x27;&#x27;));
    if (this._oplog) {
        for (var op in this._oplog) {
            map.add(op);
        }
    }
    return map; // TODO return the object, let the consumer trim it to taste
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    this.weave = w1.join(&#x27;&#x27;);
    this.ids = w4;
    this.rebuild();
},
remove: function (spec, rm, src) {
    var w1 = [], w4 = [];
    var v = spec.<span class="apidocCodeKeywordSpan">version</span>();
    for (var i = 0; i &#x3c; this.weave.length; i++) {
        w1.push(this.weave.charAt(i));
        w4.push(this.ids[i]);
        if (this.ids[i] in rm) {
            w1.push(&#x27;\u0008&#x27;);
            w4.push(v);
        }
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Syncable.prototype._neutrals" id="apidoc.module.swarm.Syncable.prototype._neutrals">module swarm.Syncable.prototype._neutrals</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype._neutrals.error" id="apidoc.element.swarm.Syncable.prototype._neutrals.error">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype._neutrals.</span>error
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (spec, val, repl) {
    console.error(&#x27;something failed:&#x27;, spec, val, &#x27;@&#x27;, (repl &#x26;&#x26; repl._id));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.buf = buf; //will wait for &#x22;open&#x22;
    }
    ws.on(&#x27;close&#x27;, function () { ln.close &#x26;&#x26; ln.close(); });
    ws.on(&#x27;data&#x27;, function (msg) {
        try {
            ln.data &#x26;&#x26; ln.data(msg);
        } catch (ex) {
            console.<span class="apidocCodeKeywordSpan">error</span>(&#x27;message processing fails&#x27;, ex);
            ln.error &#x26;&#x26; ln.error(ex.message);
        }
    });
}

module.exports = SockJSStream;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype._neutrals.off" id="apidoc.element.swarm.Syncable.prototype._neutrals.off">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype._neutrals.</span>off
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (spec, val, repl) {
    var idx = this.getListenerIndex(repl); //TODO ??? uplinks_only?
    if (idx &#x3e; -1) {
        this._lstn.splice(idx, 1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Unsubscribe from collections entries&#x27; events
 * @param {function(*)} callback
 * @this Set|Vector
 */
offObjectEvent: function (callback) {
    this._proxy.<span class="apidocCodeKeywordSpan">off</span>(callback);
},

/**
 * Waits for collection to receive state from cache or uplink and then invokes passed callback
 *
 * @param {function()} callback
 * @this Set|Vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype._neutrals.on" id="apidoc.element.swarm.Syncable.prototype._neutrals.on">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype._neutrals.</span>on
        <span class="apidocSignatureSpan">(spec, filter, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (spec, filter, repl) {   // WELL  on() is not an op, right?
    // if no listener is supplied then the object is only
    // guaranteed to exist till the next Host.gc() run
    if (!repl) { return; }

    var self = this;
    // stateless objects fire no events; essentially, on() is deferred
    if (!this._version &#x26;&#x26; filter) { // TODO solidify
        this._lstn.push({
            _op: &#x27;reon&#x27;,
            _src: repl,
            deliver: function () {
                var i = self._lstn.indexOf(this);
                self._lstn.splice(i, 1);
                self.deliver(spec, filter, repl);
            }
        });
        return; // defer this call till uplinks are ready
    }
    // make all listeners uniform objects
    if (repl.constructor === Function) {
        repl = {
            sink: repl,
            that: this,
            deliver: function () { // .deliver is invoked on an event
                this.sink.apply(this.that, arguments);
            }
        };
    }

    if (filter) {
        filter = new Spec(filter, &#x27;.&#x27;);
        var baseVersion = filter.filter(&#x27;!&#x27;),
            filter_by_op = filter.get(&#x27;.&#x27;);

        if (filter_by_op === &#x27;init&#x27;) {
            var diff_if_needed = baseVersion ? this.diff(baseVersion) : &#x27;&#x27;;
            repl.deliver(spec.set(&#x27;.init&#x27;), diff_if_needed, this); //??
            // FIXME use once()
            return;
        }
        if (filter_by_op) {
            repl = {
                sink: repl,
                _op: filter_by_op,
                deliver: function deliverWithFilter(spec, val, src) {
                    if (spec.op() === filter_by_op) {
                        this.sink.deliver(spec, val, src);
                    }
                }
            };
        }

        if (!baseVersion.isEmpty()) {
            var diff = this.diff(baseVersion);
            diff &#x26;&#x26; repl.deliver(spec.set(&#x27;.init&#x27;), diff, this); // 2downlink
            repl.deliver(spec.set(&#x27;.reon&#x27;), this.version().toString(), this);
        }
    }

    this._lstn.push(repl);
    // TODO repeated subscriptions: send a diff, otherwise ignore
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype._neutrals.reoff" id="apidoc.element.swarm.Syncable.prototype._neutrals.reoff">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype._neutrals.</span>reoff
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reoff = function (spec, val, repl) {
    var idx = this.getListenerIndex(repl); //TODO ??? uplinks_only?
    if (idx &#x3e; -1) {
        this._lstn.splice(idx, 1);
    }
    if (this._id) {
        this.checkUplink();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype._neutrals.reon" id="apidoc.element.swarm.Syncable.prototype._neutrals.reon">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype._neutrals.</span>reon
        <span class="apidocSignatureSpan">(spec, filter, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reon = function (spec, filter, repl) {
    if (filter) {  // a diff is requested
        var base = Spec.as(filter).tok(&#x27;!&#x27;);
        var diff = this.diff(base);
        if (diff) {
            repl.deliver(spec.set(&#x27;.init&#x27;), diff, this);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Syncable.prototype._ops" id="apidoc.module.swarm.Syncable.prototype._ops">module swarm.Syncable.prototype._ops</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Syncable.prototype._ops.init" id="apidoc.element.swarm.Syncable.prototype._ops.init">
        function <span class="apidocSignatureSpan">swarm.Syncable.prototype._ops.</span>init
        <span class="apidocSignatureSpan">(spec, state, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (spec, state, src) {

    var tail = {}, // ops to be applied on top of the received state
        typeid = spec.filter(&#x27;/#&#x27;),
        lstn = this._lstn,
        a_spec;
    this._lstn = []; // prevent events from being fired

    if (state._version/* &#x26;&#x26; state._version !== &#x27;!0&#x27;*/) {
        // local changes may need to be merged into the received state
        if (this._oplog) {
            for (a_spec in this._oplog) {
                tail[a_spec] = this._oplog[a_spec];
            }
            this._oplog = {};
        }
        this._vector &#x26;&#x26; (this._vector = undefined);
        // zero everything
        for (var key in this) {
            if (this.hasOwnProperty(key) &#x26;&#x26; key.charAt(0) !== &#x27;_&#x27;) {
                this[key] = undefined;
            }
        }
        // set default values
        this.reset();

        this.apply(state);
        this._version = state._version;

        state._oplog &#x26;&#x26; (this._oplog = state._oplog); // FIXME copy
        state._vector &#x26;&#x26; (this._vector = state._vector);
    }
    // add the received tail to the local one
    if (state._tail) {
        for (a_spec in state._tail) {
            tail[a_spec] = state._tail[a_spec];
        }
    }
    // appply the combined tail to the new state
    var specs = [];
    for (a_spec in tail) {
        specs.push(a_spec);
    }
    specs.sort().reverse();
    // there will be some replays, but those will be ignored
    while (a_spec = specs.pop()) {
        this.deliver(typeid.add(a_spec), tail[a_spec], this);
    }

    this._lstn = lstn;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Syncable.types" id="apidoc.module.swarm.Syncable.types">module swarm.Syncable.types</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Syncable.types.Host" id="apidoc.element.swarm.Syncable.types.Host">
        function <span class="apidocSignatureSpan">swarm.Syncable.types.</span>Host
        <span class="apidocSignatureSpan">(id, ms, storage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Host(id, ms, storage) {
    this.objects = {};
    this.sources = {};
    this.storage = storage;
    this._host = this; // :)
    this._lstn = [&#x27;,&#x27;];
    this._id = id;
    this._server = /^swarm~.*/.test(id);
    var clock_fn = env.clockType || SecondPreciseClock;
    this.clock = new clock_fn(this._id, ms||0);

    if (this.storage) {
        this.sources[this._id] = this.storage;
        this.storage._host = this;
    }
    delete this.objects[this.spec()];

    if (!env.multihost) {
        if (env.localhost) {
            throw new Error(&#x27;use multihost mode&#x27;);
        }
        env.localhost = this;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
module.exports = Mouse; // CommonJS
```

### Using the model on the client (app.js)

```js
// 1. create local Host
var swarmHost = new Swarm.<span class="apidocCodeKeywordSpan">Host</span>(&#x27;unique_client_id&#x27;);

// 2. connect to your server
swarmHost.connect(&#x27;ws://localhost:8000/&#x27;);

// 3.a. create an object
var someMouse = new Mouse();
// OR swarmHost.get(&#x27;/Mouse&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.types.Model" id="apidoc.element.swarm.Syncable.types.Model">
        function <span class="apidocSignatureSpan">swarm.Syncable.types.</span>Model
        <span class="apidocSignatureSpan">(idOrState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Model(idOrState) {
    var ret = Model._super.apply(this, arguments);
    /// TODO: combine with state push, make clean
    if (ret === this &#x26;&#x26; idOrState &#x26;&#x26; idOrState.constructor !== String &#x26;&#x26; !Spec.is(idOrState)) {
        this.deliver(this.spec().add(this._id, &#x27;!&#x27;).add(&#x27;.set&#x27;), idOrState);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.types.Set" id="apidoc.element.swarm.Syncable.types.Set">
        function <span class="apidocSignatureSpan">swarm.Syncable.types.</span>Set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SomeSyncable() {
    return parent.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.types.Syncable" id="apidoc.element.swarm.Syncable.types.Syncable">
        function <span class="apidocSignatureSpan">swarm.Syncable.types.</span>Syncable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Syncable() {
    // listeners represented as objects that have deliver() method
    this._lstn = [&#x27;,&#x27;]; // we unshift() uplink listeners and push() downlinks
    // ...so _lstn is like [server1, server2, storage, &#x27;,&#x27;, view, listener]
    // The most correct way to specify a version is the version vector,
    // but that one may consume more space than the data itself in some cases.
    // Hence, _version is not a fully specified version vector (see version()
    // instead). _version is essentially is the greatest operation timestamp
    // (Lamport-like, i.e. &#x22;time+source&#x22;), sometimes amended with additional
    // timestamps. Its main features:
    // (1) changes once the object&#x27;s state changes
    // (2) does it monotonically (in the alphanum order sense)
    this._version = &#x27;&#x27;;
    // make sense of arguments
    var args = Array.prototype.slice.call(arguments);
    this._host = (args.length &#x26;&#x26; args[args.length - 1]._type === &#x27;Host&#x27;) ?
            args.pop() : env.localhost;
    if (Spec.is(args[0])) {
        this._id = new Spec(args.shift()).id() || this._host.time();
    } else if (typeof(args[0]) === &#x27;string&#x27;) {
        this._id = args.shift(); // TODO format
    } else {
        this._id = this._host.time();
        this._version = &#x27;!0&#x27;; // may apply state in the constructor, see Model
    }
    //var state = args.length ? args.pop() : (fresh?{}:undefined);
    // register with the host
    var doubl = this._host.register(this);
    if (doubl !== this) { return doubl; }
    // locally created objects get state immediately
    // (while external-id objects need to query uplinks)
<span class="apidocCodeCommentSpan">    /*if (fresh &#x26;&#x26; state) {
     state._version = &#x27;!&#x27;+this._id;
     var pspec = this.spec().add(state._version).add(&#x27;.init&#x27;);
     this.deliver(pspec,state,this._host);
     }*/
</span>    this.reset();
    // find uplinks, subscribe
    this.checkUplink();
    // TODO inplement state push
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.types.Text" id="apidoc.element.swarm.Syncable.types.Text">
        function <span class="apidocSignatureSpan">swarm.Syncable.types.</span>Text
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SomeSyncable() {
    return parent.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.types.Vector" id="apidoc.element.swarm.Syncable.types.Vector">
        function <span class="apidocSignatureSpan">swarm.Syncable.types.</span>Vector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SomeSyncable() {
    return parent.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Syncable.types.Text.prototype" id="apidoc.module.swarm.Syncable.types.Text.prototype">module swarm.Syncable.types.Text.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Syncable.types.Text.prototype.callReactions" id="apidoc.element.swarm.Syncable.types.Text.prototype.callReactions">
        function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>callReactions
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callReactions = function (spec, value, src) {
    var superReactions = syncProto._super.callReactions;
    if (&#x27;function&#x27; === typeof superReactions) {
        superReactions.call(this, spec, value, src);
    }
    var r = syncProto._reactions[spec.op()];
    if (r) {
        r.constructor !== Array &#x26;&#x26; (r = [r]);
        for (var i = 0; i &#x3c; r.length; i++) {
            r[i] &#x26;&#x26; r[i].call(this, spec, value, src);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.types.Text.prototype.constructor" id="apidoc.element.swarm.Syncable.types.Text.prototype.constructor">
        function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SomeSyncable() {
    return parent.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.types.Text.prototype.insert" id="apidoc.element.swarm.Syncable.types.Text.prototype.insert">
        function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>insert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
            break;
        case &#x27;=&#x27;:
            skip(val.length);
        }
    }
    rm &#x26;&#x26; this.remove(rm);
    ins &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">insert</span>(ins);
}
});

Text.diff = function diff(was, is) {
var ret = [];
// prefix suffix the rest is change
var pre = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.types.Text.prototype.rebuild" id="apidoc.element.swarm.Syncable.types.Text.prototype.rebuild">
        function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>rebuild
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rebuild = function () {
<span class="apidocCodeCommentSpan">    /*var re = /([^\u0008][\u0008]+)|([^\u0008])/g, m=[];
     var text = [], tids = [], pos = 0;
     while (m=re.exec(this.weave)) {
     if (m[2]) {
     text.push(m[2]);
     tids.push(this.ids[pos]);
     }
     pos += m[0].length;
     }

     this.tids = tids;*/
</span>    this.text = this.weave.replace(/[^\u0008][\u0008]+/mg, &#x27;&#x27;).substr(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }
    if (genTs) {
        this._host.clock.checkTimestamp(genTs);
    }
    this.weave = w1.join(&#x27;&#x27;);
    this.ids = w4;
    this.<span class="apidocCodeKeywordSpan">rebuild</span>();
},
remove: function (spec, rm, src) {
    var w1 = [], w4 = [];
    var v = spec.version();
    for (var i = 0; i &#x3c; this.weave.length; i++) {
        w1.push(this.weave.charAt(i));
        w4.push(this.ids[i]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.types.Text.prototype.remove" id="apidoc.element.swarm.Syncable.types.Text.prototype.remove">
        function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>remove
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                skip();
            }
            break;
        case &#x27;=&#x27;:
            skip(val.length);
        }
    }
    rm &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">remove</span>(rm);
    ins &#x26;&#x26; this.insert(ins);
}
});

Text.diff = function diff(was, is) {
var ret = [];
// prefix suffix the rest is change
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.types.Text.prototype.set" id="apidoc.element.swarm.Syncable.types.Text.prototype.set">
        function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>set
        <span class="apidocSignatureSpan">(newText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (newText) {
    var patch = Text.diff(this.text, newText);
    var rm = null, ins = null, weave = this.weave;
    var re_atom = /[^\u0008]([^\u0008][\u0008]+)*/mg;
    var atom;

    function skip(n) {
        for (n = n || 1; n &#x3e; 0; n--) {
            atom = re_atom.exec(weave);
        }
    }

    skip(1); // \n #00000+swarm

    for (var i = 0; i &#x3c; patch.length; i++) {
        var op = patch[i][0], val = patch[i][1];
        switch (op) {
        case &#x27;+&#x27;:
            ins || (ins = {});
            ins[this.ids[atom.index]] = val;
            break;
        case &#x27;-&#x27;:
            rm || (rm = {});
            for (var r = 0; r &#x3c; val.length; r++) {
                rm[this.ids[atom.index + atom[0].length]] = true;
                skip();
            }
            break;
        case &#x27;=&#x27;:
            skip(val.length);
        }
    }
    rm &#x26;&#x26; this.remove(rm);
    ins &#x26;&#x26; this.insert(ins);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// 3.a. create an object
var someMouse = new Mouse();
// OR swarmHost.get(&#x27;/Mouse&#x27;);
// OR new Mouse({x:1, y:2});

// 4.a. a locally created object may be touched immediately
someMouse.<span class="apidocCodeKeywordSpan">set</span>({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.on(&#x27;init&#x27;, function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Syncable.types.Text.prototype.state" id="apidoc.element.swarm.Syncable.types.Text.prototype.state">
        function <span class="apidocSignatureSpan">swarm.Syncable.types.Text.prototype.</span>state
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Text" id="apidoc.module.swarm.Text">module swarm.Text</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Text.Text" id="apidoc.element.swarm.Text.Text">
        function <span class="apidocSignatureSpan">swarm.</span>Text
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SomeSyncable() {
    return parent.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Text._super" id="apidoc.element.swarm.Text._super">
        function <span class="apidocSignatureSpan">swarm.Text.</span>_super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Syncable() {
    // listeners represented as objects that have deliver() method
    this._lstn = [&#x27;,&#x27;]; // we unshift() uplink listeners and push() downlinks
    // ...so _lstn is like [server1, server2, storage, &#x27;,&#x27;, view, listener]
    // The most correct way to specify a version is the version vector,
    // but that one may consume more space than the data itself in some cases.
    // Hence, _version is not a fully specified version vector (see version()
    // instead). _version is essentially is the greatest operation timestamp
    // (Lamport-like, i.e. &#x22;time+source&#x22;), sometimes amended with additional
    // timestamps. Its main features:
    // (1) changes once the object&#x27;s state changes
    // (2) does it monotonically (in the alphanum order sense)
    this._version = &#x27;&#x27;;
    // make sense of arguments
    var args = Array.prototype.slice.call(arguments);
    this._host = (args.length &#x26;&#x26; args[args.length - 1]._type === &#x27;Host&#x27;) ?
            args.pop() : env.localhost;
    if (Spec.is(args[0])) {
        this._id = new Spec(args.shift()).id() || this._host.time();
    } else if (typeof(args[0]) === &#x27;string&#x27;) {
        this._id = args.shift(); // TODO format
    } else {
        this._id = this._host.time();
        this._version = &#x27;!0&#x27;; // may apply state in the constructor, see Model
    }
    //var state = args.length ? args.pop() : (fresh?{}:undefined);
    // register with the host
    var doubl = this._host.register(this);
    if (doubl !== this) { return doubl; }
    // locally created objects get state immediately
    // (while external-id objects need to query uplinks)
<span class="apidocCodeCommentSpan">    /*if (fresh &#x26;&#x26; state) {
     state._version = &#x27;!&#x27;+this._id;
     var pspec = this.spec().add(state._version).add(&#x27;.init&#x27;);
     this.deliver(pspec,state,this._host);
     }*/
</span>    this.reset();
    // find uplinks, subscribe
    this.checkUplink();
    // TODO inplement state push
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Text.addReaction" id="apidoc.element.swarm.Text.addReaction">
        function <span class="apidocSignatureSpan">swarm.Text.</span>addReaction
        <span class="apidocSignatureSpan">(op, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addReaction = function (op, fn) {
    var reactions = this.prototype._reactions;
    var list = reactions[op];
    list || (list = reactions[op] = []);
    list.push(fn);
    return {op: op, fn: fn};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Text.diff" id="apidoc.element.swarm.Text.diff">
        function <span class="apidocSignatureSpan">swarm.Text.</span>diff
        <span class="apidocSignatureSpan">(was, is)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diff(was, is) {
    var ret = [];
    // prefix suffix the rest is change
    var pre = 0;
    while (pre &#x3c; was.length &#x26;&#x26; pre &#x3c; is.length &#x26;&#x26; was.charAt(pre) === is.charAt(pre)) {
        pre++;
    }
    var post = 0;
    while (post &#x3c; was.length - pre &#x26;&#x26; post &#x3c; is.length - pre &#x26;&#x26;
    was.charAt(was.length - post - 1) === is.charAt(is.length - post - 1)) {
        post++;
    }
    if (pre) {
        ret.push([&#x27;=&#x27;, was.substr(0, pre)]);
    }
    var ins = is.length - pre - post;
    if (ins) {
        ret.push([&#x27;+&#x27;, is.substr(pre, ins)]);
    }
    var rm = was.length - pre - post;
    if (rm) {
        ret.push([&#x27;-&#x27;, was.substr(pre, rm)]);
    }
    if (post) {
        ret.push([&#x27;=&#x27;, was.substr(pre + rm)]);
    }
    return ret;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 pos += m[0].length;
 }

 this.tids = tids;*/
this.text = this.weave.replace(/[^\u0008][\u0008]+/mg, &#x27;&#x27;).substr(1);
    },
    set: function (newText) {
var patch = Text.<span class="apidocCodeKeywordSpan">diff</span>(this.text, newText);
var rm = null, ins = null, weave = this.weave;
var re_atom = /[^\u0008]([^\u0008][\u0008]+)*/mg;
var atom;

function skip(n) {
    for (n = n || 1; n &#x3e; 0; n--) {
        atom = re_atom.exec(weave);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Text.extend" id="apidoc.element.swarm.Text.extend">
        function <span class="apidocSignatureSpan">swarm.Text.</span>extend
        <span class="apidocSignatureSpan">(fn, own)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (fn, own) {
    var parent = this, fnid;
    if (fn.constructor !== Function) {
        var id = fn.toString();
        fn = function SomeSyncable() {
            return parent.apply(this, arguments);
        };
        fnid = id; // if only it worked
    } else { // please call Syncable.constructor.apply(this,args) in your constructor
        fnid = fnname(fn);
    }

    // inheritance trick from backbone.js
    var SyncProto = function () {
        this.constructor = fn;
        this._neutrals = {};
        this._ops = {};
        this._reactions = {};

        var event,
            name;
        if (parent._pt) {
            //copy _neutrals &#x26; _ops from parent
            for (event in parent._pt._neutrals) {
                this._neutrals[event] = parent._pt._neutrals[event];
            }
            for (event in parent._pt._ops) {
                this._ops[event] = parent._pt._ops[event];
            }
        }

        // &#x22;Methods&#x22; are serialized, logged and delivered to replicas
        for (name in own.ops || {}) {
            if (Syncable.reMethodName.test(name)) {
                this._ops[name] = own.ops[name];
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid op name:&#x27;,name);
            }
        }

        // &#x22;Neutrals&#x22; don&#x27;t change the state
        for (name in own.neutrals || {}) {
            if (Syncable.reMethodName.test(name)) {
                this._neutrals[name] = own.neutrals[name];
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid neutral op name:&#x27;,name);
            }
        }

        // &#x22;Remotes&#x22; are serialized and sent upstream (like RPC calls)
        for (name in own.remotes || {}) {
            if (Syncable.reMethodName.test(name)) {
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid rpc name:&#x27;,name);
            }
        }

        // add mixins
        (own.mixins || []).forEach(function (mixin) {
            for (var name in mixin) {
                this[name] = mixin[name];
            }
        }, this);

        // add other members
        for (name in own) {
            if (Syncable.reMethodName.test(name)) {
                var memberType = own[name].constructor;
                if (memberType === Function) { // non-op method
                    // these must change state ONLY by invoking ops
                    this[name] = own[name];
                } else if (memberType===String || memberType===Number) {
                    this[name] = own[name]; // some static constant, OK
                } else if (name in Syncable.memberClasses) {
                    // see above
                    continue;
                } else {
                    console.warn(&#x27;invalid member:&#x27;,name,memberType);
                }
            } else {
                console.warn(&#x27;invalid member name:&#x27;,name);
            }
        }

        // add reactions
        for (name in own.reactions || {}) {
            var reaction = own.reactions[name];
            if (!reaction) { continue; }

            switch (typeof reaction) {
            case &#x27;function&#x27;:
                // handler-function
                this._reactions[name] = [reaction];
                break;
            case &#x27;string&#x27;:
                // handler-method name
                this._reactions[name] = [this[name]];
                break;
            default:
                if (reaction.constructor === Array) {
                    // array of handlers
                    this._reactions[name] = reaction.map(function (item) {
                        switch (typeof item) {
                        case &#x27;function&#x27;:
                            return item;
                        case &#x27;string&#x27;:
                            return this[item];
                        default:
                            throw new Error(&#x27;unexpected reaction type&#x27;);
                        }
                    }, this);
                } else {
                    throw new Error(&#x27;unex ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
these demos are normally online at http://ppyr.us and http://ppyr.us:8001/demo3/index.html respectively.

### Creating your first simple synchronized type

```js
var Swarm = require(&#x27;swarm&#x27;);

var Mouse = Swarm.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;Mouse&#x27;, {
    defaults: {
        name: &#x27;Mickey&#x27;,
        x: 0,
        y: 0
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Text.removeReaction" id="apidoc.element.swarm.Text.removeReaction">
        function <span class="apidocSignatureSpan">swarm.Text.</span>removeReaction
        <span class="apidocSignatureSpan">(handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeReaction = function (handle) {
    var op = handle.op,
        fn = handle.fn,
        list = this.prototype._reactions[op],
        i = list.indexOf(fn);
    if (i === -1) {
        throw new Error(&#x27;reaction unknown&#x27;);
    }
    list[i] = undefined; // such a peculiar pattern not to mess up out-of-callback removal
    while (list.length &#x26;&#x26; !list[list.length - 1]) {
        list.pop();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Vector" id="apidoc.module.swarm.Vector">module swarm.Vector</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Vector.Vector" id="apidoc.element.swarm.Vector.Vector">
        function <span class="apidocSignatureSpan">swarm.</span>Vector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SomeSyncable() {
    return parent.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector._super" id="apidoc.element.swarm.Vector._super">
        function <span class="apidocSignatureSpan">swarm.Vector.</span>_super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Syncable() {
    // listeners represented as objects that have deliver() method
    this._lstn = [&#x27;,&#x27;]; // we unshift() uplink listeners and push() downlinks
    // ...so _lstn is like [server1, server2, storage, &#x27;,&#x27;, view, listener]
    // The most correct way to specify a version is the version vector,
    // but that one may consume more space than the data itself in some cases.
    // Hence, _version is not a fully specified version vector (see version()
    // instead). _version is essentially is the greatest operation timestamp
    // (Lamport-like, i.e. &#x22;time+source&#x22;), sometimes amended with additional
    // timestamps. Its main features:
    // (1) changes once the object&#x27;s state changes
    // (2) does it monotonically (in the alphanum order sense)
    this._version = &#x27;&#x27;;
    // make sense of arguments
    var args = Array.prototype.slice.call(arguments);
    this._host = (args.length &#x26;&#x26; args[args.length - 1]._type === &#x27;Host&#x27;) ?
            args.pop() : env.localhost;
    if (Spec.is(args[0])) {
        this._id = new Spec(args.shift()).id() || this._host.time();
    } else if (typeof(args[0]) === &#x27;string&#x27;) {
        this._id = args.shift(); // TODO format
    } else {
        this._id = this._host.time();
        this._version = &#x27;!0&#x27;; // may apply state in the constructor, see Model
    }
    //var state = args.length ? args.pop() : (fresh?{}:undefined);
    // register with the host
    var doubl = this._host.register(this);
    if (doubl !== this) { return doubl; }
    // locally created objects get state immediately
    // (while external-id objects need to query uplinks)
<span class="apidocCodeCommentSpan">    /*if (fresh &#x26;&#x26; state) {
     state._version = &#x27;!&#x27;+this._id;
     var pspec = this.spec().add(state._version).add(&#x27;.init&#x27;);
     this.deliver(pspec,state,this._host);
     }*/
</span>    this.reset();
    // find uplinks, subscribe
    this.checkUplink();
    // TODO inplement state push
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.addReaction" id="apidoc.element.swarm.Vector.addReaction">
        function <span class="apidocSignatureSpan">swarm.Vector.</span>addReaction
        <span class="apidocSignatureSpan">(op, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addReaction = function (op, fn) {
    var reactions = this.prototype._reactions;
    var list = reactions[op];
    list || (list = reactions[op] = []);
    list.push(fn);
    return {op: op, fn: fn};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.extend" id="apidoc.element.swarm.Vector.extend">
        function <span class="apidocSignatureSpan">swarm.Vector.</span>extend
        <span class="apidocSignatureSpan">(fn, own)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (fn, own) {
    var parent = this, fnid;
    if (fn.constructor !== Function) {
        var id = fn.toString();
        fn = function SomeSyncable() {
            return parent.apply(this, arguments);
        };
        fnid = id; // if only it worked
    } else { // please call Syncable.constructor.apply(this,args) in your constructor
        fnid = fnname(fn);
    }

    // inheritance trick from backbone.js
    var SyncProto = function () {
        this.constructor = fn;
        this._neutrals = {};
        this._ops = {};
        this._reactions = {};

        var event,
            name;
        if (parent._pt) {
            //copy _neutrals &#x26; _ops from parent
            for (event in parent._pt._neutrals) {
                this._neutrals[event] = parent._pt._neutrals[event];
            }
            for (event in parent._pt._ops) {
                this._ops[event] = parent._pt._ops[event];
            }
        }

        // &#x22;Methods&#x22; are serialized, logged and delivered to replicas
        for (name in own.ops || {}) {
            if (Syncable.reMethodName.test(name)) {
                this._ops[name] = own.ops[name];
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid op name:&#x27;,name);
            }
        }

        // &#x22;Neutrals&#x22; don&#x27;t change the state
        for (name in own.neutrals || {}) {
            if (Syncable.reMethodName.test(name)) {
                this._neutrals[name] = own.neutrals[name];
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid neutral op name:&#x27;,name);
            }
        }

        // &#x22;Remotes&#x22; are serialized and sent upstream (like RPC calls)
        for (name in own.remotes || {}) {
            if (Syncable.reMethodName.test(name)) {
                this[name] = wrapCall(name);
            } else {
                console.warn(&#x27;invalid rpc name:&#x27;,name);
            }
        }

        // add mixins
        (own.mixins || []).forEach(function (mixin) {
            for (var name in mixin) {
                this[name] = mixin[name];
            }
        }, this);

        // add other members
        for (name in own) {
            if (Syncable.reMethodName.test(name)) {
                var memberType = own[name].constructor;
                if (memberType === Function) { // non-op method
                    // these must change state ONLY by invoking ops
                    this[name] = own[name];
                } else if (memberType===String || memberType===Number) {
                    this[name] = own[name]; // some static constant, OK
                } else if (name in Syncable.memberClasses) {
                    // see above
                    continue;
                } else {
                    console.warn(&#x27;invalid member:&#x27;,name,memberType);
                }
            } else {
                console.warn(&#x27;invalid member name:&#x27;,name);
            }
        }

        // add reactions
        for (name in own.reactions || {}) {
            var reaction = own.reactions[name];
            if (!reaction) { continue; }

            switch (typeof reaction) {
            case &#x27;function&#x27;:
                // handler-function
                this._reactions[name] = [reaction];
                break;
            case &#x27;string&#x27;:
                // handler-method name
                this._reactions[name] = [this[name]];
                break;
            default:
                if (reaction.constructor === Array) {
                    // array of handlers
                    this._reactions[name] = reaction.map(function (item) {
                        switch (typeof item) {
                        case &#x27;function&#x27;:
                            return item;
                        case &#x27;string&#x27;:
                            return this[item];
                        default:
                            throw new Error(&#x27;unexpected reaction type&#x27;);
                        }
                    }, this);
                } else {
                    throw new Error(&#x27;unex ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
these demos are normally online at http://ppyr.us and http://ppyr.us:8001/demo3/index.html respectively.

### Creating your first simple synchronized type

```js
var Swarm = require(&#x27;swarm&#x27;);

var Mouse = Swarm.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;Mouse&#x27;, {
    defaults: {
        name: &#x27;Mickey&#x27;,
        x: 0,
        y: 0
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.removeReaction" id="apidoc.element.swarm.Vector.removeReaction">
        function <span class="apidocSignatureSpan">swarm.Vector.</span>removeReaction
        <span class="apidocSignatureSpan">(handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeReaction = function (handle) {
    var op = handle.op,
        fn = handle.fn,
        list = this.prototype._reactions[op],
        i = list.indexOf(fn);
    if (i === -1) {
        throw new Error(&#x27;reaction unknown&#x27;);
    }
    list[i] = undefined; // such a peculiar pattern not to mess up out-of-callback removal
    while (list.length &#x26;&#x26; !list[list.length - 1]) {
        list.pop();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Vector.prototype" id="apidoc.module.swarm.Vector.prototype">module swarm.Vector.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.addObject" id="apidoc.element.swarm.Vector.prototype.addObject">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>addObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addObject = function (obj) {
    this.append(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.append" id="apidoc.element.swarm.Vector.prototype.append">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>append
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function append(spec) {
    this.insert(spec,this._order.length()-1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.callReactions" id="apidoc.element.swarm.Vector.prototype.callReactions">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>callReactions
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callReactions = function (spec, value, src) {
    var superReactions = syncProto._super.callReactions;
    if (&#x27;function&#x27; === typeof superReactions) {
        superReactions.call(this, spec, value, src);
    }
    var r = syncProto._reactions[spec.op()];
    if (r) {
        r.constructor !== Array &#x26;&#x26; (r = [r]);
        for (var i = 0; i &#x3c; r.length; i++) {
            r[i] &#x26;&#x26; r[i].call(this, spec, value, src);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.constructor" id="apidoc.element.swarm.Vector.prototype.constructor">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SomeSyncable() {
    return parent.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.distillLog" id="apidoc.element.swarm.Vector.prototype.distillLog">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>distillLog
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distillLog = function () {
    // TODO HORIZON
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.every" id="apidoc.element.swarm.Vector.prototype.every">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>every
        <span class="apidocSignatureSpan">(cb, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">every = function (cb, thisArg) {
    return this._objects.every(cb, thisArg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.filter" id="apidoc.element.swarm.Vector.prototype.filter">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>filter
        <span class="apidocSignatureSpan">(cb, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (cb, thisArg) {
    return this._objects.filter(cb, thisArg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function htmlesc (text) {
return text;
}

/// range/ids -???  first, all   then...

function rtf2txt (rtf) {
var txt = rtf.<span class="apidocCodeKeywordSpan">filter</span>(function(o){ return o &#x26;&#x26; o.constructor===String });
return txt.join(&#x27;&#x27;);
}

function meta2attstr (meta) {
var ret = [], styles={}, classes={}, atts={}, structs={};
var kv = {&#x27;:&#x27;:styles,&#x27;_&#x27;:classes,&#x27;=&#x27;:atts,&#x27;s&#x27;:structs};
var re_meta = /^(\w[\w_\-]*)([:_=]?)$/, m;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.findPositionFor" id="apidoc.element.swarm.Vector.prototype.findPositionFor">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>findPositionFor
        <span class="apidocSignatureSpan">(id, parentId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPositionFor = function (id, parentId) { // FIXME protected methods &#x26;&#x26; statics (entryType)
    if (!parentId) {
        parentId = this.getParentOf(id);
    }
    var next;
    if (parentId!==&#x27;!0&#x27;) {
        next = this._order.find(parentId);
        if (next.end()) {
            next = this.findPositionFor(parentId);
        }
        next.next();
    } else {
        next = this._order.iterator();
    }
    // skip &#x22;younger&#x22; concurrent siblings
    while (!next.end()) {
        var nextId = next.token();
        if (nextId&#x3c;id) {
            break;
        }
        var subtreeId = this.inSubtreeOf(nextId,parentId);
        if (!subtreeId || subtreeId&#x3c;id) {
            break;
        }
        this.skipSubtree(next,subtreeId);
    }
    return next; // insert before
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.forEach" id="apidoc.element.swarm.Vector.prototype.forEach">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>forEach
        <span class="apidocSignatureSpan">(cb, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (cb, thisArg) {
    this._objects.forEach(cb, thisArg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.getObject" id="apidoc.element.swarm.Vector.prototype.getObject">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>getObject
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getObject = function (spec) {
    spec = new Spec(spec,&#x27;#&#x27;);
    if (!spec.has(&#x27;/&#x27;)) {
        if (this.objectType) {
            spec = spec.add(this.objectType.prototype._type,&#x27;/&#x27;).sort();
        } else {
            throw new Error(&#x22;type not specified&#x22;); // TODO is it necessary at all?
        }
    }
    var obj = this._host.get(spec);
    return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.getParentOf" id="apidoc.element.swarm.Vector.prototype.getParentOf">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>getParentOf
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParentOf = function (id) {
    var spec = this._oplog[id+&#x27;.in&#x27;];
    if (!spec) {
        throw new Error(&#x27;operation unknown: &#x27;+id);
    }
    var parentId = Spec.as(spec).tok(&#x27;!&#x27;) || &#x27;!0&#x27;;
    return parentId;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.in" id="apidoc.element.swarm.Vector.prototype.in">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>in
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.inSubtreeOf" id="apidoc.element.swarm.Vector.prototype.inSubtreeOf">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>inSubtreeOf
        <span class="apidocSignatureSpan">(nodeId, rootId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inSubtreeOf = function (nodeId, rootId) {
    var id=nodeId, p=id;
    while (id&#x3e;rootId) {
        p=id;
        id=this.getParentOf(id);
    }
    return id===rootId &#x26;&#x26; p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.indexOf" id="apidoc.element.swarm.Vector.prototype.indexOf">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(obj, startAt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (obj, startAt) {
    if (!obj._id) {
        obj = this.getObject(obj);
    }
    return this._objects.indexOf(obj,startAt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            openTag = &#x27;h&#x27;+format.head;
        else
            openTag = &#x27;p&#x27;;
        html.push(&#x27;&#x3c;&#x27;,openTag,&#x27;&#x3e;&#x27;); // TODO pid
        frg = frg.substr(1);
    }
    //find next struct (lookahead; had \n =&#x3e; check for \t)
    var n = frg.<span class="apidocCodeKeywordSpan">indexOf</span>(&#x27;\n&#x27;,1);
    if (n!==-1) { // repair
        rtf.push(frg.substr(n));
        frg = frg.substr(0,n);
    }
    var atts = meta2attstr(format);
    html.push(&#x27;&#x3c;span&#x27;,atts,&#x27;&#x3e;&#x27;,htmlesc(frg),&#x27;&#x3c;/span&#x3e;&#x27;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.insert" id="apidoc.element.swarm.Vector.prototype.insert">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>insert
        <span class="apidocSignatureSpan">(spec, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (spec, pos) {
    // TODO bulk insert: make&#x27;em siblings
    if (pos===undefined) {
        pos = -1; // TODO ? this._order.length()
    }
    if (pos.constructor!==Number) {
        pos = this.normalizePos(pos);
    }
    if (spec &#x26;&#x26; spec._id) {
        spec = spec.spec();
    } else /*if (spec.constructor===String)*/ {
        spec = new Spec(spec,&#x27;#&#x27;);
    }
    // TODO new object
    var opid = pos===-1 ? &#x27;!0&#x27; : this._order.tokenAt(pos);
    // TODO hint pos
    return this.in(spec+opid);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
            break;
        case &#x27;=&#x27;:
            skip(val.length);
        }
    }
    rm &#x26;&#x26; this.remove(rm);
    ins &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">insert</span>(ins);
}
});

Text.diff = function diff(was, is) {
var ret = [];
// prefix suffix the rest is change
var pre = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.insertAfter" id="apidoc.element.swarm.Vector.prototype.insertAfter">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>insertAfter
        <span class="apidocSignatureSpan">(obj, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertAfter = function (obj, pos) {
    this.insert (obj,pos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.insertBefore" id="apidoc.element.swarm.Vector.prototype.insertBefore">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>insertBefore
        <span class="apidocSignatureSpan">(spec, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertBefore = function (spec, pos) {
    if (pos===undefined) {
        pos = this._order.length();
    }
    if (pos.constructor!==Number) {
        pos = this.normalizePos(pos);
    }
    this.insert(spec,pos-1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    /*
    var from=range.get(&#x27;#&#x27;), till=range.get(&#x27;#&#x27;,from);
    // clean DOM range
    for(var pid=from; pid &#x26;&#x26; pid!==till; pid=???)
        body.removeChild(pid);
    // install
    while ()
        body.<span class="apidocCodeKeywordSpan">insertBefore</span>(newp,till); // TODO batch?
    // recover selection
    // */
};


//DOMEditor.prototype.getRTF = function (from, till, format, rtf) {
function dom2rtf (from, till, format, rtf) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.insertSorted" id="apidoc.element.swarm.Vector.prototype.insertSorted">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>insertSorted
        <span class="apidocSignatureSpan">(obj, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertSorted = function (obj, cmp) {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.isDescendantOf" id="apidoc.element.swarm.Vector.prototype.isDescendantOf">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>isDescendantOf
        <span class="apidocSignatureSpan">(nodeId, rootId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDescendantOf = function (nodeId, rootId) {
    var i=nodeId;
    while (i&#x3e;rootId) {
        i=this.getParentOf(i);
    }
    return i===rootId;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.length" id="apidoc.element.swarm.Vector.prototype.length">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">length = function () {
    return this._objects.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.map" id="apidoc.element.swarm.Vector.prototype.map">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>map
        <span class="apidocSignatureSpan">(cb, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (cb, thisArg) {
    return this._objects.map(cb, thisArg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.normalizePos" id="apidoc.element.swarm.Vector.prototype.normalizePos">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>normalizePos
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizePos = function (pos) {
    if (pos &#x26;&#x26; pos._id) {
        pos=pos._id;
    }
    var spec = new Spec(pos,&#x27;#&#x27;);
    var type = spec.type();
    var id = spec.id();
    for(var i=0; i&#x3c;this._objects.length; i++) {
        var obj = this._objects[i];
        if (obj &#x26;&#x26; obj._id===id &#x26;&#x26; (!type || obj._type===type)) {
            break;
        }
    }
    return i;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.objectAt" id="apidoc.element.swarm.Vector.prototype.objectAt">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>objectAt
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAt = function (i) {
    return this._objects[i];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.offObjectEvent" id="apidoc.element.swarm.Vector.prototype.offObjectEvent">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>offObjectEvent
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">offObjectEvent = function (callback) {
    this._proxy.off(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.onObjectEvent" id="apidoc.element.swarm.Vector.prototype.onObjectEvent">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>onObjectEvent
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onObjectEvent = function (callback) {
    this._proxy.owner = this;
    this._proxy.on(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.onObjectStateReady" id="apidoc.element.swarm.Vector.prototype.onObjectStateReady">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>onObjectStateReady
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onObjectStateReady = function (callback) { // TODO timeout ?
    var self = this;
    function checker() {
        var notInitedYet = self.filter(function (entry) {
            return !entry._version;
        });
        if (!notInitedYet.length) {
            // all entries are inited
            callback();
        } else {
            // wait for some entry not ready yet
            var randomIdx = (Math.random() * (notInitedYet.length - 1)) | 0;
            notInitedYet[randomIdx].once(&#x27;init&#x27;, checker);
        }
    }
    if (this._version) {
        checker();
    } else {
        this.once(&#x27;init&#x27;, checker);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.pojo" id="apidoc.element.swarm.Vector.prototype.pojo">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>pojo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pojo = function () {
    // invoke super.pojo()
    var result = Syncable._pt.pojo.apply(this, arguments);
    result.entries = Object.keys(this._objects);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.remove" id="apidoc.element.swarm.Vector.prototype.remove">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>remove
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function remove(pos) {
    if (pos.constructor!==Number) {
        pos = this.normalizePos(pos);
    }
    var hint = Spec.int2base(pos,0);
    var op = this._order.tokenAt(pos);
    this.rm(op+&#x27;.&#x27;+hint); // TODO generic spec quants
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                skip();
            }
            break;
        case &#x27;=&#x27;:
            skip(val.length);
        }
    }
    rm &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">remove</span>(rm);
    ins &#x26;&#x26; this.insert(ins);
}
});

Text.diff = function diff(was, is) {
var ret = [];
// prefix suffix the rest is change
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.removeObject" id="apidoc.element.swarm.Vector.prototype.removeObject">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>removeObject
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObject = function (pos) {
    this.remove(pos);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.rm" id="apidoc.element.swarm.Vector.prototype.rm">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>rm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapper() {
    // assign a Lamport timestamp
    var spec = this.newEventSpec(name);
    var args = Array.prototype.slice.apply(arguments), lstn;
    // find the callback if any
    Syncable.isOpSink(args[args.length - 1]) &#x26;&#x26; (lstn = args.pop());
    // prettify the rest of the arguments
    if (!args.length) {  // FIXME isn&#x27;t it confusing?
        args = &#x27;&#x27;; // used as &#x27;empty&#x27;
    } else if (args.length === 1) {
        args = args[0]; // {key:val}
    }
    // TODO log &#x27;initiated&#x27;
    return this.deliver(spec, args, lstn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.setOrder" id="apidoc.element.swarm.Vector.prototype.setOrder">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>setOrder
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOrder = function (fn) {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.skipSubtree" id="apidoc.element.swarm.Vector.prototype.skipSubtree">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>skipSubtree
        <span class="apidocSignatureSpan">(iter, root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipSubtree = function (iter, root) {
    root = root || iter.token();
    do {
        iter.next();
    } while (!iter.end() &#x26;&#x26; this.isDescendantOf(iter.token(),root));
    return iter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype.validate" id="apidoc.element.swarm.Vector.prototype.validate">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype.</span>validate
        <span class="apidocSignatureSpan">(spec, val, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (spec, val, source) {
    // ref op is known
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Vector.prototype._neutrals" id="apidoc.module.swarm.Vector.prototype._neutrals">module swarm.Vector.prototype._neutrals</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype._neutrals.error" id="apidoc.element.swarm.Vector.prototype._neutrals.error">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype._neutrals.</span>error
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (spec, val, repl) {
    console.error(&#x27;something failed:&#x27;, spec, val, &#x27;@&#x27;, (repl &#x26;&#x26; repl._id));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.buf = buf; //will wait for &#x22;open&#x22;
    }
    ws.on(&#x27;close&#x27;, function () { ln.close &#x26;&#x26; ln.close(); });
    ws.on(&#x27;data&#x27;, function (msg) {
        try {
            ln.data &#x26;&#x26; ln.data(msg);
        } catch (ex) {
            console.<span class="apidocCodeKeywordSpan">error</span>(&#x27;message processing fails&#x27;, ex);
            ln.error &#x26;&#x26; ln.error(ex.message);
        }
    });
}

module.exports = SockJSStream;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype._neutrals.off" id="apidoc.element.swarm.Vector.prototype._neutrals.off">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype._neutrals.</span>off
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (spec, val, repl) {
    var idx = this.getListenerIndex(repl); //TODO ??? uplinks_only?
    if (idx &#x3e; -1) {
        this._lstn.splice(idx, 1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Unsubscribe from collections entries&#x27; events
 * @param {function(*)} callback
 * @this Set|Vector
 */
offObjectEvent: function (callback) {
    this._proxy.<span class="apidocCodeKeywordSpan">off</span>(callback);
},

/**
 * Waits for collection to receive state from cache or uplink and then invokes passed callback
 *
 * @param {function()} callback
 * @this Set|Vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype._neutrals.on" id="apidoc.element.swarm.Vector.prototype._neutrals.on">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype._neutrals.</span>on
        <span class="apidocSignatureSpan">(spec, filter, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (spec, filter, repl) {   // WELL  on() is not an op, right?
    // if no listener is supplied then the object is only
    // guaranteed to exist till the next Host.gc() run
    if (!repl) { return; }

    var self = this;
    // stateless objects fire no events; essentially, on() is deferred
    if (!this._version &#x26;&#x26; filter) { // TODO solidify
        this._lstn.push({
            _op: &#x27;reon&#x27;,
            _src: repl,
            deliver: function () {
                var i = self._lstn.indexOf(this);
                self._lstn.splice(i, 1);
                self.deliver(spec, filter, repl);
            }
        });
        return; // defer this call till uplinks are ready
    }
    // make all listeners uniform objects
    if (repl.constructor === Function) {
        repl = {
            sink: repl,
            that: this,
            deliver: function () { // .deliver is invoked on an event
                this.sink.apply(this.that, arguments);
            }
        };
    }

    if (filter) {
        filter = new Spec(filter, &#x27;.&#x27;);
        var baseVersion = filter.filter(&#x27;!&#x27;),
            filter_by_op = filter.get(&#x27;.&#x27;);

        if (filter_by_op === &#x27;init&#x27;) {
            var diff_if_needed = baseVersion ? this.diff(baseVersion) : &#x27;&#x27;;
            repl.deliver(spec.set(&#x27;.init&#x27;), diff_if_needed, this); //??
            // FIXME use once()
            return;
        }
        if (filter_by_op) {
            repl = {
                sink: repl,
                _op: filter_by_op,
                deliver: function deliverWithFilter(spec, val, src) {
                    if (spec.op() === filter_by_op) {
                        this.sink.deliver(spec, val, src);
                    }
                }
            };
        }

        if (!baseVersion.isEmpty()) {
            var diff = this.diff(baseVersion);
            diff &#x26;&#x26; repl.deliver(spec.set(&#x27;.init&#x27;), diff, this); // 2downlink
            repl.deliver(spec.set(&#x27;.reon&#x27;), this.version().toString(), this);
        }
    }

    this._lstn.push(repl);
    // TODO repeated subscriptions: send a diff, otherwise ignore
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype._neutrals.reoff" id="apidoc.element.swarm.Vector.prototype._neutrals.reoff">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype._neutrals.</span>reoff
        <span class="apidocSignatureSpan">(spec, val, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reoff = function (spec, val, repl) {
    var idx = this.getListenerIndex(repl); //TODO ??? uplinks_only?
    if (idx &#x3e; -1) {
        this._lstn.splice(idx, 1);
    }
    if (this._id) {
        this.checkUplink();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype._neutrals.reon" id="apidoc.element.swarm.Vector.prototype._neutrals.reon">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype._neutrals.</span>reon
        <span class="apidocSignatureSpan">(spec, filter, repl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reon = function (spec, filter, repl) {
    if (filter) {  // a diff is requested
        var base = Spec.as(filter).tok(&#x27;!&#x27;);
        var diff = this.diff(base);
        if (diff) {
            repl.deliver(spec.set(&#x27;.init&#x27;), diff, this);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.Vector.prototype._ops" id="apidoc.module.swarm.Vector.prototype._ops">module swarm.Vector.prototype._ops</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype._ops.in" id="apidoc.element.swarm.Vector.prototype._ops.in">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype._ops.</span>in
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">in = function (spec, value, src) {
    // we misuse specifiers to express the operation in
    // a compact non-ambiguous way
    value = new Spec(value);
    var opid = spec.tok(&#x27;!&#x27;);
    var at = value.tok(&#x27;!&#x27;);
    if (opid&#x3c;=at) {
        throw new Error(&#x27;timestamps are messed up&#x27;);
    }
    var what = value.tok(&#x27;#&#x27;);
    if (!what) { throw new Error(&#x27;object #id not specified&#x27;); }
    var type = value.get(&#x27;/&#x27;);
    if (!type &#x26;&#x26; this.objectType) {
        type = this.objectType.prototype._type;
    }
    if (!type) {
        throw new Error(&#x27;object /type not specified&#x27;);
    }
    type = &#x27;/&#x27; + type;

    var pos = this.findPositionFor(opid, at?at:&#x27;!0&#x27;);
    var obj = this._host.get(type+what);

    this._objects.splice(pos.index,0,obj);
    this._order.insert(opid,pos);

    obj.on(this._proxy);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype._ops.init" id="apidoc.element.swarm.Vector.prototype._ops.init">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype._ops.</span>init
        <span class="apidocSignatureSpan">(spec, state, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (spec, state, src) {

    var tail = {}, // ops to be applied on top of the received state
        typeid = spec.filter(&#x27;/#&#x27;),
        lstn = this._lstn,
        a_spec;
    this._lstn = []; // prevent events from being fired

    if (state._version/* &#x26;&#x26; state._version !== &#x27;!0&#x27;*/) {
        // local changes may need to be merged into the received state
        if (this._oplog) {
            for (a_spec in this._oplog) {
                tail[a_spec] = this._oplog[a_spec];
            }
            this._oplog = {};
        }
        this._vector &#x26;&#x26; (this._vector = undefined);
        // zero everything
        for (var key in this) {
            if (this.hasOwnProperty(key) &#x26;&#x26; key.charAt(0) !== &#x27;_&#x27;) {
                this[key] = undefined;
            }
        }
        // set default values
        this.reset();

        this.apply(state);
        this._version = state._version;

        state._oplog &#x26;&#x26; (this._oplog = state._oplog); // FIXME copy
        state._vector &#x26;&#x26; (this._vector = state._vector);
    }
    // add the received tail to the local one
    if (state._tail) {
        for (a_spec in state._tail) {
            tail[a_spec] = state._tail[a_spec];
        }
    }
    // appply the combined tail to the new state
    var specs = [];
    for (a_spec in tail) {
        specs.push(a_spec);
    }
    specs.sort().reverse();
    // there will be some replays, but those will be ignored
    while (a_spec = specs.pop()) {
        this.deliver(typeid.add(a_spec), tail[a_spec], this);
    }

    this._lstn = lstn;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.Vector.prototype._ops.rm" id="apidoc.element.swarm.Vector.prototype._ops.rm">
        function <span class="apidocSignatureSpan">swarm.Vector.prototype._ops.</span>rm
        <span class="apidocSignatureSpan">(spec, value, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rm = function (spec, value, src) {
    value = Spec.as(value);
    var target = value.tok(&#x27;!&#x27;);
    var hint = value.has(&#x27;.&#x27;) ? Spec.base2int(value.get(&#x27;.&#x27;)) : 0;
    var at = this._order.find(target, Math.max(0,hint-5));
    if (at.end()) {
        at = this._order.find(target, 0);
    }
    if (at.end()) {
        // this can only be explained by concurrent deletion
        // partial order can&#x27;t break cause-and-effect ordering
        return;
    }
    var obj = this._objects[at.index];
    this._objects.splice(at.index,1);
    at.erase(1);

    obj.off(this._proxy);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.WebSocketStream" id="apidoc.module.swarm.WebSocketStream">module swarm.WebSocketStream</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.WebSocketStream.WebSocketStream" id="apidoc.element.swarm.WebSocketStream.WebSocketStream">
        function <span class="apidocSignatureSpan">swarm.</span>WebSocketStream
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketStream(url) {
    var self = this;
    var ln = this.lstn = {};
    this.url = url;
    var ws = this.ws = new WebSocket(url);
    var buf = this.buf = [];
    ws.onopen = function () {
        buf.reverse();
        self.buf = null;
        while (buf.length) {
            self.write(buf.pop());
        }

    };
    ws.onclose = function () { ln.close &#x26;&#x26; ln.close(); };
    ws.onmessage = function (msg) {
        ln.data &#x26;&#x26; ln.data(msg.data);
    };
    ws.onerror = function (err) { ln.error &#x26;&#x26; ln.error(err); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.env" id="apidoc.module.swarm.env">module swarm.env</a></h1>


















    <h2>
        <a href="#apidoc.element.swarm.env.hashfn" id="apidoc.element.swarm.env.hashfn">
        function <span class="apidocSignatureSpan">swarm.env.</span>hashfn
        <span class="apidocSignatureSpan">(key, seed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function murmurhash3_32_gc(key, seed) {
    var remainder, bytes, h1, h1b, c1, c2, k1, i;

    remainder = key.length &#x26; 3; // key.length % 4
    bytes = key.length - remainder;
    h1 = seed;
    c1 = 0xcc9e2d51;
    c2 = 0x1b873593;
    i = 0;

    while (i &#x3c; bytes) {
        k1 =
                ((key.charCodeAt(i) &#x26; 0xff)) |
                ((key.charCodeAt(++i) &#x26; 0xff) &#x3c;&#x3c; 8) |
                ((key.charCodeAt(++i) &#x26; 0xff) &#x3c;&#x3c; 16) |
                ((key.charCodeAt(++i) &#x26; 0xff) &#x3c;&#x3c; 24);
        ++i;

        k1 = ((((k1 &#x26; 0xffff) * c1) + ((((k1 &#x3e;&#x3e;&#x3e; 16) * c1) &#x26; 0xffff) &#x3c;&#x3c; 16))) &#x26; 0xffffffff;
        k1 = (k1 &#x3c;&#x3c; 15) | (k1 &#x3e;&#x3e;&#x3e; 17);
        k1 = ((((k1 &#x26; 0xffff) * c2) + ((((k1 &#x3e;&#x3e;&#x3e; 16) * c2) &#x26; 0xffff) &#x3c;&#x3c; 16))) &#x26; 0xffffffff;

        h1 ^= k1;
        h1 = (h1 &#x3c;&#x3c; 13) | (h1 &#x3e;&#x3e;&#x3e; 19);
        h1b = ((((h1 &#x26; 0xffff) * 5) + ((((h1 &#x3e;&#x3e;&#x3e; 16) * 5) &#x26; 0xffff) &#x3c;&#x3c; 16))) &#x26; 0xffffffff;
        h1 = (((h1b &#x26; 0xffff) + 0x6b64) + ((((h1b &#x3e;&#x3e;&#x3e; 16) + 0xe654) &#x26; 0xffff) &#x3c;&#x3c; 16));
    }

    k1 = 0;

    switch (remainder) {
    case 3:
        k1 ^= (key.charCodeAt(i + 2) &#x26; 0xff) &#x3c;&#x3c; 16;
<span class="apidocCodeCommentSpan">        /* falls through */
</span>    case 2:
        k1 ^= (key.charCodeAt(i + 1) &#x26; 0xff) &#x3c;&#x3c; 8;
        /* falls through */
    case 1:
        k1 ^= (key.charCodeAt(i) &#x26; 0xff);

        k1 = (((k1 &#x26; 0xffff) * c1) + ((((k1 &#x3e;&#x3e;&#x3e; 16) * c1) &#x26; 0xffff) &#x3c;&#x3c; 16)) &#x26; 0xffffffff;
        k1 = (k1 &#x3c;&#x3c; 15) | (k1 &#x3e;&#x3e;&#x3e; 17);
        k1 = (((k1 &#x26; 0xffff) * c2) + ((((k1 &#x3e;&#x3e;&#x3e; 16) * c2) &#x26; 0xffff) &#x3c;&#x3c; 16)) &#x26; 0xffffffff;
        h1 ^= k1;
    }

    h1 ^= key.length;

    h1 ^= h1 &#x3e;&#x3e;&#x3e; 16;
    h1 = (((h1 &#x26; 0xffff) * 0x85ebca6b) + ((((h1 &#x3e;&#x3e;&#x3e; 16) * 0x85ebca6b) &#x26; 0xffff) &#x3c;&#x3c; 16)) &#x26; 0xffffffff;
    h1 ^= h1 &#x3e;&#x3e;&#x3e; 13;
    h1 = ((((h1 &#x26; 0xffff) * 0xc2b2ae35) + ((((h1 &#x3e;&#x3e;&#x3e; 16) * 0xc2b2ae35) &#x26; 0xffff) &#x3c;&#x3c; 16))) &#x26; 0xffffffff;
    h1 ^= h1 &#x3e;&#x3e;&#x3e; 16;

    return h1 &#x3e;&#x3e;&#x3e; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.env.log" id="apidoc.element.swarm.env.log">
        function <span class="apidocSignatureSpan">swarm.env.</span>log
        <span class="apidocSignatureSpan">(spec, val, object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function plain_log(spec, val, object) {
    var method = &#x27;log&#x27;;
    switch (spec.op()) {
    case &#x27;error&#x27;:
        method = &#x27;error&#x27;;
        break;
    case &#x27;warn&#x27;:
        method = &#x27;warn&#x27;;
        break;
    }
    console[method](spec.toString(), val, object &#x26;&#x26; object._id,
            &#x27;@&#x27; + ((object &#x26;&#x26; object._host &#x26;&#x26; object._host._id) || &#x27;&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
    // this will be triggered by every state change, be it
    // local or remote
    console.<span class="apidocCodeKeywordSpan">log</span>(&#x27;event: &#x27;, spec.op(), val);
    // outputs:
    // set {x:3, y:4}
});
```

### Creating a simple NodeJS sync server
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.env.streams" id="apidoc.module.swarm.env.streams">module swarm.env.streams</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.env.streams.loopback" id="apidoc.element.swarm.env.streams.loopback">
        function <span class="apidocSignatureSpan">swarm.env.streams.</span>loopback
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncLoopbackConnection(url) {
    var m = url.match(/loopback:(\w+)/);
    if (!m) {
        throw new Error(&#x27;invalid url&#x27;);
    }
    this.id = m[1];
    this.lstn = {};
    this.queue = [];
    if (this.id in AsyncLoopbackConnection.pipes) {
        throw new Error(&#x27;duplicate&#x27;);
    }
    AsyncLoopbackConnection.pipes[this.id] = this;
    var pair = this.pair();
    if (pair &#x26;&#x26; pair.queue.length) {
        pair.write();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.env.streams.ws" id="apidoc.element.swarm.env.streams.ws">
        function <span class="apidocSignatureSpan">swarm.env.streams.</span>ws
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketStream(url) {
    var self = this;
    var ln = this.lstn = {};
    this.url = url;
    var ws = this.ws = new WebSocket(url);
    var buf = this.buf = [];
    ws.onopen = function () {
        buf.reverse();
        self.buf = null;
        while (buf.length) {
            self.write(buf.pop());
        }

    };
    ws.onclose = function () { ln.close &#x26;&#x26; ln.close(); };
    ws.onmessage = function (msg) {
        ln.data &#x26;&#x26; ln.data(msg.data);
    };
    ws.onerror = function (err) { ln.error &#x26;&#x26; ln.error(err); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.env.streams.wss" id="apidoc.element.swarm.env.streams.wss">
        function <span class="apidocSignatureSpan">swarm.env.streams.</span>wss
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketStream(url) {
    var self = this;
    var ln = this.lstn = {};
    this.url = url;
    var ws = this.ws = new WebSocket(url);
    var buf = this.buf = [];
    ws.onopen = function () {
        buf.reverse();
        self.buf = null;
        while (buf.length) {
            self.write(buf.pop());
        }

    };
    ws.onclose = function () { ln.close &#x26;&#x26; ln.close(); };
    ws.onmessage = function (msg) {
        ln.data &#x26;&#x26; ln.data(msg.data);
    };
    ws.onerror = function (err) { ln.error &#x26;&#x26; ln.error(err); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.env.streams.loopback.prototype" id="apidoc.module.swarm.env.streams.loopback.prototype">module swarm.env.streams.loopback.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.env.streams.loopback.prototype.close" id="apidoc.element.swarm.env.streams.loopback.prototype.close">
        function <span class="apidocSignatureSpan">swarm.env.streams.loopback.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    delete AsyncLoopbackConnection.pipes[this.id];
    var pair = this.pair();
    pair &#x26;&#x26; pair.close();
    this.lstn.close &#x26;&#x26; this.lstn.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }, 1);
};

AsyncLoopbackConnection.prototype.close = function () {
    delete AsyncLoopbackConnection.pipes[this.id];
    var pair = this.pair();
    pair &#x26;&#x26; pair.<span class="apidocCodeKeywordSpan">close</span>();
    this.lstn.close &#x26;&#x26; this.lstn.close();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.env.streams.loopback.prototype.on" id="apidoc.element.swarm.env.streams.loopback.prototype.on">
        function <span class="apidocSignatureSpan">swarm.env.streams.loopback.prototype.</span>on
        <span class="apidocSignatureSpan">(evname, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (evname, fn) {
    if (evname in this.lstn) {
        throw new Error(&#x27;multiple listeners not supported&#x27;);
    }
    this.lstn[evname] = fn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.env.streams.loopback.prototype.pair" id="apidoc.element.swarm.env.streams.loopback.prototype.pair">
        function <span class="apidocSignatureSpan">swarm.env.streams.loopback.prototype.</span>pair
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pair = function () {
    var pairId = this.id.match(/./g).reverse().join(&#x27;&#x27;);
    return AsyncLoopbackConnection.pipes[pairId];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.id = m[1];
    this.lstn = {};
    this.queue = [];
    if (this.id in AsyncLoopbackConnection.pipes) {
        throw new Error(&#x27;duplicate&#x27;);
    }
    AsyncLoopbackConnection.pipes[this.id] = this;
    var pair = this.<span class="apidocCodeKeywordSpan">pair</span>();
    if (pair &#x26;&#x26; pair.queue.length) {
        pair.write();
    }
}
AsyncLoopbackConnection.pipes = {};

env.streams.loopback = AsyncLoopbackConnection;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.env.streams.loopback.prototype.receive" id="apidoc.element.swarm.env.streams.loopback.prototype.receive">
        function <span class="apidocSignatureSpan">swarm.env.streams.loopback.prototype.</span>receive
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">receive = function (string) {
    this.lstn.data &#x26;&#x26; this.lstn.data(string);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
obj &#x26;&#x26; self.queue.push(obj.toString());
setTimeout(function () {
    var pair = self.pair();
    if (!pair) {
        return;
    }
    while (self.queue.length) {
        pair.<span class="apidocCodeKeywordSpan">receive</span>(self.queue.shift());
    }
}, 1);
};

AsyncLoopbackConnection.prototype.close = function () {
delete AsyncLoopbackConnection.pipes[this.id];
var pair = this.pair();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.env.streams.loopback.prototype.write" id="apidoc.element.swarm.env.streams.loopback.prototype.write">
        function <span class="apidocSignatureSpan">swarm.env.streams.loopback.prototype.</span>write
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (obj) {
    var self = this;
    obj &#x26;&#x26; self.queue.push(obj.toString());
    setTimeout(function () {
        var pair = self.pair();
        if (!pair) {
            return;
        }
        while (self.queue.length) {
            pair.receive(self.queue.shift());
        }
    }, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.queue = [];
    if (this.id in AsyncLoopbackConnection.pipes) {
        throw new Error(&#x27;duplicate&#x27;);
    }
    AsyncLoopbackConnection.pipes[this.id] = this;
    var pair = this.pair();
    if (pair &#x26;&#x26; pair.queue.length) {
        pair.<span class="apidocCodeKeywordSpan">write</span>();
    }
}
AsyncLoopbackConnection.pipes = {};

env.streams.loopback = AsyncLoopbackConnection;

AsyncLoopbackConnection.prototype.pair = function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.swarm.env.streams.wss.prototype" id="apidoc.module.swarm.env.streams.wss.prototype">module swarm.env.streams.wss.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.swarm.env.streams.wss.prototype.on" id="apidoc.element.swarm.env.streams.wss.prototype.on">
        function <span class="apidocSignatureSpan">swarm.env.streams.wss.prototype.</span>on
        <span class="apidocSignatureSpan">(evname, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (evname, fn) {
    if (evname in this.lstn) {
        var self = this,
            prev_fn = this.lstn[evname];
        this.lstn[evname] = function () {
            prev_fn.apply(self, arguments);
            fn.apply(self, arguments);
        };
    } else {
        this.lstn[evname] = fn;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
someMouse.set({x:1,y:2});

// 3.b. This object is global (we supply a certain id) so we
// may need to wait for its state to arrive from the server
var mickey = new Mouse(&#x27;Mickey&#x27;);

// 4.b. ...wait for the state to arrive
mickey.<span class="apidocCodeKeywordSpan">on</span>(&#x27;init&#x27;, function () {
// ...so we may touch it finally.
mickey.set({x: 3, y: 4});
});

// 5. let&#x27;s subscribe to the object&#x27;s change events
mickey.on(function (spec, val, source) {
// this will be triggered by every state change, be it
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.swarm.env.streams.wss.prototype.write" id="apidoc.element.swarm.env.streams.wss.prototype.write">
        function <span class="apidocSignatureSpan">swarm.env.streams.wss.prototype.</span>write
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data) {
    if (this.buf) {
        this.buf.push(data);
    } else {
        this.ws.send(data);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.queue = [];
    if (this.id in AsyncLoopbackConnection.pipes) {
        throw new Error(&#x27;duplicate&#x27;);
    }
    AsyncLoopbackConnection.pipes[this.id] = this;
    var pair = this.pair();
    if (pair &#x26;&#x26; pair.queue.length) {
        pair.<span class="apidocCodeKeywordSpan">write</span>();
    }
}
AsyncLoopbackConnection.pipes = {};

env.streams.loopback = AsyncLoopbackConnection;

AsyncLoopbackConnection.prototype.pair = function () {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
